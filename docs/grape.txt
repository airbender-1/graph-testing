Help on package grape:

NAME
    grape - GRAPE main module.

DESCRIPTION
    For now, this is a simple wrapper of GRAPE main two sub-modules that for
    software engineering porposes are kept as two separate packages.
    
    These packages are mimed here by the two sub-directories, ensmallen and embiggen.

PACKAGE CONTENTS
    __version__

CLASSES
    builtins.object
        embiggen.utils.abstract_models.embedding_result.EmbeddingResult
        embiggen.visualizations.graph_visualizer.GraphVisualizer
        ensmallen.Chain
        ensmallen.Circle
        ensmallen.Clique
        ensmallen.DendriticTree
        ensmallen.Graph
        ensmallen.GraphBuilder
        ensmallen.GraphCSVBuilder
        ensmallen.NodeTuple
        ensmallen.ShortestPathsDjkstra
        ensmallen.ShortestPathsResultBFS
        ensmallen.Star
        ensmallen.Tendril
    
    class Chain(builtins.object)
     |  Methods defined here:
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  get_chain_node_ids(self, /)
     |      Return the node IDs of the nodes composing the chain
     |  
     |  get_chain_node_names(self, /)
     |      Return the node names of the nodes composing the chain
     |  
     |  get_first_k_chain_node_ids(self, /, k)
     |      Return the first `k` node IDs of the nodes composing the chain.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_first_k_chain_node_names(self, /, k)
     |      Return the first `k` node names of the nodes composing the chain.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_root_node_id(self, /)
     |      Return the first node ID of the chain
     |  
     |  get_root_node_name(self, /)
     |      Return the first node name of the chain
     |  
     |  len(self, /)
     |      Return length of the chain
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class Circle(builtins.object)
     |  Methods defined here:
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  get_circle_node_ids(self, /)
     |      Return the node IDs of the nodes composing the Circle
     |  
     |  get_circle_node_names(self, /)
     |      Return the node names of the nodes composing the Circle
     |  
     |  get_first_k_circle_node_ids(self, /, k)
     |      Return the first `k` node IDs of the nodes composing the Circle.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_first_k_circle_node_names(self, /, k)
     |      Return the first `k` node names of the nodes composing the Circle.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_root_node_id(self, /)
     |      Return the first node ID of the Circle
     |  
     |  get_root_node_name(self, /)
     |      Return the first node name of the circle
     |  
     |  len(self, /)
     |      Return length of the Circle
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class Clique(builtins.object)
     |  Methods defined here:
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  get_node_ids(self, /)
     |      Return the node IDs of the nodes composing the clique
     |  
     |  get_node_names(self, /)
     |      Return the node names of the nodes composing the Clique
     |  
     |  len(self, /)
     |      Return length of the Clique
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class DendriticTree(builtins.object)
     |  Methods defined here:
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  get_dendritic_tree_type(self, /)
     |      Return the type of the dendritic tree
     |  
     |  get_dentritic_trees_node_ids(self, /)
     |      Return the node IDs of the nodes composing the DendriticTree
     |  
     |  get_dentritic_trees_node_names(self, /)
     |      Return the node names of the nodes composing the DendriticTree
     |  
     |  get_depth(self, /)
     |      Return the depth of the dentritic tree
     |  
     |  get_first_k_dentritic_trees_node_ids(self, /, k)
     |      Return the first `k` node IDs of the nodes composing the DendriticTree.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_first_k_dentritic_trees_node_names(self, /, k)
     |      Return the first `k` node names of the nodes composing the DendriticTree.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_number_of_involved_edges(self, /)
     |      Return number of edges involved in the dendritic tree
     |  
     |  get_number_of_involved_nodes(self, /)
     |      Return number of nodes involved in the dendritic tree
     |  
     |  get_root_node_id(self, /)
     |      Return the root node ID of the dendritic tree
     |  
     |  get_root_node_name(self, /)
     |      Return the root node name of the DendriticTree
     |  
     |  is_dendritic_star(self, /)
     |      Return whether the current dendritic tree is actually a dendritic star
     |  
     |  is_dendritic_tendril_star(self, /)
     |      Return whether the current dendritic tree is actually a dendritic tendril star
     |  
     |  is_dendritic_tree(self, /)
     |      Return whether the current dendritic tree is a proper dentritic tree
     |  
     |  is_free_floating_chain(self, /)
     |      Return whether the current dendritic tree is actually a free-floating chain
     |  
     |  is_star(self, /)
     |      Return whether the current dendritic tree is actually a star
     |  
     |  is_tendril(self, /)
     |      Return whether the current dendritic tree is actually a tendril
     |  
     |  is_tendril_star(self, /)
     |      Return whether the current dendritic tree is actually a star of tendrils
     |  
     |  is_tree(self, /)
     |      Return whether the current dendritic tree is actually a tree
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class EmbeddingResult(builtins.object)
     |  EmbeddingResult(embedding_method_name: str, node_embeddings: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, edge_embeddings: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, node_type_embeddings: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, edge_type_embeddings: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None)
     |  
     |  Methods defined here:
     |  
     |  __init__(self, embedding_method_name: str, node_embeddings: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, edge_embeddings: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, node_type_embeddings: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, edge_type_embeddings: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None)
     |      Create new Embedding Result.
     |      
     |      Parameters
     |      ---------------------------
     |      embedding_method_name: str
     |          The embedding algorithm used.
     |      node_embeddings: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The node embedding(s).
     |          Some algorithms return multiple node embedding.
     |      edge_embeddings: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The edge embedding(s).
     |          Some algorithms return multiple edge embedding.
     |      node_type_embeddings: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The node type embedding(s).
     |          Some algorithms return multiple node type embedding.
     |      edge_type_embeddings: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The edge type embedding(s).
     |          Some algorithms return multiple edge type embedding.
     |  
     |  dump(self) -> Dict[str, Union[ForwardRef('CachableList'), ForwardRef('CachableValue')]]
     |      Method to cache the embedding result object.
     |  
     |  get_all_edge_embedding(self) -> List[Union[pandas.core.frame.DataFrame, numpy.ndarray]]
     |      Return a list with all the computed edge embedding.
     |      
     |      Implementation details
     |      ----------------------
     |      Different embedding methods compute a different number of edge embeddings.
     |      For example, a method such as HyperSketching produces three different edge
     |      embeddings for each edge: one for the exclusive overlaps matrix, one for the
     |      exclusive left difference and one for the exclusive right difference.
     |      
     |      For this reason, to standardize the access to the edge embeddings,
     |      this method returns a list of edge embeddings.
     |      
     |      Raises
     |      ----------------
     |      ValueError
     |          If the edge embeddings were not computed by the embedding method.
     |  
     |  get_all_edge_type_embeddings(self) -> List[Union[pandas.core.frame.DataFrame, numpy.ndarray]]
     |      Return a list with all the computed edge type embedding.
     |  
     |  get_all_node_embedding(self) -> List[Union[pandas.core.frame.DataFrame, numpy.ndarray]]
     |      Return a list with all the computed node embedding.
     |      
     |      Implementation details
     |      ----------------------
     |      Different embedding methods compute a different number of node embeddings.
     |      For example, the LINE method computes a single embedding for each node,
     |      while an embedding based on SkipGram, such as Node2Vec SkipGram,
     |      computes two embeddings for each node: one for the node context and one for the node itself.
     |      
     |      For this reason, to standardize the access to the node embeddings,
     |      this method returns a list of node embeddings.
     |      
     |      Raises
     |      ----------------
     |      ValueError
     |          If the node embeddings were not computed by the embedding method.
     |  
     |  get_all_node_type_embeddings(self) -> List[Union[pandas.core.frame.DataFrame, numpy.ndarray]]
     |      Return a list with all the computed node type embedding.
     |  
     |  get_edge_embedding_from_index(self, index: int) -> Union[pandas.core.frame.DataFrame, numpy.ndarray]
     |      Return a computed edge embedding curresponding to the provided index.
     |      
     |      Parameters
     |      ----------------
     |      index: int
     |          The index of the edge embedding to return.
     |      
     |      Raises
     |      ----------------
     |      IndexError
     |          If the provided index is higher than the number of available embeddings.
     |  
     |  get_edge_type_embedding_from_index(self, index: int) -> Union[pandas.core.frame.DataFrame, numpy.ndarray]
     |      Return a computed edge type embedding curresponding to the provided index.
     |      
     |      Parameters
     |      ----------------
     |      index: int
     |          The index of the edge type embedding to return.
     |      
     |      Raises
     |      ----------------
     |      IndexError
     |          If the provided index is higher than the number of available embeddings.
     |  
     |  get_node_embedding_from_index(self, index: int) -> Union[pandas.core.frame.DataFrame, numpy.ndarray]
     |      Return a computed node embedding curresponding to the provided index.
     |      
     |      Parameters
     |      ----------------
     |      index: int
     |          The index of the node embedding to return.
     |      
     |      Raises
     |      ----------------
     |      IndexError
     |          If the provided index is higher than the number of available embeddings.
     |  
     |  get_node_type_embedding_from_index(self, index: int) -> Union[pandas.core.frame.DataFrame, numpy.ndarray]
     |      Return a computed node type embedding curresponding to the provided index.
     |      
     |      Parameters
     |      ----------------
     |      index: int
     |          The index of the node type embedding to return.
     |      
     |      Raises
     |      ----------------
     |      IndexError
     |          If the provided index is higher than the number of available embeddings.
     |  
     |  get_single_embedding(self) -> Union[numpy.ndarray, pandas.core.frame.DataFrame]
     |      Returns the single non-None embedding.
     |  
     |  is_single_embedding(self) -> bool
     |      Returns whether the wrapper contains a single embedding.
     |  
     |  number_of_embeddings(self) -> int
     |      Returns the number of embedding included in the wrapper.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  load(cached_embedding_result: Dict[str, Union[str, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]]]]) -> 'EmbeddingResult'
     |      Return restored embedding result.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  embedding_method_name
     |      Returns the name of the method used for this embedding.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Graph(builtins.object)
     |  This is the main struct in Ensmallen, it allows to load and manipulate Graphs efficently.
     |  You are not supposed to directly instantiate this struct but instead you should use the
     |  static method `from_csv`, which allows to load the graph from an edge-list.
     |  
     |  To get information about a loaded graph, you can call the `textual_report` method which
     |  generates an human-readable HTML report.
     |  
     |  By default we use EliasFano to store the Adjacency Matrix, this allows to save memory but
     |  is slower than a CSR. For this reason you can use the `enable` method to enable optimizzations
     |  which speeds up the operations at the cost of more memory usage. You can check the memory usage
     |  in bytes using `get_total_memory_used` and you can get a detailed memory report of each data-structure
     |  inside Graph using `memory_stats`.
     |  
     |  You can pre-compute the memory needed (in bits) to store the adjacency matrix of a Graph with $|E|$ edges and $|V|$ nodes:
     |   $$2 |E| + |E| \\left\\lceil \\log_2 \\frac{|V|^2}{|E|} \\right\\rceil$$
     |  
     |  Most Graph properties are automatically cached to speed up.
     |  
     |  Methods defined here:
     |  
     |  __and__(self, value, /)
     |      Return self&value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __getitem__(self, key, /)
     |      Return self[key].
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __or__(self, value, /)
     |      Return self|value.
     |  
     |  __rand__(self, value, /)
     |      Return value&self.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __ror__(self, value, /)
     |      Return value|self.
     |  
     |  __rsub__(self, value, /)
     |      Return value-self.
     |  
     |  __rxor__(self, value, /)
     |      Return value^self.
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  __sub__(self, value, /)
     |      Return self-value.
     |  
     |  __xor__(self, value, /)
     |      Return self^value.
     |  
     |  add_edge_type_name_inplace(self, /, edge_type_name)
     |      Add edge type name to the graph in place.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: str
     |          The edge type name to add.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given edge type name already exists in the graph.
     |  
     |  add_node_type_id_from_node_name_prefixes(self, /, node_type_id, node_name_prefixes)
     |      Assigns given node type id to the nodes with given prefixes.
     |      
     |      Parameters
     |      ----------
     |      node_type_id: int
     |          The node type ID to assign.
     |      node_name_prefixes: List[str]
     |          The node name prefixes to check for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given list of node name prefixes is empty.
     |  
     |  add_node_type_id_from_node_name_prefixes_inplace(self, /, node_type_id, node_name_prefixes)
     |      Assigns inplace given node type id to the nodes with given prefixes.
     |      
     |      Parameters
     |      ----------
     |      node_type_id: int
     |          The node type ID to assign.
     |      node_name_prefixes: List[str]
     |          The node name prefixes to check for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given list of node name prefixes is empty.
     |  
     |  add_node_type_name_from_node_name_prefixes(self, /, node_type_name, node_name_prefixes)
     |      Assigns given node type name to the nodes with given prefixes.
     |      
     |      Parameters
     |      ----------
     |      node_type_name: str
     |          The node type ID to assign.
     |      node_name_prefixes: List[str]
     |          The node name prefixes to check for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given list of node name prefixes is empty.
     |  
     |  add_node_type_name_from_node_name_prefixes_inplace(self, /, node_type_name, node_name_prefixes)
     |      Assigns inplace given node type name to the nodes with given prefixes.
     |      
     |      Parameters
     |      ----------
     |      node_type_name: str
     |          The node type ID to assign.
     |      node_name_prefixes: List[str]
     |          The node name prefixes to check for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given list of node name prefixes is empty.
     |  
     |  add_node_type_name_inplace(self, /, node_type_name)
     |      Add node type name to the graph in place.
     |      
     |      Parameters
     |      ----------
     |      node_type_name: str
     |          The node type name to add.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node type name already exists in the graph.
     |  
     |  add_selfloops(self, /, edge_type_name, weight)
     |      Returns new graph with added in missing self-loops with given edge type and weight.
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the edge type for the new selfloops is provided but the graph does not have edge types.
     |      ValueError
     |          If the edge weight for the new selfloops is provided but the graph does not have edge weights.
     |      ValueError
     |          If the edge weight for the new selfloops is NOT provided but the graph does have edge weights.
     |  
     |  are_isomorphic_from_node_ids(self, /, first_node_id, second_node_id)
     |      Returns whether two provided nodes IDs are isomorphic to one another.
     |      
     |      Parameters
     |      ----------
     |      first_node_id: int
     |          The first node to check for.
     |      second_node_id: int
     |          The first node to check for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          ValueError: This method assumes that the two provided node IDs are effectively within
     |  
     |  are_isomorphic_from_node_names(self, /, first_node_name, second_node_name)
     |      Returns whether two provided nodes names are isomorphic to one another.
     |      
     |      Parameters
     |      ----------
     |      first_node_name: str
     |          The first node name to check for.
     |      second_node_name: str
     |          The first node name to check for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          ValueError: This method assumes that the two provided node names are effectively within
     |  
     |  are_nodes_remappable(self, /, other)
     |      Return whether nodes are remappable to those of the given graph.
     |      
     |      Parameters
     |      ----------
     |      other: Graph
     |          graph towards remap the nodes to.
     |  
     |  are_unchecked_isomorphic_from_node_ids(self, /, first_node_id, second_node_id)
     |      Returns whether two provided nodes IDs are isomorphic to one another.
     |      
     |      Parameters
     |      ----------
     |      first_node_id: int
     |          The first node to check for.
     |      second_node_id: int
     |          The first node to check for.
     |      
     |      
     |      Safety
     |      ------
     |      This method assumes that the two provided node IDs are effectively within
     |       the set of nodes in the graph. Out of bound errors might be raised with
     |       improper parametrization of the method.
     |  
     |  build_bipartite_graph_from_edge_node_ids(self, /, source_node_ids, destination_node_ids, directed)
     |      Returns bipartite graph between the provided source and destination node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_ids: List[int]
     |          The source node IDs.
     |      destination_node_ids: List[int]
     |          The destination node IDs.
     |      directed: bool
     |          Whether to make the graph directed or undirected.
     |  
     |  build_bipartite_graph_from_edge_node_names(self, /, source_node_names, destination_node_names, directed)
     |      Returns bipartite graph between the provided source and destination node names.
     |      
     |      Parameters
     |      ----------
     |      source_node_names: List[&str]
     |          The source node names.
     |      destination_node_names: List[&str]
     |          The destination node names.
     |      directed: bool
     |          Whether to make the graph directed or undirected.
     |  
     |  build_bipartite_graph_from_edge_node_prefixes(self, /, source_node_prefixes, destination_node_prefixes, directed)
     |      Returns bipartite graph between the provided source and destination node prefixes.
     |      
     |      Parameters
     |      ----------
     |      source_node_prefixes: List[str]
     |          The source node prefixes.
     |      destination_node_prefixes: List[str]
     |          The destination node prefixes.
     |      directed: bool
     |          Whether to make the graph directed or undirected.
     |  
     |  build_bipartite_graph_from_edge_node_types(self, /, source_node_types, destination_node_types, directed)
     |      Returns bipartite graph between the provided source and destination node types.
     |      
     |      Parameters
     |      ----------
     |      source_node_types: List[Optional[&str]]
     |          The source node types.
     |      destination_node_types: List[Optional[&str]]
     |          The destination node types.
     |      directed: bool
     |          Whether to make the graph directed or undirected.
     |  
     |  build_clique_graph_from_node_ids(self, /, node_ids, directed)
     |      Returns clique graph between the provided node IDs.
     |      
     |      Parameters
     |      ----------
     |      node_ids: List[int]
     |          The node IDs.
     |      directed: bool
     |          Whether to make the graph directed or undirected.
     |  
     |  build_clique_graph_from_node_names(self, /, node_names, directed)
     |      Returns clique graph between the provided node names.
     |      
     |      Parameters
     |      ----------
     |      node_names: List[&str]
     |          The node names.
     |      directed: bool
     |          Whether to make the graph directed or undirected.
     |  
     |  build_clique_graph_from_node_prefixes(self, /, node_prefixes, directed)
     |      Returns clique graph between the nodes with the provided prefixes.
     |      
     |      Parameters
     |      ----------
     |      node_prefixes: List[str]
     |          The node name prefixes.
     |      directed: bool
     |          Whether to make the graph directed or undirected.
     |  
     |  build_clique_graph_from_node_type_names(self, /, node_type_names, directed)
     |      Returns clique graph between the nodes with the provided node types.
     |      
     |      Parameters
     |      ----------
     |      node_type_names: List[Optional[&str]]
     |          The node name types.
     |      directed: bool
     |          Whether to make the graph directed or undirected.
     |  
     |  complete_walks(self, /, *, walk_length, return_weight, explore_weight, change_edge_type_weight, change_node_type_weight, random_state, iterations, dense_node_mapping, max_neighbours, normalize_by_degree)
     |      Return complete random walks done on the graph using Rust.
     |      
     |      Parameters
     |      ----------
     |      walk_length: int
     |          Maximal length of the random walk.
     |          On graphs without traps, all walks have this length.
     |      return_weight: float = 1.0
     |          Weight on the probability of returning to node coming from
     |          Having this higher tends the walks to be
     |          more like a Breadth-First Search.
     |          Having this very high  (> 2) makes search very local.
     |          Equal to the inverse of p in the Node2Vec paper.
     |      explore_weight: float = 1.0
     |          Weight on the probability of visiting a neighbor node
     |          to the one we're coming from in the random walk
     |          Having this higher tends the walks to be
     |          more like a Depth-First Search.
     |          Having this very high makes search more outward.
     |          Having this very low makes search very local.
     |          Equal to the inverse of q in the Node2Vec paper.
     |      change_edge_type_weight: float = 1.0
     |          Weight on the probability of visiting a neighbor node of a
     |          different type than the previous node. This only applies to
     |          colored graphs, otherwise it has no impact.
     |      change_node_type_weight: float = 1.0
     |          Weight on the probability of visiting a neighbor edge of a
     |          different type than the previous edge. This only applies to
     |          multigraphs, otherwise it has no impact.
     |      random_state: int = 42
     |          random_state to use to reproduce the walks.
     |      iterations: int = 1
     |          Number of cycles on the graphs to execute.
     |      dense_node_mapping: Dict[int, int] = None
     |          Mapping to use for converting sparse walk space into a dense space.
     |          This object can be created using the method available from graph
     |          called `get_dense_node_mapping` that returns a mapping from
     |          the non trap nodes (those from where a walk could start) and
     |          maps these nodes into a dense range of values.
     |      max_neighbours: Optional[int] = 100
     |          Maximum number of randomly sampled neighbours to consider.
     |          If this parameter is used, the walks becomes probabilistic in nature
     |          and becomes an approximation of an exact walk.
     |      normalize_by_degree: Optional[bool] = False
     |          Whether to normalize the random walks by the node degree.
     |      
     |      Raises
     |      ------
     |      TODO: Update raises
     |      
     |      Returns
     |      -------
     |      List of list of walks containing the numeric IDs of nodes.
     |  
     |  connected_holdout(self, /, train_size, random_state, edge_types, include_all_edge_types, minimum_node_degree, maximum_node_degree, verbose)
     |      Returns holdout for training ML algorithms on the graph structure.
     |      
     |      The holdouts returned are a tuple of graphs. The first one, which
     |      is the training graph, is garanteed to have the same number of
     |      graph components as the initial graph. The second graph is the graph
     |      meant for testing or validation of the algorithm, and has no garantee
     |      to be connected. It will have at most (1-train_size) edges,
     |      as the bound of connectivity which is required for the training graph
     |      may lead to more edges being left into the training partition.
     |      
     |      In the option where a list of edge types has been provided, these
     |      edge types will be those put into the validation set.
     |      
     |      Parameters
     |      ----------
     |      train_size: float
     |          Rate target to reserve for training.
     |      random_state: Optional[int]
     |          The random_state to use for the holdout,
     |      edge_types: Optional[&List[Optional[&str]]]
     |          Edge types to be selected for in the validation set.
     |      include_all_edge_types: Optional[bool]
     |          Whether to include all the edges between two nodes.
     |      minimum_node_degree: Optional[int]
     |          The minimum node degree of either the source or destination node to be sampled. By default 0.
     |      maximum_node_degree: Optional[int]
     |          The maximum node degree of either the source or destination node to be sampled. By default, the number of nodes.
     |      verbose: Optional[bool]
     |          Whether to show the loading bar.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the edge types have been specified but the graph does not have edge types.
     |      ValueError
     |          If the required training size is not a real value between 0 and 1.
     |      ValueError
     |          If the current graph does not allow for the creation of a spanning tree for the requested training size.
     |  
     |  contains(self, /, other)
     |      Return true if given graph edges are all contained within current graph.
     |      
     |      Parameters
     |      ----------
     |      other: Graph
     |          The graph to check against.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If a graph is directed and the other is undirected.
     |      ValueError
     |          If one of the two graphs has edge weights and the other does not.
     |      ValueError
     |          If one of the two graphs has node types and the other does not.
     |      ValueError
     |          If one of the two graphs has edge types and the other does not.
     |  
     |  contains_identity_matrix(self, /)
     |      Returns whether the graph contains the identity matrix.
     |  
     |  disable_all(self, /)
     |      Disable all extra perks, reducing memory impact but incresing time requirements
     |  
     |  divide_edge_weights(self, /, denominator)
     |      Divide edge weights.
     |      
     |      Note that the modification does not happen inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge weights.
     |  
     |  divide_edge_weights_inplace(self, /, denominator)
     |      Divide edge weights in place.
     |      
     |      Note that the modification happens inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge weights.
     |  
     |  dump_edges(self, /, path, *, verbose, separator, header, sources_column_number, sources_column, destinations_column_number, destinations_column, weights_column_number, weights_column, edge_types_column_number, edge_type_column, numeric_node_ids, directed)
     |      Write to disk the edges (and optionally the metadata) of the graph.
     |      
     |      Parameters
     |      ----------
     |      path: str
     |          Path where to save the edges and their metadata.
     |      verbose: bool = True
     |          Wether to show a loading bar while writing to file.
     |      separator: str = '\t'
     |          What separator to use while writing out to file.
     |      header: bool = True
     |          Wether to write out the header of the file.
     |      sources_column_number: int = 0
     |          The column number where to write out the file.
     |      sources_column: str = "subject"
     |          The name of the column where to write out the file.
     |      destinations_column_number: int = 1
     |          The column number where to write out the file.
     |      destinations_column: str = "object"
     |          The name of the column where to write out the file.
     |      edge_types_column_number: int = 2
     |          The column number where to write out the file.
     |      edge_type_column: str = "label"
     |          The name of the column where to write out the file.
     |      weights_column_number: int = 3
     |          The column number where to write out the file.
     |      weights_column: str = "weight"
     |          The name of the column where to write out the file.
     |      numeric_node_ids: bool = False
     |          whether to save the internal numeric Ids instead of the string names.
     |      directed: bool = False
     |          whether to save graph as directed or undirected.
     |      
     |      Raises
     |      ------
     |      TODO: update the set of exceptions
     |  
     |  dump_nodes(self, /, path, *, verbose, separator, header, nodes_column_number, nodes_column, node_types_column_number, node_type_column)
     |      Write to disk the nodes (and optionally the metadata) of the graph.
     |      
     |      Parameters
     |      ----------
     |      path: str
     |          Path where to save the nodes and their metadata.
     |      verbose: bool = True
     |          Wether to show a loading bar while writing to file.
     |      separator: str = '\t'
     |          What separator to use while writing out to file.
     |      header: bool = True
     |          Wether to write out the header of the file.
     |      nodes_column_number: int = 0
     |          The column number where to write the nodes.
     |      nodes_column: str = "id"
     |          The name of the column of the nodes.
     |      node_types_column_number: int = 1
     |          The column number where to write the node types.
     |      node_type_column: str = "category"
     |          The name of the column of the node types.
     |      
     |      Raises
     |      ------
     |      TODO: update the set of exceptions
     |  
     |  enable(self, /, vector_sources, vector_reciprocal_sqrt_degrees)
     |      Enable extra perks that buys you time as you accept to spend more memory.
     |      
     |      Parameters
     |      ----------
     |      vector_sources: Optional[bool]
     |          Whether to cache sources into a vector for faster walks.
     |      vector_reciprocal_sqrt_degrees: Optional[bool]
     |          Whether to cache reciprocal_sqrt_degrees into a vector for faster laplacian kernel computation.
     |  
     |  filter_from_ids(self, /, node_ids_to_keep, node_ids_to_remove, node_names_to_keep_from_graph, node_names_to_remove_from_graph, node_prefixes_to_keep, node_prefixes_to_remove, node_type_ids_to_keep, node_type_ids_to_remove, node_type_id_to_keep, node_type_id_to_remove, source_node_ids_to_keep, source_node_ids_to_remove, source_node_names_to_keep_from_graph, source_node_names_to_remove_from_graph, source_node_prefixes_to_keep, source_node_prefixes_to_remove, source_node_type_ids_to_keep, source_node_type_ids_to_remove, source_node_type_id_to_keep, source_node_type_id_to_remove, destination_node_ids_to_keep, destination_node_ids_to_remove, destination_node_names_to_keep_from_graph, destination_node_names_to_remove_from_graph, destination_node_prefixes_to_keep, destination_node_prefixes_to_remove, destination_node_type_ids_to_keep, destination_node_type_ids_to_remove, destination_node_type_id_to_keep, destination_node_type_id_to_remove, edge_ids_to_keep, edge_ids_to_remove, edge_node_ids_to_keep, edge_node_ids_to_remove, edge_type_ids_to_keep, edge_type_ids_to_remove, min_edge_weight, max_edge_weight, min_node_degree, max_node_degree, filter_singleton_nodes, filter_singleton_nodes_with_selfloop, filter_selfloops, filter_parallel_edges)
     |      Returns a **NEW** Graph that does not have the required attributes.
     |      
     |      Parameters
     |      ----------
     |      node_ids_to_keep: Optional[List[int]]
     |          List of node IDs to keep during filtering.
     |      node_ids_to_remove: Optional[List[int]]
     |          List of node IDs to remove during filtering.
     |      node_names_to_keep_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be kept.
     |      node_names_to_remove_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be removed.
     |      node_prefixes_to_keep: Optional[List[str]]
     |          List of node prefixes to keep during filtering.
     |      node_prefixes_to_remove: Optional[List[str]]
     |          List of node prefixes to remove during filtering.
     |      node_type_ids_to_keep: Optional[List[Optional[List[int]]]]
     |          List of node type IDs to keep during filtering. The node types must match entirely the given node types vector provided.
     |      node_type_ids_to_remove: Optional[List[Optional[List[int]]]]
     |          List of node type IDs to remove during filtering. The node types must match entirely the given node types vector provided.
     |      node_type_id_to_keep: Optional[List[Optional[int]]]
     |          List of node type IDs to keep during filtering. Any of node types must match with one of the node types given.
     |      node_type_id_to_remove: Optional[List[Optional[int]]]
     |          List of node type IDs to remove during filtering. Any of node types must match with one of the node types given.
     |      source_node_ids_to_keep: Optional[List[int]]
     |          List of source node IDs to keep during filtering.
     |      source_node_ids_to_remove: Optional[List[int]]
     |          List of source node IDs to remove during filtering.
     |      source_node_names_to_keep_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be kept when they are source nodes in this graph instance.
     |      source_node_names_to_remove_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be removed when they are source nodes in this graph instance.
     |      source_node_prefixes_to_keep: Optional[List[str]]
     |          List of source node prefixes to keep during filtering.
     |      source_node_prefixes_to_remove: Optional[List[str]]
     |          List of source node prefixes to remove during filtering.
     |      source_node_type_ids_to_keep: Optional[List[Optional[List[int]]]]
     |          List of source node type IDs to keep during filtering. The node types must match entirely the given node types vector provided.
     |      source_node_type_ids_to_remove: Optional[List[Optional[List[int]]]]
     |          List of source node type IDs to remove during filtering. The node types must match entirely the given node types vector provided.
     |      source_node_type_id_to_keep: Optional[List[Optional[int]]]
     |          List of source node type IDs to keep during filtering. Any of source node types must match with one of the node types given.
     |      source_node_type_id_to_remove: Optional[List[Optional[int]]]
     |          List of source node type IDs to remove during filtering. Any of source node types must match with one of the node types given.
     |      destination_node_ids_to_keep: Optional[List[int]]
     |          List of destination node IDs to keep during filtering.
     |      destination_node_ids_to_remove: Optional[List[int]]
     |          List of destination node IDs to remove during filtering.
     |      destination_node_names_to_keep_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be kept when they are destination nodes in this graph instance.
     |      destination_node_names_to_remove_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be removed when they are destination nodes in this graph instance.
     |      destination_node_prefixes_to_keep: Optional[List[str]]
     |          List of destination node prefixes to keep during filtering.
     |      destination_node_prefixes_to_remove: Optional[List[str]]
     |          List of destination node prefixes to remove during filtering.
     |      destination_node_type_ids_to_keep: Optional[List[Optional[List[int]]]]
     |          List of destination node type IDs to keep during filtering. The node types must match entirely the given node types vector provided.
     |      destination_node_type_ids_to_remove: Optional[List[Optional[List[int]]]]
     |          List of destination node type IDs to remove during filtering. The node types must match entirely the given node types vector provided.
     |      destination_node_type_id_to_keep: Optional[List[Optional[int]]]
     |          List of destination node type IDs to keep during filtering. Any of destination node types must match with one of the node types given.
     |      destination_node_type_id_to_remove: Optional[List[Optional[int]]]
     |          List of destination node type IDs to remove during filtering. Any of destination node types must match with one of the node types given.
     |      edge_ids_to_keep: Optional[List[int]]
     |          List of edge IDs to keep during filtering.
     |      edge_ids_to_remove: Optional[List[int]]
     |          List of edge IDs to remove during filtering.
     |      edge_node_ids_to_keep: Optional[List[Tuple[int, int]]]
     |          List of tuple of node IDs to keep during filtering.
     |      edge_node_ids_to_remove: Optional[List[Tuple[int, int]]]
     |          List of tuple of node IDs to remove during filtering.
     |      edge_type_ids_to_keep: Optional[List[Optional[int]]]
     |          List of edge type IDs to keep during filtering.
     |      edge_type_ids_to_remove: Optional[List[Optional[int]]]
     |          List of edge type IDs to remove during filtering.
     |      min_edge_weight: Optional[float]
     |          Minimum edge weight. Values lower than this are removed.
     |      max_edge_weight: Optional[float]
     |          Maximum edge weight. Values higher than this are removed.
     |      min_node_degree: Optional[int]
     |          Minimum node degree. Values lower than this are removed.
     |      max_node_degree: Optional[int]
     |          Maximum node degree. Values higher than this are removed.
     |      filter_singleton_nodes: Optional[bool]
     |          Whether to filter out singleton nodes.
     |      filter_singleton_nodes_with_selfloop: Optional[bool]
     |          Whether to filter out singleton nodes with selfloops.
     |      filter_selfloops: Optional[bool]
     |          Whether to filter out selfloops.
     |      filter_parallel_edges: Optional[bool]
     |          Whether to filter out parallel edges.
     |      verbose: Optional[bool]
     |          Whether to show loading bar while building the graphs.
     |  
     |  filter_from_names(self, /, node_names_to_keep, node_names_to_remove, node_names_to_keep_from_graph, node_names_to_remove_from_graph, node_prefixes_to_keep, node_prefixes_to_remove, node_type_names_to_keep, node_type_names_to_remove, node_type_name_to_keep, node_type_name_to_remove, source_node_names_to_keep, source_node_names_to_remove, source_node_names_to_keep_from_graph, source_node_names_to_remove_from_graph, source_node_prefixes_to_keep, source_node_prefixes_to_remove, source_node_type_names_to_keep, source_node_type_names_to_remove, source_node_type_name_to_keep, source_node_type_name_to_remove, destination_node_names_to_keep, destination_node_names_to_remove, destination_node_names_to_keep_from_graph, destination_node_names_to_remove_from_graph, destination_node_prefixes_to_keep, destination_node_prefixes_to_remove, destination_node_type_names_to_keep, destination_node_type_names_to_remove, destination_node_type_name_to_keep, destination_node_type_name_to_remove, edge_node_names_to_keep, edge_node_names_to_remove, edge_type_names_to_keep, edge_type_names_to_remove, min_edge_weight, max_edge_weight, min_node_degree, max_node_degree, filter_singleton_nodes, filter_singleton_nodes_with_selfloop, filter_selfloops, filter_parallel_edges)
     |      Returns a **NEW** Graph that does not have the required attributes.
     |      
     |      Parameters
     |      ----------
     |      node_names_to_keep: Optional[List[&str]]
     |          List of node names to keep during filtering.
     |      node_names_to_remove: Optional[List[&str]]
     |          List of node names to remove during filtering.
     |      node_names_to_keep_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be kept.
     |      node_names_to_remove_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be removed.
     |      node_prefixes_to_keep: Optional[List[str]]
     |          List of node prefixes to keep during filtering.
     |      node_prefixes_to_remove: Optional[List[str]]
     |          List of node prefixes to remove during filtering.
     |      node_type_names_to_keep: Optional[List[Optional[List[&str]]]]
     |          List of node type names to keep during filtering. The node types must match entirely the given node types vector provided.
     |      node_type_names_to_remove: Optional[List[Optional[List[&str]]]]
     |          List of node type names to remove during filtering. The node types must match entirely the given node types vector provided.
     |      node_type_name_to_keep: Optional[&List[Optional[&str]]]
     |          List of node type name to keep during filtering. Any of node types must match with one of the node types given.
     |      node_type_name_to_remove: Optional[&List[Optional[&str]]]
     |          List of node type name to remove during filtering. Any of node types must match with one of the node types given.
     |      source_node_names_to_keep: Optional[List[&str]]
     |          List of source node names to keep during filtering.
     |      source_node_names_to_remove: Optional[List[&str]]
     |          List of source node names to remove during filtering.
     |      source_node_names_to_keep_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be kept when they are source nodes.
     |      source_node_names_to_remove_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be removed when they are source nodes.
     |      source_node_prefixes_to_keep: Optional[List[str]]
     |          List of source node prefixes to keep during filtering.
     |      source_node_prefixes_to_remove: Optional[List[str]]
     |          List of source node prefixes to remove during filtering.
     |      source_node_type_names_to_keep: Optional[List[Optional[List[&str]]]]
     |          List of node type names of source nodes to keep during filtering. The node types must match entirely the given node types vector provided.
     |      source_node_type_names_to_remove: Optional[List[Optional[List[&str]]]]
     |          List of node type names of source nodes to remove during filtering. The node types must match entirely the given node types vector provided.
     |      source_node_type_name_to_keep: Optional[&List[Optional[&str]]]
     |          List of node type name of source nodes to keep during filtering. Any of node types must match with one of the node types given.
     |      source_node_type_name_to_remove: Optional[&List[Optional[&str]]]
     |          List of node type name of source nodes to remove during filtering. Any of node types must match with one of the node types given.
     |      destination_node_names_to_keep: Optional[List[&str]]
     |          List of destination node names to keep during filtering.
     |      destination_node_names_to_remove: Optional[List[&str]]
     |          List of destination node names to remove during filtering.
     |      destination_node_names_to_keep_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be kept when they are destination nodes.
     |      destination_node_names_to_remove_from_graph: Optional[&Graph]
     |          Graph whose nodes are to be removed when they are destination nodes.
     |      destination_node_prefixes_to_keep: Optional[List[str]]
     |          List of destination node prefixes to keep during filtering.
     |      destination_node_prefixes_to_remove: Optional[List[str]]
     |          List of destination node prefixes to remove during filtering.
     |      destination_node_type_names_to_keep: Optional[List[Optional[List[&str]]]]
     |          List of node type names of destination nodes to keep during filtering. The node types must match entirely the given node types vector provided.
     |      destination_node_type_names_to_remove: Optional[List[Optional[List[&str]]]]
     |          List of node type names of destination nodes to remove during filtering. The node types must match entirely the given node types vector provided.
     |      destination_node_type_name_to_keep: Optional[&List[Optional[&str]]]
     |          List of node type name of destination nodes to keep during filtering. Any of node types must match with one of the node types given.
     |      destination_node_type_name_to_remove: Optional[&List[Optional[&str]]]
     |          List of node type name of destination nodes to remove during filtering. Any of node types must match with one of the node types given.
     |      edge_node_names_to_keep: Optional[List[Tuple[str, str]]]
     |          List of tuple of node names to keep during filtering.
     |      edge_node_names_to_remove: Optional[List[Tuple[str, str]]]
     |          List of tuple of node names to remove during filtering.
     |      edge_type_names_to_keep: Optional[&List[Optional[&str]]]
     |          List of edge type names to keep during filtering.
     |      edge_type_names_to_remove: Optional[&List[Optional[&str]]]
     |          List of edge type names to remove during filtering.
     |      min_edge_weight: Optional[float]
     |          Minimum edge weight. Values lower than this are removed.
     |      max_edge_weight: Optional[float]
     |          Maximum edge weight. Values higher than this are removed.
     |      min_node_degree: Optional[int]
     |          Minimum node degree. Values lower than this are removed.
     |      max_node_degree: Optional[int]
     |          Maximum node degree. Values higher than this are removed.
     |      filter_singleton_nodes: Optional[bool]
     |          Whether to filter out singletons.
     |      filter_singleton_nodes_with_selfloop: Optional[bool]
     |          Whether to filter out singleton nodes with selfloops.
     |      filter_selfloops: Optional[bool]
     |          Whether to filter out selfloops.
     |      filter_parallel_edges: Optional[bool]
     |          Whether to filter out parallel edges.
     |      verbose: Optional[bool]
     |          Whether to show loading bar while building the graphs.
     |  
     |  generate_new_edges_from_node_features(self, /, features, neighbours_number, max_degree, distance_name, verbose)
     |      Returns graph with edges added extracted from given node_features.
     |      
     |      This operation might distrupt the graph topology.
     |      Proceed with caution!
     |      
     |      Parameters
     |      ----------
     |      features: List[List[float]]
     |          node_features to use to identify the new neighbours.
     |      neighbours_number: Optional[int]
     |          Number of neighbours to add.
     |      max_degree: Optional[int]
     |          The maximum degree a node can have its neighbours augmented. By default 0, that is, only singletons are augmented.
     |      distance_name: Optional[&str]
     |          Name of distance to use. Can either be L2 or COSINE. By default COSINE.
     |      verbose: Optional[bool]
     |          Whether to show loading bars.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have nodes.
     |      ValueError
     |          If the given node_features are not provided exactly for each node.
     |      ValueError
     |          If the node_features do not have a consistent shape.
     |      ValueError
     |          If the provided number of neighbours is zero.
     |  
     |  get_adamic_adar_coo_matrix(self, /)
     |      Returns Adamic-adar coo matrix
     |  
     |  get_adamic_adar_graph(self, /)
     |      Returns Adamic-Adar weighted graph
     |  
     |  get_adamic_adar_index_from_node_ids(self, /, source_node_id, destination_node_id)
     |      Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the node IDs are higher than the number of nodes in the graph.
     |  
     |  get_adamic_adar_index_from_node_names(self, /, first_node_name, second_node_name)
     |      Returns the Adamic/Adar Index for the given pair of nodes from the given node names.
     |      
     |      Parameters
     |      ----------
     |      first_node_name: str
     |          Node name of the first node.
     |      second_node_name: str
     |          Node name of the second node.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the given node names do not exist in the current graph.
     |  
     |  get_adamic_adar_scores(self, /, subgraph)
     |      Returns Adamic-Adar for all edges.
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided subgraph graph does not share a compatible vocabulary with the current graph instance.
     |  
     |  get_all_directed_edge_metrics(self, /, normalize, subgraph)
     |      Returns all available edge metrics for all directed edges.
     |      
     |      The metrics returned are, in order:
     |      - Adamic-Adar
     |      - Jaccard Coefficient
     |      - Resource Allocation index
     |      - Preferential attachment score
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided subgraph graph does not share a compatible vocabulary with the current graph instance.
     |  
     |  get_all_edge_metrics(self, /, normalize, subgraph)
     |      Returns all available edge metrics for all edges, dispatching to the correct implementation based on the graph directionality.
     |      
     |      The metrics returned are, in order:
     |      - Adamic-Adar
     |      - Jaccard Coefficient
     |      - Resource Allocation index
     |      - Preferential attachment score
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided subgraph graph does not share a compatible vocabulary with the current graph instance.
     |  
     |  get_all_edge_metrics_from_node_ids(self, /, source_node_ids, destination_node_ids, normalize)
     |      Returns all the implemented edge metrics for the vectors source and destination node IDs.
     |      
     |      Specifically, the returned values are:
     |      * Adamic Adar
     |      * Jaccard coefficient
     |      * Resource allocation index
     |      * Preferential attachment
     |      
     |      Parameters
     |      ----------
     |      source_node_ids: List[int]
     |          Node ID of the first node.
     |      destination_node_ids: List[int]
     |          Node ID of the second node.
     |      normalize: bool
     |          Whether to normalize within 0 to 1.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node IDs do not exist in the graph this method will panic.
     |  
     |  get_all_edge_metrics_from_node_ids_tuple(self, /, source_node_id, destination_node_id, normalize)
     |      Returns all the implemented edge metrics for the two given node IDs.
     |      
     |      Specifically, the returned values are:
     |      * Adamic Adar
     |      * Jaccard coefficient
     |      * Resource allocation index
     |      * Preferential attachment
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      normalize: bool
     |          Whether to normalize within 0 to 1.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided node IDs do not exist in the current graph instance.
     |  
     |  get_all_lower_triangular_edge_metrics(self, /, normalize, subgraph)
     |      Returns all available edge metrics for all edges in the triangular lower part of the adjacency matrix.
     |      
     |      The metrics returned are, in order:
     |      - Adamic-Adar
     |      - Jaccard Coefficient
     |      - Resource Allocation index
     |      - Preferential attachment score
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided subgraph graph does not share a compatible vocabulary with the current graph instance.
     |  
     |  get_all_shortest_paths(self, /, iterations, verbose)
     |      Returns graph with unweighted shortest paths computed up to the given depth.
     |      
     |      The returned graph will have no selfloops.
     |      
     |      Parameters
     |      ----------
     |      iterations: Optional[int]
     |          The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar while building the graph.
     |  
     |  get_all_upper_triangular_edge_metrics(self, /, normalize, subgraph)
     |      Returns all available edge metrics for all edges in the triangular upper part of the adjacency matrix.
     |      
     |      The metrics returned are, in order:
     |      - Adamic-Adar
     |      - Jaccard Coefficient
     |      - Resource Allocation index
     |      - Preferential attachment score
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided subgraph graph does not share a compatible vocabulary with the current graph instance.
     |  
     |  get_ancestors_jaccard_coo_matrix(self, /, bfs)
     |      Returns Ancestors Jaccard coo matrix.
     |      
     |      Parameters
     |      ----------
     |      bfs: ShortestPathsResultBFS
     |          The BFS object to use for the ancestors.
     |  
     |  get_ancestors_jaccard_from_node_ids(self, /, bfs, first_node_ids, second_node_ids)
     |      Returns shared ancestors of the provided node ids.
     |      
     |      Parameters
     |      ----------
     |      bfs: ShortestPathsResultBFS
     |          The BFS object to use for the ancestors.
     |      first_node_ids: List[int]
     |          The first node ids to query for.
     |      second_node_ids: List[int]
     |          The second node ids to query for.
     |  
     |  get_ancestors_jaccard_from_node_names(self, /, bfs, first_node_names, second_node_names)
     |      Returns shared ancestors of the provided node names.
     |      
     |      Parameters
     |      ----------
     |      bfs: ShortestPathsResultBFS
     |          The BFS object to use for the ancestors.
     |      first_node_names: List[str]
     |          The first node names to query for.
     |      second_node_names: List[str]
     |          The second node names to query for.
     |  
     |  get_ancestors_jaccard_graph(self, /, bfs)
     |      Returns Ancestors Jaccard weighted graph.
     |      
     |      Parameters
     |      ----------
     |      bfs: ShortestPathsResultBFS
     |          The BFS object to use for the ancestors.
     |  
     |  get_approximated_betweenness_centrality_from_node_id(self, /, node_id, ant, maximum_samples_number, random_state)
     |      Returns the unweighted approximated betweenness centrality of the given node id.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID for which to compute the approximated betweenness centrality.
     |      constant: Optional[float]
     |          The constant factor to use to regulate the sampling. By default 2.0. It must be greater or equal than 2.0.
     |      maximum_samples_number: Optional[float]
     |          The maximum number of samples to sample. By default `number_of_nodes / 20`, as suggested in the paper.
     |      random_state: Optional[int]
     |          The random state to use for the sampling. By default 42.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided node ID does not exist in the current graph instance.
     |  
     |  get_approximated_betweenness_centrality_from_node_name(self, /, node_name, ant, maximum_samples_number, random_state)
     |      Returns the unweighted approximated betweenness centrality of the given node id.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          The node name for which to compute the approximated betweenness centrality.
     |      constant: Optional[float]
     |          The constant factor to use to regulate the sampling. By default 2.0. It must be greater or equal than 2.0.
     |      maximum_samples_number: Optional[float]
     |          The maximum number of samples to sample. By default `number_of_nodes / 20`, as suggested in the paper.
     |      random_state: Optional[int]
     |          The random state to use for the sampling. By default 42.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided node name does not exist in the current graph instance.
     |  
     |  get_approximated_cliques(self, /, minimum_degree, minimum_clique_size, clique_per_node, verbose)
     |      Returns graph cliques with at least `minimum_degree` nodes.
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the current graph is directed.
     |  
     |  get_approximated_closeness_centrality(self, /, precision, bits)
     |      Returns an approximation of the closeness centrality for all nodes in the graph.
     |      
     |      This method applies the HyperBall algorithm to compute an approximation of the closeness
     |      centrality of each node. The precision parameter indicates the number of bits to use to
     |      represent the HyperLogLog registers. The higher the precision, the more accurate the
     |      results, but also the more memory required and the slower the algorithm.
     |      
     |      Closeness centrality is a metric that measures the importance of a node in a
     |      graph based on how close it is to all other nodes in the graph.
     |      This is determined by taking the reciprocal of the sum of the shortest
     |      path distances between a node and all other nodes in the graph.
     |      Closeness centrality is a measure of how quickly information can spread through a network,
     |      as nodes that are closer to other nodes can transmit information more efficiently.
     |      Nodes with higher closeness centrality are therefore considered more important
     |      in terms of their ability to communicate with other nodes in the network.
     |      However, closeness centrality is sensitive to disconnected nodes and may not
     |      provide a reliable measure of importance in graphs with multiple connected components.
     |      
     |      Parameters
     |      ----------
     |      precision: Optional[int]
     |          The number of bits to use to represent the HyperLogLog registers. By default 6.
     |      bits: Optional[int]
     |          The number of bits to use for the HyperLogLog counters. It must be either 4, 5 or 6, and by default 6.
     |  
     |  get_approximated_diameter(self, /, precision, bits, dtype)
     |      Returns an approximation of the graph diameter.
     |      
     |      Parameters
     |      ----------
     |      precision: Optional[int]
     |          The number of bits to use to represent the HyperLogLog registers. By default 6.
     |      bits: Optional[int]
     |          The number of bits to use for the HyperLogLog counters. It must be either 4, 5 or 6, and by default 6.
     |      dtype: Optional[&str]
     |          The data type to use for the HyperLogLog counters. It must be either "u8", "u16", "u32" or "u64" and by default "u16".
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the data type is not supported.
     |      ValueError
     |          If the combination of precision and bits is not supported.
     |  
     |  get_approximated_harmonic_centrality(self, /, precision, bits)
     |      Returns an approximation of the harmonic centrality for all nodes in the graph.
     |      
     |      This method applies the HyperBall algorithm to compute an approximation of the harmonic
     |      centrality of each node. The precision parameter indicates the number of bits to use to
     |      represent the HyperLogLog registers. The higher the precision, the more accurate the
     |      results, but also the more memory required and the slower the algorithm.
     |      
     |      Harmonic centrality is another metric that measures the importance of a node
     |      in a graph based on its ability to reach other nodes.
     |      It is defined as the sum of the harmonic mean of the distances between a node
     |      and all other nodes in the graph. The harmonic mean is used instead of the
     |      arithmetic mean as it gives greater weight to shorter distances.
     |      Harmonic centrality is also more robust to disconnected nodes than closeness centrality,
     |      as it assigns higher centrality scores to nodes that are closer to other nodes
     |      within their own connected component. However, harmonic centrality does not
     |      provide an accurate measure of importance in terms of communication efficiency,
     |      as it does not take into account the actual distances between nodes.
     |      It is therefore most useful for measuring the ability of a node to reach
     |      other nodes within a connected component.
     |      
     |      Parameters
     |      ----------
     |      precision: Optional[int]
     |          The number of bits to use to represent the HyperLogLog registers. By default 6.
     |      bits: Optional[int]
     |          The number of bits to use for the HyperLogLog counters. It must be either 4, 5 or 6, and by default 6.
     |  
     |  get_approximated_isomorphic_node_type_ids_groups(self, /)
     |      Returns vector with isomorphic node type groups IDs
     |  
     |  get_approximated_isomorphic_node_type_names_groups(self, /)
     |      Returns vector with isomorphic node type groups names
     |  
     |  get_approximated_number_of_cliques(self, /, minimum_degree, minimum_clique_size, clique_per_node, verbose)
     |      Returns number of graph cliques with at least `minimum_degree` nodes.
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the current graph is directed.
     |  
     |  get_approximated_total_distances(self, /, precision, bits)
     |      Returns an approximation of the total distances centrality for all nodes in the graph.
     |      
     |      This method applies the HyperBall algorithm to compute an approximation of the total distances
     |      from each node. The precision parameter indicates the number of bits to use to
     |      represent the HyperLogLog registers. The higher the precision, the more accurate the
     |      results, but also the more memory required and the slower the algorithm.
     |      
     |      Parameters
     |      ----------
     |      precision: Optional[int]
     |          The number of bits to use to represent the HyperLogLog registers. By default 6.
     |      bits: Optional[int]
     |          The number of bits to use for the HyperLogLog counters. It must be either 4, 5 or 6, and by default 6.
     |  
     |  get_available_edge_metrics_names(self, /)
     |      Returns names of currently subgraphed edge metrics
     |  
     |  get_average_clustering_coefficient(self, /, approach, insert_only_source, verbose)
     |      Returns the graph average clustering coefficient.
     |      
     |      Parameters
     |      ----------
     |      approach: Optional[&str]
     |          The approach name to be used. By default, the increasing node degree order is used.
     |      insert_only_source: Optional[bool]
     |          Whether to insert only the source node or both source and destination. By default only the source is inserted.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar.
     |  
     |  get_base_13_triad_census(self, /)
     |  
     |  get_base_13_triad_census_per_node(self, /)
     |      Return 2D numpy array with base 13 triad census.
     |  
     |  get_base_13_tricodes_from_node_ids(self, /, first, second, third)
     |      Returns the base 13, i.e. using 13 possible triads, tricodes associated to the provided triple of node IDs.
     |      
     |      Parameters
     |      ----------
     |      first: int
     |          The first node ID of the triple.
     |      second: int
     |          The second node ID of the triple.
     |      third: int
     |          The third node ID of the triple.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_base_13_tricodes_from_node_names(self, /, first, second, third)
     |      Returns the base 13, i.e. using 13 possible triads, tricodes associated to the provided triple of node names.
     |      
     |      Parameters
     |      ----------
     |      first: str
     |          The first node name of the triple.
     |      second: str
     |          The second node name of the triple.
     |      third: str
     |          The third node name of the triple.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_base_16_triad_census(self, /)
     |      Returns slice with graph-wide triad census defined over 16 type of triads.
     |  
     |  get_base_16_tricodes_from_node_ids(self, /, first, second, third)
     |      Returns the base 16, i.e. using 16 possible triads, tricodes associated to the provided triple of node IDs.
     |      
     |      Parameters
     |      ----------
     |      first: int
     |          The first node ID of the triple.
     |      second: int
     |          The second node ID of the triple.
     |      third: int
     |          The third node ID of the triple.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_base_16_tricodes_from_node_names(self, /, first, second, third)
     |      Returns the base 16, i.e. using 16 possible triads, tricodes associated to the provided triple of node names.
     |      
     |      Parameters
     |      ----------
     |      first: str
     |          The first node name of the triple.
     |      second: str
     |          The second node name of the triple.
     |      third: str
     |          The third node name of the triple.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_base_30_triad_census(self, /)
     |  
     |  get_base_30_triad_census_per_node(self, /)
     |      Return 2D numpy array with base 30 triad census.
     |  
     |  get_base_30_tricodes_from_node_ids(self, /, first, second, third)
     |      Returns the base 30, i.e. using 30 possible triads, tricodes associated to the provided triple of node IDs.
     |      
     |      Parameters
     |      ----------
     |      first: int
     |          The first node ID of the triple.
     |      second: int
     |          The second node ID of the triple.
     |      third: int
     |          The third node ID of the triple.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_base_30_tricodes_from_node_names(self, /, first, second, third)
     |      Returns the base 30, i.e. using 30 possible triads, tricodes associated to the provided triple of node names.
     |      
     |      Parameters
     |      ----------
     |      first: str
     |          The first node name of the triple.
     |      second: str
     |          The second node name of the triple.
     |      third: str
     |          The third node name of the triple.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_base_64_tricodes_from_node_ids(self, /, first, second, third)
     |      Returns the base 64, i.e. using 64 possible triads, tricodes associated to the provided triple of node IDs.
     |      
     |      Parameters
     |      ----------
     |      first: int
     |          The first node ID of the triple.
     |      second: int
     |          The second node ID of the triple.
     |      third: int
     |          The third node ID of the triple.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_base_64_tricodes_from_node_names(self, /, first, second, third)
     |      Returns the base 64, i.e. using 64 possible triads, tricodes associated to the provided triple of node names.
     |      
     |      Parameters
     |      ----------
     |      first: str
     |          The first node name of the triple.
     |      second: str
     |          The second node name of the triple.
     |      third: str
     |          The third node name of the triple.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_betweenness_centrality(self, /, edges_normalization, min_max_normalization, verbose)
     |      Returns vector of betweenness centrality for all nodes.
     |      
     |      Parameters
     |      ----------
     |      edges_normalization: Optional[bool]
     |          Whether to normalize the values by the number of edges of the complete graph. By default, false.
     |      min_max_normalization: Optional[bool]
     |          Whether to normalize the values between 0 and 1. By default, false.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar while computing the betweenness centrality. By default, true.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is a multigraph.
     |  
     |  get_bfs_topological_sorting_from_node_id(self, /, root_node_id)
     |      Returns topological sorting map using breadth-first search from the given node.
     |      
     |      Parameters
     |      ----------
     |      root_node_id: int
     |          Node ID of node to be used as root of BFS
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given root node ID does not exist in the graph
     |  
     |  get_bipartite_edge_names(self, /, removed_existing_edges, first_nodes_set, second_nodes_set, first_node_types_set, second_node_types_set)
     |      Return vector of tuple of Node IDs that form the edges of the required bipartite graph.
     |      
     |      Parameters
     |      ----------
     |      removed_existing_edges: Optional[bool]
     |          Whether to filter out the existing edges. By default, true.
     |      first_nodes_set: Optional[Set[str]]
     |          Optional set of nodes to use to create the first set of nodes of the graph.
     |      second_nodes_set: Optional[Set[str]]
     |          Optional set of nodes to use to create the second set of nodes of the graph.
     |      first_node_types_set: Optional[Set[str]]
     |          Optional set of node types to create the first set of nodes of the graph.
     |      second_node_types_set: Optional[Set[str]]
     |          Optional set of node types to create the second set of nodes of the graph.
     |  
     |  get_bipartite_edges(self, /, removed_existing_edges, first_nodes_set, second_nodes_set, first_node_types_set, second_node_types_set)
     |      Return vector of tuple of Node IDs that form the edges of the required bipartite graph.
     |      
     |      Parameters
     |      ----------
     |      removed_existing_edges: Optional[bool]
     |          Whether to filter out the existing edges. By default, true.
     |      first_nodes_set: Optional[Set[str]]
     |          Optional set of nodes to use to create the first set of nodes of the graph.
     |      second_nodes_set: Optional[Set[str]]
     |          Optional set of nodes to use to create the second set of nodes of the graph.
     |      first_node_types_set: Optional[Set[str]]
     |          Optional set of node types to create the first set of nodes of the graph.
     |      second_node_types_set: Optional[Set[str]]
     |          Optional set of node types to create the second set of nodes of the graph.
     |  
     |  get_boolean_node_type_ids(self, /, target_value, unknown_node_types_value)
     |      Returns 1D binarized node types ids vector
     |  
     |  get_breadth_first_search_from_node_ids(self, /, src_node_id, dst_node_id, compute_predecessors, maximal_depth)
     |      Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Node ID root of the tree of minimum paths.
     |      compute_predecessors: Optional[bool]
     |          Whether to compute the vector of predecessors.
     |      maximal_depth: Optional[int]
     |          The maximal number of iterations to execute the DFS for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given source node ID does not exist in the current graph.
     |      ValueError
     |          If the given optional destination node ID does not exist in the current graph.
     |  
     |  get_breadth_first_search_from_node_names(self, /, src_node_name, dst_node_name, compute_predecessors, maximal_depth)
     |      Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.
     |      
     |      Parameters
     |      ----------
     |      src_node_name: str
     |          Node name root of the tree of minimum paths.
     |      dst_node_name: Optional[&str]
     |          Destination node name.
     |      compute_predecessors: Optional[bool]
     |          Whether to compute the vector of predecessors.
     |      maximal_depth: Optional[int]
     |          The maximal depth to execute the DFS for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the weights are to be used and the graph does not have weights.
     |      ValueError
     |          If the given source node name does not exist in the current graph.
     |      ValueError
     |          If the given optional destination node name does not exist in the current graph.
     |  
     |  get_breadth_first_search_random_nodes(self, /, number_of_nodes_to_sample, root_node)
     |      Return nodes sampled from the neighbourhood of given root nodes.
     |      
     |      Parameters
     |      ----------
     |      number_of_nodes_to_sample: int
     |          The number of nodes to sample.
     |      root_node: int
     |          The root node from .
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the number of requested nodes is higher than the number of nodes in the graph.
     |      ValueError
     |          If the given root node does not exist in the curret graph instance.
     |  
     |  get_chains(self, /, minimum_number_of_nodes_per_chain, compute_chain_nodes)
     |      Return vector of chains in the current graph instance.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_circles(self, /, minimum_number_of_nodes_per_circle, compute_circle_nodes)
     |      Return vector of Circles in the current graph instance.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_clique_edge_names(self, /, directed, allow_selfloops, removed_existing_edges, allow_node_type_set, allow_node_set)
     |      Return vector of tuple of Node names that form the edges of the required clique.
     |      
     |      Parameters
     |      ----------
     |      directed: Optional[bool]
     |          Whether to return the edges as directed or undirected. By default, equal to the graph.
     |      allow_selfloops: Optional[bool]
     |          Whether to allow self-loops in the clique. By default, equal to the graph.
     |      removed_existing_edges: Optional[bool]
     |          Whether to filter out the existing edges. By default, true.
     |      allow_node_type_set: Optional[Set[str]]
     |          Node types to include in the clique.
     |      allow_node_set: Optional[Set[str]]
     |          Nodes to include i the clique.
     |  
     |  get_clique_edges(self, /, directed, allow_selfloops, removed_existing_edges, allow_node_type_set, allow_node_set)
     |      Return vector of tuple of Node IDs that form the edges of the required clique.
     |      
     |      Parameters
     |      ----------
     |      directed: Optional[bool]
     |          Whether to return the edges as directed or undirected. By default, equal to the graph.
     |      allow_selfloops: Optional[bool]
     |          Whether to allow self-loops in the clique. By default, equal to the graph.
     |      removed_existing_edges: Optional[bool]
     |          Whether to filter out the existing edges. By default, true.
     |      allow_node_type_set: Optional[Set[str]]
     |          Node types to include in the clique.
     |      allow_node_set: Optional[Set[str]]
     |          Nodes to include i the clique.
     |  
     |  get_closeness_centrality(self, /)
     |      Return parallel iterator over closeness centrality for all nodes.
     |  
     |  get_clustering_coefficient(self, /, approach, insert_only_source, verbose)
     |      Returns the graph clustering coefficient.
     |      
     |      Parameters
     |      ----------
     |      approach: Optional[&str]
     |          The approach name to be used. By default, the increasing node degree order is used.
     |      insert_only_source: Optional[bool]
     |          Whether to insert only the source node or both source and destination. By default only the source is inserted.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar.
     |  
     |  get_clustering_coefficient_per_node(self, /, approach, insert_only_source, verbose)
     |      Returns clustering coefficients for all nodes in the graph.
     |      
     |      Parameters
     |      ----------
     |      approach: Optional[&str]
     |          The approach name to be used. By default, the increasing node degree order is used.
     |      insert_only_source: Optional[bool]
     |          Whether to insert only the source node or both source and destination. By default only the source is inserted.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar.
     |  
     |  get_comulative_node_degree_from_node_id(self, /, node_id)
     |      Returns the comulative node degree up to the given node.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node.
     |  
     |  get_connected_components(self, /, verbose)
     |      Compute the connected components building in parallel a spanning tree using [bader's algorithm](https://www.sciencedirect.com/science/article/abs/pii/S0743731505000882).
     |      
     |      **This works only for undirected graphs.**
     |      
     |      This method is **not thread save and not deterministic** but by design of the algorithm this
     |      shouldn't matter but if we will encounter non-detemristic bugs here is where we want to look.
     |      
     |      The returned quadruple contains:
     |      - Vector of the connected component for each node.
     |      - Number of connected components.
     |      - Minimum connected component size.
     |      - Maximum connected component size.
     |      
     |      Parameters
     |      ----------
     |      verbose: Optional[bool]
     |          Whether to show a loading bar or not.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given graph is directed.
     |      ValueError
     |          If the system configuration does not allow for the creation of the thread pool.
     |  
     |  get_cumulative_node_degrees(self, /)
     |      Return vector with node cumulative_node_degrees, that is the comulative node degree
     |  
     |  get_degree_centrality(self, /)
     |      Returns vector of unweighted degree centrality for all nodes
     |  
     |  get_dendritic_trees(self, /)
     |      Returns vector of detected dentritic trees
     |  
     |  get_dense_binary_adjacency_matrix(self, /)
     |      Return the dense binary adjacency matrix.
     |  
     |  get_dense_modularity_matrix(self, /, verbose)
     |      Return the dense modularity matrix.
     |      
     |      Parameters
     |      --------------
     |      verbose: bool = True
     |          Whether to show a loading bar. By default, true.
     |  
     |  get_dense_nodes_mapping(self, /)
     |      Return mapping from instance not trap nodes to dense nodes
     |  
     |  get_dense_weighted_adjacency_matrix(self, /)
     |      Return the dense weighted adjacency matrix.
     |  
     |  get_density(self, /)
     |      Returns density of the graph.
     |  
     |  get_destination_names(self, /, directed)
     |      Return vector of the non-unique destination nodes names.
     |      
     |      Parameters
     |      ----------
     |      directed: bool
     |          Whether to filter out the undirected edges.
     |  
     |  get_destination_node_id_from_edge_id(self, /, edge_id)
     |      Returns destination node ID corresponding to given edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose destination node ID is to be retrieved.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given edge ID does not exist in the current graph.
     |  
     |  get_destination_node_ids(self, /, directed)
     |      Return vector on the (non unique) destination nodes of the graph.
     |      
     |      Parameters
     |      ----------
     |      directed: bool
     |          Whether to filter out the undirected edges.
     |  
     |  get_destination_node_name_from_edge_id(self, /, edge_id)
     |      Returns destination node name corresponding to given edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose destination node name is to be retrieved.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_diameter(self, /, ignore_infinity, verbose)
     |      Returns diameter of the graph.
     |      
     |      Parameters
     |      ----------
     |      ignore_infinity: Optional[bool]
     |          Whether to ignore infinite distances, which are present when in the graph exist multiple components. By default True.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain nodes.
     |  
     |  get_diameter_naive(self, /, ignore_infinity, verbose)
     |      Returns diameter of the graph using naive method.
     |      
     |      Note that there exists the non-naive method for undirected graphs
     |      and it is possible to implement a faster method for directed graphs
     |      but we still need to get to it, as it will require an updated
     |      succinct data structure.
     |      
     |      Parameters
     |      ----------
     |      ignore_infinity: Optional[bool]
     |          Whether to ignore infinite distances, which are present when in the graph exist multiple components.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain nodes.
     |  
     |  get_dijkstra_from_node_ids(self, /, src_node_id, maybe_dst_node_id, maybe_dst_node_ids, compute_predecessors, maximal_depth, use_edge_weights_as_probabilities)
     |      Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Node ID root of the tree of minimum paths.
     |      maybe_dst_node_id: Optional[int]
     |          Optional target destination. If provided, Dijkstra will stop upon reaching this node.
     |      maybe_dst_node_ids: Optional[List[int]]
     |          Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.
     |      compute_predecessors: Optional[bool]
     |          Whether to compute the vector of predecessors.
     |      maximal_depth: Optional[int]
     |          The maximal depth to execute the DFS for.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the weights are to be used and the graph does not have weights.
     |      ValueError
     |          If the given source node ID does not exist in the current graph.
     |      ValueError
     |          If the given optional destination node ID does not exist in the current graph.
     |      ValueError
     |          If weights are requested to be treated as probabilities but are not between 0 and 1.
     |      ValueError
     |          If the graph contains negative weights.
     |  
     |  get_dijkstra_from_node_names(self, /, src_node_name, maybe_dst_node_name, maybe_dst_node_names, compute_predecessors, maximal_depth, use_edge_weights_as_probabilities)
     |      Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.
     |      
     |      Parameters
     |      ----------
     |      src_node_name: str
     |          Node name root of the tree of minimum paths.
     |      maybe_dst_node_name: Optional[&str]
     |          Optional target destination node name. If provided, Dijkstra will stop upon reaching this node.
     |      maybe_dst_node_names: Optional[List[&str]]
     |          Optional target destination node names. If provided, Dijkstra will stop upon reaching all of these nodes.
     |      compute_predecessors: Optional[bool]
     |          Whether to compute the vector of predecessors.
     |      maximal_depth: Optional[int]
     |          The maximal depth to execute the DFS for.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the weights are to be used and the graph does not have weights.
     |      ValueError
     |          If the given source node name does not exist in the current graph.
     |      ValueError
     |          If the given optional destination node name does not exist in the current graph.
     |  
     |  get_directed_destination_node_ids(self, /)
     |      Return vector on the (non unique) directed destination nodes of the graph
     |  
     |  get_directed_destination_nodes_with_known_edge_types(self, /)
     |      Return the directed destination node IDs with known edge types
     |  
     |  get_directed_edge_ids_from_edge_type_id(self, /, edge_type_id)
     |      Returns vector containing directed edge IDs with given edge type name.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: Optional[int]
     |          Edge type id to extract.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |      ValueError
     |          If the given edge type id does not exist in the graph.
     |  
     |  get_directed_edge_ids_from_edge_type_name(self, /, edge_type_name)
     |      Returns vector containing directed edge IDs with given edge type name.
     |      
     |      Parameters
     |      ----------
     |      edge_type_names: Optional[int]
     |          Edge type names to extract.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |      ValueError
     |          If the given edge type names does not exist in the graph.
     |  
     |  get_directed_edge_ids_from_node_curie_prefixes(self, /, src_node_name_prefixes, dst_node_name_prefixes)
     |      Returns vector of directed edge IDs with given node name prefixes.
     |      
     |      Parameters
     |      ----------
     |      src_node_name_prefixes: Optional[List[&str]]
     |          Prefix of the source node names.
     |      dst_node_name_prefixes: Optional[List[&str]]
     |          Prefix of the source node names.
     |  
     |  get_directed_edge_ids_with_known_edge_types(self, /)
     |      Returns edge IDs of the edges with known edge types
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_directed_edge_ids_with_unknown_edge_types(self, /)
     |      Returns directed edge IDs of the edges with unknown edge types
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_directed_edge_node_ids(self, /)
     |      Return vector with the sorted directed edge node IDs
     |  
     |  get_directed_edge_node_ids_from_edge_type_id(self, /, edge_type_id)
     |      Returns vector containing directed edge node IDs with given edge type.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: Optional[int]
     |          Edge type ID to extract.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |      ValueError
     |          If the given edge type ID does not exist in the graph.
     |  
     |  get_directed_edge_node_ids_from_edge_type_name(self, /, edge_type_name)
     |      Returns vector containing directed edge node IDs with given edge type name.
     |      
     |      Parameters
     |      ----------
     |      edge_type_names: Optional[int]
     |          Edge type names to extract.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |      ValueError
     |          If the given edge type names does not exist in the graph.
     |  
     |  get_directed_edge_node_ids_from_node_curie_prefixes(self, /, src_node_name_prefixes, dst_node_name_prefixes)
     |      Returns vector of directed edge node IDs with given node name prefixes
     |      
     |      Parameters
     |      ----------
     |      src_node_name_prefixes: Optional[List[&str]]
     |          Prefix of the source node names.
     |      dst_node_name_prefixes: Optional[List[&str]]
     |          Prefix of the source node names.
     |  
     |  get_directed_edge_node_names(self, /)
     |      Return vector with the sorted directed edge names
     |  
     |  get_directed_edge_node_names_from_edge_type_id(self, /, edge_type_id)
     |      Returns vector containing directed edge node names with given edge type.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: Optional[int]
     |          Edge type ID to extract.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |      ValueError
     |          If the given edge type ID does not exist in the graph.
     |  
     |  get_directed_edge_node_names_from_edge_type_name(self, /, edge_type_name)
     |      Returns vector containing directed edge node names with given edge type name.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: Optional[int]
     |          Edge type name to extract.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |      ValueError
     |          If the given edge type name does not exist in the graph.
     |  
     |  get_directed_edge_node_names_from_node_curie_prefixes(self, /, src_node_name_prefixes, dst_node_name_prefixes)
     |      Returns vector of directed edge node names with given node name prefixes
     |      
     |      Parameters
     |      ----------
     |      src_node_name_prefixes: Optional[List[&str]]
     |          Prefix of the source node names.
     |      dst_node_name_prefixes: Optional[List[&str]]
     |          Prefix of the source node names.
     |  
     |  get_directed_edge_triples_ids(self, /)
     |      Return vector with the sorted directed triples with (source, edge_type, destination) IDs.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain edge types.
     |  
     |  get_directed_edge_triples_names(self, /)
     |      Return vector with the sorted directed triples with (source, edge_type, destination) names.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain edge types.
     |  
     |  get_directed_edge_type_ids(self, /)
     |      Return the directed edge types of the edges
     |  
     |  get_directed_edge_type_names(self, /)
     |      Return the directed edge types names
     |  
     |  get_directed_edge_weights(self, /)
     |      Return the directed weights of the graph edges.
     |  
     |  get_directed_edges_with_known_edge_types_mask(self, /)
     |      Returns a boolean vector that for each directed edge contains whether it has an
     |      unknown edge type.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_directed_known_edge_type_ids(self, /)
     |      Return the directed known edge types of the edges, dropping unknown ones
     |  
     |  get_directed_modularity_from_node_community_memberships(self, /, node_community_memberships)
     |      Returns the directed modularity of the graph from the given memberships.
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the number of provided memberships does not match the number of nodes of the graph.
     |  
     |  get_directed_source_node_ids(self, /)
     |      Return vector on the (non unique) directed source nodes of the graph
     |  
     |  get_directed_source_nodes_with_known_edge_types(self, /)
     |      Return the directed source node IDs with known edge types
     |  
     |  get_distances_histogram_between_node_type_ids(self, /, src_node_type_ids, dst_node_type_ids, verbose)
     |      Returns histogram of distances between the given source node type ids and the given destination node type ids.
     |      
     |      Parameters
     |      ----------
     |      src_node_type_ids: Optional[List[int]]
     |          Source node types ids. If None, the nodes with unknown node type will be used.
     |      dst_node_type_ids: Optional[List[int]]
     |          Destination node types ids. If None, the nodes with unknown node type will be used.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar.
     |  
     |  get_distances_histogram_between_node_type_names(self, /, src_node_type_names, dst_node_type_names, verbose)
     |      Returns histogram of distances between the given source node type names and the given destination node type names.
     |      
     |      Parameters
     |      ----------
     |      src_node_type_names: Optional[List[&str]]
     |          Source node types names. If None, the nodes with unknown node type will be used.
     |      dst_node_type_names: Optional[List[&str]]
     |          Destination node types names. If None, the nodes with unknown node type will be used.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar.
     |  
     |  get_distances_histogram_between_prefixes(self, /, src_prefixes, dst_prefixes, verbose)
     |      Returns histogram of distances between the given source prefixes and the given destination prefixes.
     |      
     |      Parameters
     |      ----------
     |      src_prefixes: List[str]
     |          Allowed source node prefixes.
     |      dst_prefixes: List[str]
     |          Allowed destination node prefixes.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar.
     |  
     |  get_eccentricity_and_most_distant_node_id_from_node_id(self, /, node_id)
     |      Returns unweighted eccentricity of the given node ID.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Node for which to compute the eccentricity.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node ID does not exist in the graph.
     |  
     |  get_eccentricity_from_node_name(self, /, node_name)
     |      Returns unweighted eccentricity of the given node name.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          Node for which to compute the eccentricity.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node name does not exist in the current graph instance.
     |  
     |  get_edge_count_from_edge_type_id(self, /, edge_type_id)
     |      Return number of edges with given edge type ID.
     |      
     |      If None is given as an edge type ID, the unknown edge type IDs
     |      will be returned.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: Optional[int]
     |          The edge type ID to count the edges of.
     |  
     |  get_edge_count_from_edge_type_name(self, /, edge_type_name)
     |      Return number of edges with given edge type name.
     |      
     |      If None is given as an edge type name, the unknown edge types
     |      will be returned.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: Optional[&str]
     |          The edge type name to count the edges of.
     |  
     |  get_edge_id_from_node_ids(self, /, src, dst)
     |      Returns edge ID corresponding to given source and destination node IDs.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          The source node ID.
     |      dst: int
     |          The destination node ID.
     |  
     |  get_edge_id_from_node_ids_and_edge_type_id(self, /, src, dst, edge_type)
     |      Return edge ID for given tuple of nodes and edge type.
     |      
     |      This method will return an error if the graph does not contain the
     |      requested edge with edge type.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          Source node of the edge.
     |      dst: int
     |          Destination node of the edge.
     |      edge_type: Optional[int]
     |          Edge Type of the edge.
     |  
     |  get_edge_id_from_node_names(self, /, src_name, dst_name)
     |      Return edge ID for given tuple of node names.
     |      
     |      This method will return an error if the graph does not contain the
     |      requested edge with edge type.
     |      
     |      Parameters
     |      ----------
     |      src_name: str
     |          Source node name of the edge.
     |      dst_name: str
     |          Destination node name of the edge.
     |  
     |  get_edge_id_from_node_names_and_edge_type_name(self, /, src_name, dst_name, edge_type_name)
     |      Return edge ID for given tuple of node names and edge type name.
     |      
     |      This method will return an error if the graph does not contain the
     |      requested edge with edge type.
     |      
     |      Parameters
     |      ----------
     |      src_name: str
     |          Source node name of the edge.
     |      dst_name: str
     |          Destination node name of the edge.
     |      edge_type_name: Optional[&str]
     |          Edge type name.
     |  
     |  get_edge_ids_from_node_ids(self, /, node_ids, add_selfloops_where_missing, complete)
     |      Return subsampled edges connected to the given node Ids.
     |      
     |      Parameters
     |      --------------------
     |      node_ids: List[int]
     |          List of nodes whose edges are to return.
     |      add_selfloops_where_missing: Optional[bool]
     |          Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.
     |      complete: Optional[bool] = True
     |          Whether to return the edges in both directions (when dealing with an undirected graph).
     |      
     |      Returns
     |      --------------------
     |      Tuple with the sampled nodes and the computed kernels.
     |  
     |  get_edge_label_holdout_graphs(self, /, train_size, use_stratification, random_state)
     |      Returns edge-label holdout for training ML algorithms on the graph edge labels.
     |      This is commonly used for edge type prediction tasks.
     |      
     |      This method returns two graphs, the train and the test one.
     |      The edges of the graph will be splitted in the train and test graphs according
     |      to the `train_size` argument.
     |      
     |      If stratification is enabled, the train and test will have the same ratios of
     |      edge types.
     |      
     |      Parameters
     |      ----------
     |      train_size: float
     |          rate target to reserve for training,
     |      use_stratification: Optional[bool]
     |          Whether to use edge-label stratification,
     |      random_state: Optional[int]
     |          The random_state to use for the holdout,
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is a multigraph.
     |      ValueError
     |          If the graph does not have edge types.
     |      ValueError
     |          If stratification is required but the graph has singleton edge types.
     |  
     |  get_edge_label_kfold(self, /, k, k_index, use_stratification, random_state)
     |      Returns edge-label kfold for training ML algorithms on the graph edge labels.
     |      This is commonly used for edge type prediction tasks.
     |      
     |      This method returns two graphs, the train and the test one.
     |      The edges of the graph will be splitted in the train and test graphs according
     |      to the `train_size` argument.
     |      
     |      If stratification is enabled, the train and test will have the same ratios of
     |      edge types.
     |      
     |      Parameters
     |      ----------
     |      k: int
     |          The number of folds.
     |      k_index: int
     |          Which fold to use for the validation.
     |      use_stratification: Optional[bool]
     |          Whether to use edge-label stratification,
     |      random_state: Optional[int]
     |          The random_state to use for the holdout,
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |      ValueError
     |          If stratification is required but the graph has singleton edge types.
     |  
     |  get_edge_node_ids(self, /, directed)
     |      Return vector with the sorted edge Ids.
     |      
     |      Parameters
     |      ----------
     |      directed: bool
     |          Whether to filter out the undirected edges.
     |  
     |  get_edge_node_ids_from_edge_node_names(self, /, edge_node_names)
     |      Returns result with the edge node IDs.
     |      
     |      Parameters
     |      ----------
     |      edge_node_names: List[Tuple[str, str]]
     |          The node names whose node IDs is to be returned.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          When any of the given node name does not exists in the current graph.
     |  
     |  get_edge_node_ids_from_edge_type_id(self, /, directed, edge_type_id)
     |      Returns vector containing edge node IDs with given edge type.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: Optional[int]
     |          Edge type ID to extract.
     |      directed: bool
     |          Whether to iterate the edge list as directed or undirected.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |      ValueError
     |          If the given edge type ID does not exist in the graph.
     |  
     |  get_edge_node_ids_from_edge_type_name(self, /, directed, edge_type_name)
     |      Returns vector containing edge node IDs with given edge type name.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: Optional[&str]
     |          Edge type name to extract.
     |      directed: bool
     |          Whether to iterate the edge list as directed or undirected.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |      ValueError
     |          If the given edge type name does not exist in the graph.
     |  
     |  get_edge_node_ids_with_known_edge_types(self, /, directed)
     |      Returns edge node IDs of the edges with known edge types
     |      
     |      Parameters
     |      ----------
     |      directed: bool
     |          Whether to iterated the edges as a directed or undirected edge list.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_edge_node_names(self, /, directed)
     |      Return vector with the sorted edge names.
     |      
     |      Parameters
     |      ----------
     |      directed: bool
     |          Whether to filter out the undirected edges.
     |  
     |  get_edge_node_names_from_edge_node_ids(self, /, edge_node_ids)
     |      Returns result with the edge node names.
     |      
     |      Parameters
     |      ----------
     |      edge_node_ids: List[Tuple[int, int]]
     |          The node names whose node names is to be returned.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          When any of the given node IDs does not exists in the current graph.
     |  
     |  get_edge_node_names_with_known_edge_types(self, /, directed)
     |      Returns edge node names of the edges with known edge types
     |      
     |      Parameters
     |      ----------
     |      directed: bool
     |          Whether to iterated the edges as a directed or undirected edge list.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_edge_prediction_chunk_mini_batch(self, /, idx, graph, batch_size, return_node_types, return_edge_types, return_edge_metrics)
     |      Returns n-ple for running edge predictions on a graph, sampling the graph properties from the graph used in training.
     |      
     |      Parameters
     |      -------------
     |      idx: int
     |          The index of the mini-batch to generate.
     |      graph: Graph
     |          The graph from which to extract the edges to return.
     |      batch_size: int
     |          Maximal size of the mini-batch. The last batch may be smaller.
     |      return_node_types: bool
     |          Whether to return the node types properties of the nodes.
     |      return_edge_types: bool
     |          Whether to return the edge types properties of the edges.
     |      return_edge_metrics: bool
     |          Whether to return the edge metrics that can be computed on generic edges (existing or not) using the training graph (the self).
     |      
     |      Raises
     |      -------------
     |      ValueError
     |          If the current graph does not have node types and node types are requested.
     |      ValueError
     |          If the current graph does not have edge types and edge types are requested.
     |  
     |  get_edge_prediction_kfold(self, /, k, k_index, edge_types, random_state, verbose)
     |      Returns train and test graph following kfold validation scheme.
     |      
     |      The edges are splitted into k chunks. The k_index-th chunk is used to build
     |      the validation graph, all the other edges create the training graph.
     |      
     |      Parameters
     |      ----------
     |      k: int
     |          The number of folds.
     |      k_index: int
     |          Which fold to use for the validation.
     |      edge_types: Optional[&List[Optional[&str]]]
     |          Edge types to be selected when computing the folds (All the edge types not listed here will be always be used in the training set).
     |      random_state: Optional[int]
     |          The random_state (seed) to use for the holdout,
     |      verbose: Optional[bool]
     |          Whether to show the loading bar.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the number of requested k folds is one or zero.
     |      ValueError
     |          If the given k fold index is greater than the number of k folds.
     |      ValueError
     |          If edge types have been specified but it's an empty list.
     |      ValueError
     |          If the number of k folds is higher than the number of edges in the graph.
     |  
     |  get_edge_prediction_mini_batch(self, /, random_state, batch_size, return_edge_ids, return_node_types, return_edge_types, return_edge_metrics, sample_only_edges_with_heterogeneous_node_types, negative_samples_rate, avoid_false_negatives, maximal_sampling_attempts, shuffle, use_scale_free_distribution, graph_to_avoid)
     |      Returns n-ple with index to build numpy array, source node, source node type, destination node, destination node type, edge type and whether this edge is real or artificial.
     |      
     |      Parameters
     |      -------------
     |      random_state: int
     |          The index of the batch to generate, behaves like a random random_state,
     |      batch_size: int
     |          The maximal size of the batch to generate,
     |      return_edge_ids: bool
     |          Whether to return the edge ids.
     |      return_node_types: bool
     |          Whether to return the source and destination nodes node types.
     |      return_edge_types: bool
     |         Whether to return the edge types.
     |      return_edge_metrics: bool
     |          Whether to return the edge metrics.
     |      sample_only_edges_with_heterogeneous_node_types: bool
     |          Whether to sample negative edges only with source and destination nodes that have different node types.
     |      negative_samples_rate: Optional[float]
     |          The component of netagetive samples to use.
     |      avoid_false_negatives: Optional[bool]
     |          Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.
     |      maximal_sampling_attempts: Optional[int]
     |          Number of attempts to execute to sample the negative edges.
     |      use_scale_free_distribution: bool = True
     |          Whether to sample the negative edges following a scale_free distribution.
     |          By default True.
     |      support: Optional[Graph]
     |          Graph to use to compute the edge metrics.
     |          When not provided, the current graph (self) is used.
     |      graph_to_avoid: Optional[Graph]
     |          The graph whose edges are to be avoided during the generation of false negatives,
     |      
     |      Raises
     |      ---------
     |      ValueError
     |          If the given amount of negative samples is not a positive finite real value.
     |      ValueError
     |          If node types are requested but the graph does not contain any.
     |      ValueError
     |          If the `sample_only_edges_with_heterogeneous_node_types` argument is provided as true, but the graph does not have node types.
     |  
     |  get_edge_prediction_subgraphs(self, /, number_of_nodes_to_sample, random_state, node_sampling_method, edge_weighting_methods, add_selfloops_where_missing)
     |      Return subsampled nodes according to the given method and parameters.
     |      
     |      Parameters
     |      --------------------
     |      number_of_nodes_to_sample: int
     |          The number of nodes to sample.
     |      random_state: int
     |          The random state to reproduce the sampling.
     |      node_sampling_method: str
     |          The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.
     |      edge_weighting_methods: List[str]
     |          The edge weighting methods to use to compute the adjacency matrix.
     |      add_selfloops_where_missing: Optional[bool]
     |          Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.
     |      
     |      Raises
     |      --------------------
     |      ValueError
     |          If the given node sampling method is not supported.
     |      ValueError
     |          If any of the given subgraph edge weighting method is not supported.
     |      ValueError
     |          If the list of requested edge weighting methods is empty.
     |      ValueError
     |          If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.
     |      
     |      Returns
     |      --------------------
     |      Tuple with the sampled nodes and the computed kernels.
     |  
     |  get_edge_prediction_subgraphs_from_node_ids(self, /, number_of_nodes_to_sample, random_state, source_root_node, destination_root_node, node_sampling_method, edge_weighting_methods, add_selfloops_where_missing, unique)
     |      Return subsampled nodes according to the given method and parameters.
     |      
     |      Parameters
     |      ----------
     |      number_of_nodes_to_sample: int
     |          The number of nodes to sample.
     |      random_state: int
     |          The random state to reproduce the sampling.
     |      source_root_node: int
     |          The source root node to use to sample. In not provided, a random one is sampled.
     |      destination_root_node: int
     |          The destination root node to use to sample. In not provided, a random one is sampled.
     |      node_sampling_method: str
     |          The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.
     |      edge_weighting_methods: List[str]
     |          The edge weighting methods to use to compute the adjacency matrix.
     |      add_selfloops_where_missing: Optional[bool]
     |          Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.
     |      unique: Optional[bool] = True
     |          Whether to reduce the sampled nodes to a unique set.
     |      
     |      Raises
     |      ------
     |      ValueError
     |          If the given node sampling method is not supported.
     |      ValueError
     |          If any of the given subgraph edge weighting method is not supported.
     |      ValueError
     |          If the list of requested edge weighting methods is empty.
     |      ValueError
     |          If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.
     |      
     |      Returns
     |      -------
     |      Tuple with the sampled nodes and the computed kernels.
     |  
     |  get_edge_type_id_counts_hashmap(self, /)
     |      Returns edge type IDs counts hashmap.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the current graph instance.
     |  
     |  get_edge_type_id_from_edge_id(self, /, edge_id)
     |      Returns edge type of given edge.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          edge whose edge type is to be returned.
     |  
     |  get_edge_type_id_from_edge_node_ids(self, /, src, dst)
     |      Returns edge type from given edge node IDs.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          Source node ID of the node of interest.
     |      dst: int
     |          Destination node ID of the node of interest.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided nodes do not form an edge.
     |  
     |  get_edge_type_id_from_edge_type_name(self, /, edge_type_name)
     |      Return edge type ID curresponding to given edge type name.
     |      
     |      If None is given as an edge type ID, None is returned.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: Optional[&str]
     |          The edge type name whose ID is to be returned.
     |  
     |  get_edge_type_ids_from_edge_type_names(self, /, edge_type_names)
     |      Return translated edge types from string to internal edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_type_names: List[Optional[&str]]
     |          Vector of edge types to be converted.
     |  
     |  get_edge_type_name_from_edge_id(self, /, edge_id)
     |      Returns option with the edge type of the given edge id.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose edge type is to be returned.
     |  
     |  get_edge_type_name_from_edge_type_id(self, /, edge_type_id)
     |      Return edge type name of given edge type.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: int
     |          Id of the edge type.
     |  
     |  get_edge_type_names_counts_hashmap(self, /)
     |      Returns edge type names counts hashmap.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the current graph instance.
     |  
     |  get_edge_types_total_memory_requirements(self, /)
     |      Returns how many bytes are currently used to store the edge types
     |  
     |  get_edge_types_total_memory_requirements_human_readable(self, /)
     |      Returns human readable amount of how many bytes are currently used to store the edge types
     |  
     |  get_edge_weight_from_edge_id(self, /, edge_id)
     |      Returns weight of the given edge id.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose weight is to be returned.
     |  
     |  get_edge_weight_from_node_ids(self, /, src, dst)
     |      Returns weight of the given node ids.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          The node ID of the source node.
     |      dst: int
     |          The node ID of the destination node.
     |  
     |  get_edge_weight_from_node_ids_and_edge_type_id(self, /, src, dst, edge_type)
     |      Returns weight of the given node ids and edge type.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          The node ID of the source node.
     |      dst: int
     |          The node ID of the destination node.
     |      edge_type: Optional[int]
     |          The edge type ID of the edge.
     |  
     |  get_edge_weight_from_node_names(self, /, src_name, dst_name)
     |      Returns weight of the given node names.
     |      
     |      Parameters
     |      ----------
     |      src_name: str
     |          The node name of the source node.
     |      dst_name: str
     |          The node name of the destination node.
     |  
     |  get_edge_weight_from_node_names_and_edge_type_name(self, /, src, dst, edge_type)
     |      Returns weight of the given node names and edge type.
     |      
     |      Parameters
     |      ----------
     |      src: str
     |          The node name of the source node.
     |      dst: str
     |          The node name of the destination node.
     |      edge_type: Optional[&str]
     |          The edge type name of the edge.
     |  
     |  get_edge_weighting_methods(self, /)
     |      Return list of the supported edge weighting methods
     |  
     |  get_edge_weights_total_memory_requirements(self, /)
     |      Returns how many bytes are currently used to store the edge weights
     |  
     |  get_edge_weights_total_memory_requirements_human_readable(self, /)
     |      Returns human readable amount of how many bytes are currently used to store the edge weights
     |  
     |  get_edges_total_memory_requirement(self, /)
     |      Returns how many bytes are currently used to store the edges
     |  
     |  get_edges_total_memory_requirement_human_readable(self, /)
     |      Returns human readable amount of how many bytes are currently used to store the edges
     |  
     |  get_edges_with_unknown_edge_types_mask(self, /)
     |      Returns a boolean vector that for each node contains whether it has an
     |      unknown edge type.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_eigenvector_centrality(self, /, maximum_iterations_number, tollerance)
     |      Returns vector with unweighted eigenvector centrality.
     |      
     |      Parameters
     |      ----------
     |      maximum_iterations_number: Optional[int]
     |          The maximum number of iterations to consider.
     |      tollerance: Optional[float]
     |          The maximum error tollerance for convergence.
     |  
     |  get_filtered_predictions(self, /, path, source_column_name, destination_column_name, prediction_column_name, allowed_source_nodes, allowed_destination_nodes, allowed_source_node_prefixes, allowed_destination_node_prefixes, min_prediction, max_prediction, exclude_existing_edges, exclude_non_existing_edges, separator, remove_chevrons, remove_spaces, support_balanced_quotes, comment_symbol, max_rows_number)
     |      Returns triple with source, destination and predictions according to provided filters.
     |      
     |      Parameters
     |      ----------
     |      path: str
     |          Path to the file to read.
     |      source_column_name: Optional[str]
     |          Name of the source column.
     |      destination_column_name: Optional[str]
     |          Name of the destination column.
     |      prediction_column_name: Optional[str]
     |          Name of the prediction column.
     |      allowed_source_nodes: Optional[List[str]]
     |          List of allowed source nodes.
     |      allowed_destination_nodes: Optional[List[str]]
     |          List of allowed destination nodes.
     |      allowed_source_node_prefixes: Optional[List[str]]
     |          List of allowed source node prefixes.
     |      allowed_destination_node_prefixes: Optional[List[str]]
     |          List of allowed destination node prefixes.
     |      min_prediction: Optional[float]
     |          Minimum prediction to consider.
     |      max_prediction: Optional[float]
     |          Maximum prediction to consider.
     |      exclude_existing_edges: Optional[bool]
     |          Whether to exclude existing edges.
     |      exclude_non_existing_edges: Optional[bool]
     |          Whether to exclude non existing edges.
     |      separator: Optional[str]
     |          Separator used in the file.
     |      remove_chevrons: Optional[bool]
     |          Whether to remove chevrons from the file.
     |      remove_spaces: Optional[bool]
     |          Whether to remove spaces from the file.
     |      support_balanced_quotes: Optional[bool]
     |          Whether to support balanced quotes in the file.
     |      comment_symbol: Optional[str]
     |          Symbol used to indicate that a line is a comment.
     |      max_rows_number: Optional[int]
     |          Maximum number of rows to read.
     |  
     |  get_flat_repeated_isomorphic_node_ids(self, /, minimum_node_degree, number_of_neighbours_for_hash)
     |      Retrieves a vector of flattened and repeated isomorphic node IDs, that is by removing one per group.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_degree: Optional[int]
     |          An optional parameter specifying the minimum degree a node must have to be included
     |  
     |  get_four_sweep(self, /)
     |      Returns approximated diameter and tentative low eccentricity node for an UNDIRECTED graph.
     |      This method returns a lowerbound of the diameter by doing the following steps:
     |      * Find the most central node
     |      * Find the most distant node from the most central one (and get a first
     |      approximation of the diameter lowerbound)
     |      * Get the median node in this path
     |      * Find the most distant node from the median node
     |      * Find the most distant node form the last one, and get the second approx
     |      of the diameter lowerbound.
     |      
     |      This basically creates a "cross" that spans the graph
     |  
     |  get_harmonic_centrality(self, /)
     |      Return vector of harmonic centrality for all nodes.
     |  
     |  get_heterogeneous_graphlet_ids_from_edge_node_ids(self, /, src, dst)
     |  
     |  get_heterogeneous_graphlet_names_from_edge_node_ids(self, /, src, dst)
     |  
     |  get_heterogeneous_graphlet_names_from_edge_node_names(self, /, src, dst)
     |  
     |  get_homogeneous_node_type_ids(self, /)
     |      Returns list of homogeneous node type IDs.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_homogeneous_node_type_names(self, /)
     |      Returns list of homogeneous node type names.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_imputed_directed_edge_type_ids(self, /, imputation_edge_type_id)
     |      Return the inputed directed edge types of the edges.
     |      
     |      Parameters
     |      ----------
     |      imputation_edge_type_id: int
     |          The edge type id value to impute with.
     |  
     |  get_imputed_lower_triangular_edge_type_ids(self, /, imputation_edge_type_id)
     |      Return the imputed lower triangular edge types of the edges.
     |      
     |      Parameters
     |      ----------
     |      imputation_edge_type_id: int
     |          The edge type id value to impute with.
     |  
     |  get_imputed_upper_triangular_edge_type_ids(self, /, imputation_edge_type_id)
     |      Return the imputed upper triangular edge types of the edges.
     |      
     |      Parameters
     |      ----------
     |      imputation_edge_type_id: int
     |          The edge type id value to impute with.
     |  
     |  get_isomorphic_edge_hashes(self, /, minimum_node_degree, number_of_neighbours_for_hash, ignore_edges_including_isomorphic_nodes, dtype)
     |      Retrieves the isomorphic edge hashes
     |      
     |      Parameters
     |      ----------
     |  
     |  get_isomorphic_edge_node_ids(self, /, minimum_node_degree, number_of_neighbours_for_hash, ignore_edges_including_isomorphic_nodes, dtype)
     |      Returns vector with isomorphic edge groups IDs.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_degree: Optional[int]
     |          Minimum node degree for the topological synonims. By default, 10.
     |      number_of_neighbours_for_hash: Optional[int]
     |          The number of neighbours to consider for the hash. By default 10.
     |      ignore_edges_including_isomorphic_nodes: Optional[bool]
     |          Whether to ignore edges including isomorphic nodes. By default, true.
     |      dtype: Optional[&str]
     |          The data type of the hash. By default, `&str`.
     |  
     |  get_isomorphic_edge_node_names(self, /, minimum_node_degree, number_of_neighbours_for_hash, ignore_edges_including_isomorphic_nodes, dtype)
     |      Returns vector with isomorphic edge groups names.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_degree: Optional[int]
     |          Minimum node degree for the topological synonims. By default, 10.
     |      number_of_neighbours_for_hash: Optional[int]
     |          The number of neighbours to consider for the hash. By default 10.
     |      ignore_edges_including_isomorphic_nodes: Optional[bool]
     |          Whether to ignore edges including isomorphic nodes. By default, true.
     |      dtype: Optional[&str]
     |          The data type of the hash. By default, `&str`.
     |  
     |  get_isomorphic_edge_type_ids_groups(self, /, minimum_number_of_edges)
     |      Returns vector with isomorphic edge type groups IDs.
     |      
     |      Parameters
     |      ----------
     |      minimum_number_of_edges: Optional[int]
     |          Minimum number of edges to detect edge types topological synonims. By default, 5.
     |  
     |  get_isomorphic_edge_type_names_groups(self, /, minimum_number_of_edges)
     |      Returns vector with isomorphic edge type groups names.
     |      
     |      Parameters
     |      ----------
     |      minimum_number_of_edges: Optional[int]
     |          Minimum number of edges to detect edge types topological synonims. By default, 5.
     |  
     |  get_isomorphic_node_hashes(self, /, minimum_node_degree, number_of_neighbours_for_hash, dtype)
     |      Retrieves the isomorphic node hashes
     |      
     |      Parameters
     |      ----------
     |  
     |  get_isomorphic_node_ids(self, /, minimum_node_degree, number_of_neighbours_for_hash, dtype)
     |      Returns vector with isomorphic node groups IDs.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_degree: Optional[int]
     |          Minimum node degree for the topological synonims. By default, 10.
     |      number_of_neighbours_for_hash: Optional[int]
     |          The number of neighbours to consider for the hash. By default 10.
     |      dtype: Optional[&str]
     |          The data type of the hash. By default, `&str`.
     |  
     |  get_isomorphic_node_names(self, /, minimum_node_degree, number_of_neighbours_for_hash, dtype)
     |      Returns vector with isomorphic node groups names.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_degree: Optional[int]
     |          Minimum node degree for the topological synonims. By default, 10.
     |      number_of_neighbours_for_hash: Optional[int]
     |          The number of neighbours to consider for the hash. By default 10.
     |      dtype: Optional[&str]
     |          The data type of the hash. By default, `&str`.
     |  
     |  get_isomorphic_node_type_ids_groups(self, /)
     |      Returns vector with isomorphic node type groups IDs
     |  
     |  get_isomorphic_node_type_names_groups(self, /)
     |      Returns vector with isomorphic node type groups names
     |  
     |  get_isomorphic_nodes_mask(self, /, minimum_node_degree, number_of_neighbours_for_hash)
     |      Get a mask indicating the nodes that are isomorphic.
     |      
     |      This method identifies the nodes that are isomorphic based on their minimum
     |      degree and the number of neighbors used for hashing. It populates a deny mask
     |      where the nodes that are isomorphic are marked as `true`.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_isomorphic_tuple_hashes(self, /, minimum_node_degree, number_of_neighbours_for_hash, dtype)
     |      Retrieves the isomorphic tuple hashes
     |      
     |      Parameters
     |      ----------
     |  
     |  get_isomorphic_tuple_node_ids(self, /, minimum_node_degree, number_of_neighbours_for_hash, dtype)
     |      Returns vector with isomorphic tuple groups IDs.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_degree: Optional[int]
     |          Minimum node degree for the topological synonims. By default, 10.
     |      number_of_neighbours_for_hash: Optional[int]
     |          The number of neighbours to consider for the hash. By default 10.
     |      dtype: Optional[&str]
     |          The data type of the hash. By default, `&str`.
     |  
     |  get_isomorphic_tuple_node_names(self, /, minimum_node_degree, number_of_neighbours_for_hash, dtype)
     |      Returns vector with isomorphic tuple groups names.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_degree: Optional[int]
     |          Minimum node degree for the topological synonims. By default, 10.
     |      number_of_neighbours_for_hash: Optional[int]
     |          The number of neighbours to consider for the hash. By default 10.
     |      dtype: Optional[&str]
     |          The data type of the hash. By default, `&str`.
     |  
     |  get_jaccard_coefficient_from_node_ids(self, /, source_node_id, destination_node_id)
     |      Returns the Jaccard index for the two given nodes from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the node IDs are higher than the number of nodes in the graph.
     |  
     |  get_jaccard_coefficient_from_node_names(self, /, first_node_name, second_node_name)
     |      Returns the Jaccard index for the two given nodes from the given node names.
     |      
     |      Parameters
     |      ----------
     |      first_node_name: str
     |          Node name of the first node.
     |      second_node_name: str
     |          Node name of the second node.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the given node names do not exist in the current graph.
     |  
     |  get_jaccard_coefficient_scores(self, /, subgraph)
     |      Returns Jaccard Coefficient for all edges.
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided subgraph graph does not share a compatible vocabulary with the current graph instance.
     |  
     |  get_jaccard_coo_matrix(self, /)
     |      Returns Jaccard coo matrix
     |  
     |  get_jaccard_graph(self, /)
     |      Returns jaccard weighted graph
     |  
     |  get_k_shortest_path_node_ids_from_node_ids(self, /, src_node_id, dst_node_id, k)
     |      Return vector of the k minimum paths node IDs between given source node and destination node ID.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Source node ID.
     |      dst_node_id: int
     |          Destination node ID.
     |      maximal_depth: Optional[int]
     |          The maximal depth to execute the BFS for.
     |      k: int
     |          Number of paths to find.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If any of the given node IDs does not exist in the graph.
     |  
     |  get_k_shortest_path_node_ids_from_node_names(self, /, src_node_name, dst_node_name, k)
     |      Return vector of the k minimum paths node IDs between given source node and destination node name.
     |      
     |      Parameters
     |      ----------
     |      src_node_name: str
     |          Source node name.
     |      dst_node_name: str
     |          Destination node name.
     |      k: int
     |          Number of paths to find.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If any of the given node names does not exist in the graph.
     |  
     |  get_k_shortest_path_node_names_from_node_names(self, /, src_node_name, dst_node_name, k)
     |      Return vector of the k minimum paths node names between given source node and destination node name.
     |      
     |      Parameters
     |      ----------
     |      src_node_name: str
     |          Source node name.
     |      dst_node_name: str
     |          Destination node name.
     |      k: int
     |          Number of paths to find.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If any of the given node names does not exist in the graph.
     |  
     |  get_known_boolean_node_type_ids(self, /, target_value)
     |      Returns 1D binarized known node types ids vector
     |  
     |  get_known_edge_types_mask(self, /)
     |      Returns boolean mask of known edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  get_known_edge_types_rate(self, /)
     |      Returns rate of known edge types over total edges number.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_known_node_types_mask(self, /)
     |      Returns boolean mask of known node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_known_node_types_rate(self, /)
     |      Returns rate of known node types over total nodes number.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_known_single_label_node_type_ids(self, /)
     |      Returns 1D known single labeled node types ids vector.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph has multilabel node types.
     |  
     |  get_laplacian_coo_matrix(self, /)
     |      Returns Laplacian coo matrix
     |  
     |  get_laplacian_graph(self, /)
     |      Returns Laplacian weighted graph
     |  
     |  get_left_normalized_laplacian_coo_matrix(self, /)
     |      Returns left normalized Laplacian coo matrix
     |  
     |  get_left_normalized_laplacian_graph(self, /)
     |      Returns left normalized Laplacian weighted graph
     |  
     |  get_lower_triangular_edge_ids_with_known_edge_types(self, /)
     |      Returns lower triangular edge IDs of the edges with known edge types
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_lower_triangular_edge_ids_with_unknown_edge_types(self, /)
     |      Returns lower triangular edge IDs of the edges with unknown edge types
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_lower_triangular_edge_type_ids(self, /)
     |      Return the lower triangular edge types of the edges
     |  
     |  get_lower_triangular_edge_type_names(self, /)
     |      Return the lower triangular edge type names of the edges
     |  
     |  get_lower_triangular_known_edge_type_ids(self, /)
     |      Return the lower triangular known edge types of the edges, dropping unknown ones
     |  
     |  get_lower_triangular_known_edge_types_mask(self, /)
     |      Returns a boolean vector with known edge types from the lower triangular matrix.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |      ValueError
     |          If the graph is not undirected.
     |  
     |  get_max_clique(self, /)
     |      Returns the maximum clique in the graph.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the current graph is directed.
     |  
     |  get_maximum_edge_weight(self, /)
     |      Return the maximum weight, if graph has weights.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain edge weights.
     |  
     |  get_maximum_multilabel_count(self, /)
     |      Returns number of maximum multilabel count.
     |      
     |      This value is the maximum number of multilabel counts
     |      that appear in any given node in the graph
     |  
     |  get_maximum_node_degree(self, /)
     |      Returns maximum node degree of the graph.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain any node (is an empty graph).
     |  
     |  get_maximum_number_of_edge_types(self, /)
     |      Returns maximum number of edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_maximum_number_of_node_types(self, /)
     |      Returns maximum number of node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_memory_stats(self, /)
     |      Returns a string describing the memory usage of all the fields of all the
     |      structures used to store the current graph
     |  
     |  get_minimum_node_degree(self, /)
     |      Returns minimum node degree of the graph.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain any node (is an empty graph).
     |  
     |  get_minimum_number_of_edge_types(self, /)
     |      Returns minimum number of edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_minimum_number_of_node_types(self, /)
     |      Returns minimum number of node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_mininum_edge_weight(self, /)
     |      Return the minimum weight, if graph has weights.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain edge weights.
     |  
     |  get_minmax_edge_ids_from_node_ids(self, /, src, dst)
     |      Return range of outbound edges IDs for all the edges bewteen the given
     |      source and destination nodes.
     |      This operation is meaningfull only in a multigraph.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          Source node.
     |      dst: int
     |          Destination node.
     |  
     |  get_minmax_edge_ids_from_source_node_id(self, /, src)
     |      Return range of outbound edges IDs which have as source the given Node.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          Node for which we need to compute the cumulative_node_degrees range.
     |  
     |  get_most_central_node_id(self, /)
     |      Returns maximum node degree of the graph.
     |  
     |  get_multigraph_edge_ids_from_node_ids(self, /, src, dst)
     |      Returns edge IDs of multigraph edge ids with same source and destination nodes and different edge type.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          Source node id of the edge.
     |      dst: int
     |           Destination node id of the edge.
     |  
     |  get_multiple_node_type_ids_from_node_type_names(self, /, node_type_names)
     |      Return translated node types from string to internal node ID.
     |      
     |      Parameters
     |      ----------
     |      node_type_names: List[Optional[List[&str]]]
     |          Vector of node types to be converted.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If any of the given node type names do not exists in the graph.
     |  
     |  get_name(self, /)
     |      Return name of the graph.
     |  
     |  get_neighbour_node_ids_from_node_id(self, /, node_id)
     |      Return vector of destinations for the given source node ID.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Node ID whose neighbours are to be retrieved.
     |  
     |  get_neighbour_node_ids_from_node_name(self, /, node_name)
     |      Return vector of destinations for the given source node name.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          Node ID whose neighbours are to be retrieved.
     |  
     |  get_neighbour_node_names_from_node_name(self, /, node_name)
     |      Return vector of destination names for the given source node name.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          Node name whose neighbours are to be retrieved.
     |  
     |  get_neighbours_intersection_size_coo_matrix(self, /)
     |      Returns neighbours intersection size coo matrix
     |  
     |  get_neighbours_intersection_size_graph(self, /)
     |      Returns neighbours intersection size weighted graph
     |  
     |  get_node_connected_component_ids(self, /, verbose)
     |      Return a vector with the components each node belongs to.
     |      
     |      E.g. If we have two components `[0, 2, 3]` and `[1, 4, 5]` the result will look like
     |      `[0, 1, 0, 0, 1, 1]`
     |      
     |      Parameters
     |      ----------
     |      verbose: Optional[bool]
     |          Whether to show the loading bar.
     |  
     |  get_node_count_from_node_type_id(self, /, node_type_id)
     |      Return number of nodes with given node type ID.
     |      
     |      If None is given as an node type ID, the unknown node types
     |      will be returned.
     |      
     |      Parameters
     |      ----------
     |      node_type_id: Optional[int]
     |          The node type ID to count the nodes of.
     |  
     |  get_node_count_from_node_type_name(self, /, node_type_name)
     |      Return number of nodes with given node type name.
     |      
     |      If None is given as an node type name, the unknown node types
     |      will be returned.
     |      
     |      Parameters
     |      ----------
     |      node_type_name: Optional[&str]
     |          The node type name to count the nodes of.
     |  
     |  get_node_degree_from_node_id(self, /, node_id)
     |      Returns the number of outbound neighbours of given node ID.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node.
     |  
     |  get_node_degree_from_node_name(self, /, node_name)
     |      Returns the number of outbound neighbours of given node name.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          Integer ID of the node.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node name does not exist in the graph.
     |  
     |  get_node_degree_geometric_distribution_threshold(self, /, number_of_nodes_above_threshold)
     |      Return threshold representing cutuoff point in graph node degree geometric distribution to have the given amount of elements above cutoff.
     |      
     |      Parameters
     |      ----------
     |      number_of_elements_above_threshold: int
     |          Number of elements expected to be above cutoff threshold.
     |  
     |  get_node_degrees(self, /)
     |      Returns the unweighted degree of every node in the graph
     |  
     |  get_node_degrees_mean(self, /)
     |      Returns unweighted mean node degree of the graph.
     |  
     |  get_node_degrees_median(self, /)
     |      Returns unweighted median node degree of the graph
     |  
     |  get_node_degrees_mode(self, /)
     |      Returns mode node degree of the graph.
     |  
     |  get_node_id_from_node_name(self, /, node_name)
     |      Returns result with the node ID.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          The node name whose node ID is to be returned.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          When the given node name does not exists in the current graph.
     |  
     |  get_node_ids(self, /)
     |      Return vector with the sorted nodes Ids
     |  
     |  get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(self, /, edge_id)
     |      Return the src, dst, edge type and weight of a given edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source, destination, edge type and weight are to be retrieved.
     |  
     |  get_node_ids_and_edge_type_id_from_edge_id(self, /, edge_id)
     |      Return the src, dst, edge type of a given edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source, destination and edge type are to be retrieved.
     |  
     |  get_node_ids_from_edge_id(self, /, edge_id)
     |      Returns node names corresponding to given edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source and destination node IDs are to e retrieved.
     |  
     |  get_node_ids_from_node_curie_prefixes(self, /, curie_prefixes)
     |      Returns vector with node IDs with given curie prefix.
     |      
     |      Parameters
     |      ----------
     |      curie_prefixes: List[str]
     |          Prefix of the source node names.
     |  
     |  get_node_ids_from_node_names(self, /, node_names)
     |      Returns result with the node IDs.
     |      
     |      Parameters
     |      ----------
     |      node_names: List[&str]
     |          The node names whose node IDs is to be returned.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          When any of the given node name does not exists in the current graph.
     |  
     |  get_node_ids_from_node_type_id(self, /, node_type_id)
     |      Returns node IDs of the nodes with given node type ID.
     |      
     |      Parameters
     |      ----------
     |      node_type_id: int
     |          The node type ID to filter for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_node_ids_from_node_type_ids(self, /, node_type_ids)
     |      Returns node IDs of the nodes with given node type IDs.
     |      
     |      Parameters
     |      ----------
     |      node_type_ids: List[Optional[int]]
     |          The node type ID to filter for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_node_ids_from_node_type_name(self, /, node_type_name)
     |      Returns node IDs of the nodes with given node type name.
     |      
     |      Parameters
     |      ----------
     |      node_type_name: str
     |          The node type ID to filter for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_node_ids_from_node_type_names(self, /, node_type_names)
     |      Returns node IDs of the nodes with given node type names.
     |      
     |      Parameters
     |      ----------
     |      node_type_names: List[Optional[&str]]
     |          The node type ID to filter for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_node_ids_mapping_from_graph(self, /, other)
     |      Returns mapping from the current graph node names to the other provided graph node names.
     |      
     |      Parameters
     |      ----------
     |      other: Graph
     |          The other graph to which remap the node names.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is not contained in the provided other graph.
     |  
     |  get_node_ids_with_known_node_types(self, /)
     |      Returns node IDs of the nodes with known node types
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_node_ids_with_unknown_node_types(self, /)
     |      Returns node IDs of the nodes with unknown node types
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_node_indegrees(self, /)
     |      Return the indegree for each node.
     |  
     |  get_node_label_holdout_graphs(self, /, train_size, use_stratification, random_state)
     |      Returns node-label holdout for training ML algorithms on the graph node labels.
     |      
     |      Parameters
     |      ----------
     |      train_size: float
     |          rate target to reserve for training,
     |      use_stratification: Optional[bool]
     |          Whether to use node-label stratification,
     |      random_state: Optional[int]
     |          The random_state to use for the holdout,
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If stratification is requested but the graph has a single node type.
     |      ValueError
     |          If stratification is requested but the graph has a multilabel node types.
     |  
     |  get_node_label_holdout_indices(self, /, train_size, use_stratification, random_state)
     |      Returns node-label holdout indices for training ML algorithms on the graph node labels.
     |      
     |      Parameters
     |      ----------
     |      train_size: float
     |          rate target to reserve for training,
     |      use_stratification: Optional[bool]
     |          Whether to use node-label stratification,
     |      random_state: Optional[int]
     |          The random_state to use for the holdout,
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If stratification is requested but the graph has a single node type.
     |      ValueError
     |          If stratification is requested but the graph has a multilabel node types.
     |  
     |  get_node_label_holdout_labels(self, /, train_size, use_stratification, random_state)
     |      Returns node-label holdout indices for training ML algorithms on the graph node labels.
     |      
     |      Parameters
     |      ----------
     |      train_size: float
     |          rate target to reserve for training,
     |      use_stratification: Optional[bool]
     |          Whether to use node-label stratification,
     |      random_state: Optional[int]
     |          The random_state to use for the holdout,
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If stratification is requested but the graph has a single node type.
     |      ValueError
     |          If stratification is requested but the graph has a multilabel node types.
     |  
     |  get_node_label_kfold(self, /, k, k_index, use_stratification, random_state)
     |      Returns node-label fold for training ML algorithms on the graph node labels.
     |      
     |      Parameters
     |      ----------
     |      k: int
     |          The number of folds.
     |      k_index: int
     |          Which fold to use for the validation.
     |      use_stratification: Optional[bool]
     |          Whether to use node-label stratification,
     |      random_state: Optional[int]
     |          The random_state to use for the holdout,
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If stratification is requested but the graph has a single node type.
     |      ValueError
     |          If stratification is requested but the graph has a multilabel node types.
     |  
     |  get_node_label_random_holdout(self, /, train_size, use_stratification, random_state)
     |      Returns node-label holdout for training ML algorithms on the graph node labels.
     |      
     |      Parameters
     |      ----------
     |      train_size: float
     |          rate target to reserve for training,
     |      use_stratification: Optional[bool]
     |          Whether to use node-label stratification,
     |      random_state: Optional[int]
     |          The random_state to use for the holdout,
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If stratification is requested but the graph has a single node type.
     |      ValueError
     |          If stratification is requested but the graph has a multilabel node types.
     |  
     |  get_node_name_from_node_id(self, /, node_id)
     |      Returns result with the node name.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID whose name is to be returned.
     |  
     |  get_node_names(self, /)
     |      Return vector with the sorted nodes names
     |  
     |  get_node_names_from_edge_id(self, /, edge_id)
     |      Returns node names corresponding to given edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source and destination node IDs are to e retrieved.
     |  
     |  get_node_names_from_node_curie_prefixes(self, /, curie_prefixes)
     |      Returns vector with node names with given curie prefix.
     |      
     |      Parameters
     |      ----------
     |      curie_prefixes: List[&str]
     |          Prefix of the source node names.
     |  
     |  get_node_names_from_node_ids(self, /, node_ids)
     |      Returns result with the node names.
     |      
     |      Parameters
     |      ----------
     |      node_ids: List[int]
     |          The node ids whose node names are to be returned.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          When any of the given node ids does not exists in the current graph.
     |  
     |  get_node_names_from_node_type_id(self, /, node_type_id)
     |      Returns node names of the nodes with given node type ID.
     |      
     |      Parameters
     |      ----------
     |      node_type_id: int
     |          The node type ID to filter for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_node_names_from_node_type_name(self, /, node_type_name)
     |      Returns node names of the nodes with given node type name.
     |      
     |      Parameters
     |      ----------
     |      node_type_name: str
     |          The node type ID to filter for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_node_names_prefixes(self, /, separator)
     |      Returns vector with node names prefixes when the node names include the provided separator.
     |      
     |      Parameters
     |      ----------
     |      separator: Optional[&str]
     |          The separator to use to determine a prefix. By default, a column
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided separator is empty.
     |  
     |  get_node_names_with_known_node_types(self, /)
     |      Returns node names of the nodes with known node types
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_node_names_with_unknown_node_types(self, /)
     |      Returns node names of the nodes with unknown node types
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_node_ontologies(self, /)
     |      Return vector with the node predicted ontology.
     |  
     |  get_node_report_from_node_id(self, /, node_id)
     |      Return human-readable html report of the given node.
     |      
     |      The report, by default, is rendered using html.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Whether to show a loading bar in graph operations.
     |  
     |  get_node_report_from_node_name(self, /, node_name)
     |      Return human-readable html report of the given node.
     |      
     |      The report, by default, is rendered using html.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          Whether to show a loading bar in graph operations.
     |  
     |  get_node_sampling_methods(self, /)
     |      Return list of the supported node sampling methods
     |  
     |  get_node_tuples(self, /)
     |      Return vector of node tuples in the current graph instance
     |  
     |  get_node_type_id_counts_hashmap(self, /)
     |      Returns node type IDs counts hashmap.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the current graph instance.
     |  
     |  get_node_type_id_from_node_type_name(self, /, node_type_name)
     |      Return node type ID curresponding to given node type name.
     |      
     |      Parameters
     |      ----------
     |      node_type_name: str
     |          The node type name whose ID is to be returned.
     |  
     |  get_node_type_ids(self, /)
     |      Return the node types of the graph nodes.
     |  
     |  get_node_type_ids_from_node_id(self, /, node_id)
     |      Returns node type of given node.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          node whose node type is to be returned.
     |  
     |  get_node_type_ids_from_node_name(self, /, node_name)
     |      Return node type ID for the given node name if available.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          Name of the node.
     |  
     |  get_node_type_ids_from_node_type_names(self, /, node_type_names)
     |      Return translated node types from string to internal node ID.
     |      
     |      Parameters
     |      ----------
     |      node_type_names: List[Optional[&str]]
     |          Vector of node types to be converted.
     |  
     |  get_node_type_name_from_node_name(self, /, node_name)
     |      Return node type name for the given node name if available.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          Name of the node.
     |  
     |  get_node_type_name_from_node_type_id(self, /, node_type_id)
     |      Return node type name of given node type.
     |      
     |      There is no need for a unchecked version since we will have to map
     |      on the note_types anyway.
     |      
     |      Parameters
     |      ----------
     |      node_type_id: int
     |          Id of the node type.
     |  
     |  get_node_type_names(self, /)
     |      Return the node types names.
     |  
     |  get_node_type_names_counts_hashmap(self, /)
     |      Returns node type names counts hashmap.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the current graph instance.
     |  
     |  get_node_type_names_from_node_id(self, /, node_id)
     |      Returns result of option with the node type of the given node id.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID whose node types are to be returned.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the node types are not available for the current graph instance.
     |  
     |  get_node_type_names_from_node_name(self, /, node_name)
     |      Returns result of option with the node type of the given node name.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          The node name whose node types are to be returned.
     |  
     |  get_node_types_total_memory_requirements(self, /)
     |      Returns how many bytes are currently used to store the node types
     |  
     |  get_node_types_total_memory_requirements_human_readable(self, /)
     |      Returns human readable amount of how many bytes are currently used to store the node types
     |  
     |  get_node_urls(self, /)
     |      Return vector with the node URLs.
     |  
     |  get_nodes_mapping(self, /)
     |      Return the nodes mapping
     |  
     |  get_nodes_total_memory_requirement(self, /)
     |      Returns how many bytes are currently used to store the nodes
     |  
     |  get_nodes_total_memory_requirement_human_readable(self, /)
     |      Returns human readable amount of how many bytes are currently used to store the nodes
     |  
     |  get_nodes_with_known_node_types_mask(self, /)
     |      Returns a boolean vector that for each node contains whether it has an
     |      known node type.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_nodes_with_unknown_node_types_mask(self, /)
     |      Returns a boolean vector that for each node contains whether it has an
     |      unknown node type.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_non_zero_subgraph_node_degrees(self, /, subgraph)
     |      Returns the degree of every node in the provided subgraph
     |  
     |  get_not_singletons_node_ids(self, /)
     |      Return set of nodes that are not singletons
     |  
     |  get_number_of_approximated_isomorphic_node_type_groups(self, /)
     |      Returns number of isomorphic node type groups
     |  
     |  get_number_of_available_edge_metrics(self, /)
     |      Returns number of currently subgraphed edge metrics
     |  
     |  get_number_of_connected_components(self, /, verbose)
     |      Returns number a triple with (number of components, number of nodes of the smallest component, number of nodes of the biggest component )
     |      
     |      Parameters
     |      ----------
     |      verbose: Optional[bool]
     |          Whether to show a loading bar or not.
     |  
     |  get_number_of_connected_nodes(self, /)
     |      Returns number of connected nodes in the graph.
     |  
     |  get_number_of_directed_edges(self, /)
     |      Returns number of directed edges in the graph
     |  
     |  get_number_of_directed_edges_from_node_curie_prefixes(self, /, src_node_name_prefixes, dst_node_name_prefixes)
     |      Returns number of directed edge IDs with given node name prefixes.
     |      
     |      Parameters
     |      ----------
     |      src_node_name_prefixes: Optional[List[&str]]
     |          Prefix of the source node names.
     |      dst_node_name_prefixes: Optional[List[&str]]
     |          Prefix of the source node names.
     |  
     |  get_number_of_disconnected_nodes(self, /)
     |      Returns number of disconnected nodes within the graph.
     |      A Disconnected node is a node which is nor a singleton nor a singleton
     |      with selfloops.
     |  
     |  get_number_of_edge_types(self, /)
     |      Returns number of edge types in the graph.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the current graph.
     |  
     |  get_number_of_edges(self, /)
     |      Returns number of edges of the graph.
     |  
     |  get_number_of_edges_from_edge_type_id(self, /, edge_type_id)
     |      Return number of edges with the provided edge type ID.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: int
     |          The edge type to return the number of edges of.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |      ValueError
     |          If the provided edge type ID does not exist in the graph.
     |  
     |  get_number_of_edges_from_edge_type_name(self, /, edge_type_name)
     |      Return number of edges with the provided edge type name.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: str
     |          The edge type to return the number of edges of.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |      ValueError
     |          If the provided edge type name does not exist in the graph.
     |  
     |  get_number_of_homogeneous_node_types(self, /)
     |      Returns number of homogeneous node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_number_of_isomorphic_edge_type_groups(self, /, minimum_number_of_edges)
     |      Returns number of isomorphic edge type groups.
     |      
     |      Parameters
     |      ----------
     |      minimum_number_of_edges: Optional[int]
     |          Minimum number of edges to detect edge types topological synonims. By default, 5.
     |  
     |  get_number_of_isomorphic_node_type_groups(self, /)
     |      Returns number of isomorphic node type groups
     |  
     |  get_number_of_known_edge_types(self, /)
     |      Returns the number of edge with known edge type.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_number_of_known_node_types(self, /)
     |      Returns the number of node with known node type.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_number_of_multigraph_edges_from_node_ids(self, /, src, dst)
     |      Returns number of multigraph edges with same source and destination nodes and different edge type.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          Source node id of the edge.
     |      dst: int
     |           Destination node id of the edge.
     |  
     |  get_number_of_node_types(self, /)
     |      Returns number of node types in the graph.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the current graph.
     |  
     |  get_number_of_nodes(self, /)
     |      Returns number of nodes in the graph
     |  
     |  get_number_of_nodes_from_node_curie_prefixes(self, /, curie_prefixes)
     |      Returns number of nodes with node IDs with given curie prefix.
     |      
     |      Parameters
     |      ----------
     |      curie_prefixes: List[&str]
     |          Prefix of the source node names.
     |  
     |  get_number_of_nodes_from_node_type_id(self, /, node_type_id)
     |      Return number of nodes with the provided node type ID.
     |      
     |      Parameters
     |      ----------
     |      node_type_id: int
     |          The node type to return the number of nodes of.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If the provided node type ID does not exist in the graph.
     |  
     |  get_number_of_nodes_from_node_type_name(self, /, node_type_name)
     |      Return number of nodes with the provided node type name.
     |      
     |      Parameters
     |      ----------
     |      node_type_name: str
     |          The node type to return the number of nodes of.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If the provided node type name does not exist in the graph.
     |  
     |  get_number_of_parallel_edges(self, /)
     |      Return number of edges that have multigraph syblings
     |  
     |  get_number_of_selfloops(self, /)
     |      Returns number of self-loops, including also those in eventual multi-edges.
     |  
     |  get_number_of_selfloops_from_node_id(self, /, node_id)
     |      Returns number of self-loops associated to the provided node ID.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID for which to retrieve the number of self-loops.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_number_of_selfloops_from_node_name(self, /, node_name)
     |      Returns number of self-loops associated to the provided node name.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          The node name for which to retrieve the number of self-loops.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_number_of_singleton_edge_types(self, /)
     |      Returns number of singleton edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  get_number_of_singleton_node_types(self, /)
     |      Returns number of singleton node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_number_of_singleton_nodes(self, /)
     |      Returns number of singleton nodes within the graph.
     |  
     |  get_number_of_singleton_nodes_with_selfloops(self, /)
     |      Returns number of singleton nodes with selfloops within the graph.
     |  
     |  get_number_of_squares(self, /, approach, insert_only_source, verbose)
     |      Returns number of squares in the graph.
     |      
     |      Parameters
     |      ----------
     |      approach: Optional[&str]
     |          The approach name to be used. By default, the increasing node degree order is used.
     |      insert_only_source: Optional[bool]
     |          Whether to insert only the source node or both source and destination. By default only the source is inserted.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar. By default, True.
     |  
     |  get_number_of_squares_per_node(self, /, approach, insert_only_source, verbose)
     |      Returns number of squares in the graph.
     |      
     |      Parameters
     |      ----------
     |      approach: Optional[&str]
     |          The approach name to be used. By default, the increasing node degree order is used.
     |      insert_only_source: Optional[bool]
     |          Whether to insert only the source node or both source and destination. By default only the source is inserted.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar. By default, True.
     |  
     |  get_number_of_trap_nodes(self, /)
     |      Return the number of traps nodes (nodes without any outgoing edges that are not singletons)
     |  
     |  get_number_of_trap_nodes_with_selfloops(self, /)
     |      Return the number of traps nodes with selfloops (nodes without any outgoing edges that are not singletons)
     |  
     |  get_number_of_triads(self, /)
     |      Returns total number of triads in the graph without taking into account weights
     |  
     |  get_number_of_triangles(self, /, approach, insert_only_source, verbose)
     |      Returns number of triangles in the graph.
     |      
     |      Parameters
     |      ----------
     |      approach: Optional[&str]
     |          The approach name to be used. By default, the increasing node degree order is used.
     |      insert_only_source: Optional[bool]
     |          Whether to insert only the source node or both source and destination. By default only the source is inserted.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar. By default, True.
     |  
     |  get_number_of_triangles_per_node(self, /, approach, insert_only_source, verbose)
     |      Returns number of triangles for all nodes in the graph.
     |      
     |      Parameters
     |      ----------
     |      approach: Optional[&str]
     |          The approach name to be used. By default, the increasing node degree order is used.
     |      insert_only_source: Optional[bool]
     |          Whether to insert only the source node or both source and destination. By default only the source is inserted.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar. By default, True.
     |  
     |  get_number_of_undirected_edges(self, /)
     |      Returns number of undirected edges of the graph.
     |  
     |  get_number_of_unique_directed_edges(self, /)
     |      Return number of the unique edges in the graph
     |  
     |  get_number_of_unique_edges(self, /)
     |      Returns number of unique edges of the graph.
     |  
     |  get_number_of_unique_selfloops(self, /)
     |      Returns number of unique self-loops, excluding those in eventual multi-edges.
     |  
     |  get_number_of_unique_source_nodes(self, /)
     |      Returns number of the source nodes.
     |  
     |  get_number_of_unique_undirected_edges(self, /)
     |      Returns number of undirected edges of the graph.
     |  
     |  get_number_of_unknown_edge_types(self, /)
     |      Returns number of unknown edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_number_of_unknown_node_types(self, /)
     |      Returns number of nodes with unknown node type.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_number_of_weighted_singleton_nodes(self, /)
     |      Return the number of weighted singleton nodes, i.e. nodes with weighted node degree equal to zero
     |  
     |  get_number_of_weighted_triads(self, /)
     |      Returns total number of triads in the weighted graph
     |  
     |  get_okapi_bm25_node_feature_propagation(self, /, features, iterations, maximal_distance, k1, b, include_central_node, verbose)
     |      Returns okapi node features propagation within given maximal distance.
     |      
     |      Parameters
     |      ----------
     |      features: List[Optional[List[float]]]
     |          The features to propagate. Use None to represent eventual unknown features.
     |      iterations: Optional[int]
     |          The number of iterations to execute. By default one.
     |      maximal_distance: Optional[int]
     |          The distance to consider for the cooccurrences. The default value is 3.
     |      k1: Optional[float]
     |          The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.
     |      b: Optional[float]
     |          The b parameter from okapi. Tipicaly 0.75.
     |      include_central_node: Optional[bool]
     |          Whether to include the central node. By default true.
     |      verbose: Optional[bool]
     |          Whether to show loading bar.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_okapi_bm25_node_label_propagation(self, /, iterations, maximal_distance, k1, b, verbose)
     |      Returns okapi node label propagation within given maximal distance.
     |      
     |      Parameters
     |      ----------
     |      iterations: Optional[int]
     |          The number of iterations to execute. By default one.
     |      maximal_distance: Optional[int]
     |          The distance to consider for the cooccurrences. The default value is 3.
     |      k1: Optional[float]
     |          The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.
     |      b: Optional[float]
     |          The b parameter from okapi. Tipicaly 0.75.
     |      verbose: Optional[bool]
     |          Whether to show loading bar.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_one_hot_encoded_edge_types(self, /)
     |      Returns one-hot encoded edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  get_one_hot_encoded_known_edge_types(self, /)
     |      Returns one-hot encoded known edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  get_one_hot_encoded_known_node_types(self, /)
     |      Returns one-hot encoded known node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_one_hot_encoded_node_types(self, /)
     |      Returns one-hot encoded node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_ontology_from_node_id(self, /, node_id)
     |      Return node ontology for the provided node id, if available.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node id to query for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided node ID does not exist in the current graph.
     |  
     |  get_ontology_from_node_name(self, /, node_name)
     |      Return node ontology for the provided node name, if available.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          The node name to query for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided node name does not exist in the current graph.
     |  
     |  get_predictions_histograms(self, /, path, source_column_name, destination_column_name, prediction_column_name, allowed_source_nodes, allowed_destination_nodes, allowed_source_node_prefixes, allowed_destination_node_prefixes, min_prediction, max_prediction, bins, separator, remove_chevrons, remove_spaces, support_balanced_quotes, comment_symbol, max_rows_number)
     |      Return the number of existing and non-existing edges in the provided file.
     |      
     |      Parameters
     |      ----------
     |      path: str
     |          Path to the file to read.
     |      source_column_name: Optional[str]
     |          Name of the source column.
     |      destination_column_name: Optional[str]
     |          Name of the destination column.
     |      prediction_column_name: Optional[str]
     |          Name of the prediction column.
     |      allowed_source_nodes: Optional[List[str]]
     |          List of allowed source nodes.
     |      allowed_destination_nodes: Optional[List[str]]
     |          List of allowed destination nodes.
     |      allowed_source_node_prefixes: Optional[List[str]]
     |          List of allowed source node prefixes.
     |      allowed_destination_node_prefixes: Optional[List[str]]
     |          List of allowed destination node prefixes.
     |      min_prediction: Optional[float]
     |          Minimum prediction to consider.
     |      max_prediction: Optional[float]
     |          Maximum prediction to consider.
     |      bins: Optional[int]
     |          Number of bins to use for the histogram.
     |      separator: Optional[str]
     |          Separator used in the file.
     |      remove_chevrons: Optional[bool]
     |          Whether to remove chevrons from the file.
     |      remove_spaces: Optional[bool]
     |          Whether to remove spaces from the file.
     |      support_balanced_quotes: Optional[bool]
     |          Whether to support balanced quotes in the file.
     |      comment_symbol: Optional[str]
     |          Symbol used to indicate that a line is a comment.
     |      max_rows_number: Optional[int]
     |          Maximum number of rows to read.
     |  
     |  get_preferential_attachment_from_node_ids(self, /, source_node_id, destination_node_id, normalize)
     |      Returns the unweighted preferential attachment from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      normalize: bool
     |          Whether to normalize by the square of maximum degree.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the node IDs are higher than the number of nodes in the graph.
     |  
     |  get_preferential_attachment_from_node_names(self, /, first_node_name, second_node_name, normalize)
     |      Returns the unweighted preferential attachment from the given node names.
     |      
     |      Parameters
     |      ----------
     |      first_node_name: str
     |          Node name of the first node.
     |      second_node_name: str
     |          Node name of the second node.
     |      normalize: bool
     |          Whether to normalize by the square of maximum degree.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the given node names do not exist in the current graph.
     |  
     |  get_preferential_attachment_scores(self, /, normalize, subgraph)
     |      Returns Preferential Attachment for all edges.
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided subgraph graph does not share a compatible vocabulary with the current graph instance.
     |  
     |  get_random_edge_id(self, /, random_state)
     |      Return random edge ID.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |  
     |  get_random_edge_type(self, /, random_state)
     |      Return random edge type ID.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |  
     |  get_random_inbounds_scale_free_node(self, /, random_state)
     |      Return random node ID following inbounds degree distribution of the graph.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |  
     |  get_random_node(self, /, random_state)
     |      Return random node ID.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |  
     |  get_random_node_type(self, /, random_state)
     |      Return random node type ID.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |  
     |  get_random_outbounds_scale_free_node(self, /, random_state)
     |      Return random node ID following outbounds degree distribution of the graph.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |  
     |  get_random_scale_free_edge_type(self, /, random_state)
     |      Return random scale_free edge type ID.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  get_random_scale_free_edge_weight(self, /, random_state)
     |      Return random scale free edge weight.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  get_random_spanning_tree(self, /, verbose)
     |      Returns vector of predecessors composing a RANDOM spanning tree.
     |      
     |      This is the implementaiton of [A Fast, Parallel Spanning Tree Algorithm for Symmetric Multiprocessors (SMPs)](https://smartech.gatech.edu/bitstream/handle/1853/14355/GT-CSE-06-01.pdf)
     |      by David A. Bader and Guojing Cong.
     |      
     |      Parameters
     |      ----------
     |      verbose: Optional[bool]
     |          Whether to show a loading bar or not.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the system configuration does not allow for the creation of the thread pool.
     |      ValueError
     |          If the current graph instance is directed.
     |  
     |  get_random_subgraph(self, /, number_of_nodes, random_state, verbose)
     |      Returns subgraph with given number of nodes.
     |      
     |      **This method creates a subset of the graph starting from a random node
     |      sampled using given random_state and includes all neighbouring nodes until
     |      the required number of nodes is reached**. All the edges connecting any
     |      of the selected nodes are then inserted into this graph.
     |      
     |      This is meant to execute distributed node embeddings.
     |      It may also sample singleton nodes.
     |      
     |      Parameters
     |      ----------
     |      number_of_nodes: int
     |          Number of nodes to extract.
     |      random_state: Optional[int]
     |          Random random_state to use.
     |      verbose: Optional[bool]
     |          Whether to show the loading bar.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the requested number of nodes is one or less.
     |      ValueError
     |          If the graph has less than the requested number of nodes.
     |  
     |  get_reciprocal_sqrt_degree_from_node_id(self, /, node_id)
     |      Returns the reciprocal squared root node degree up to the given node.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node.
     |  
     |  get_reciprocal_sqrt_degrees(self, /)
     |      Return vector wit
     |  
     |  get_resource_allocation_index_from_node_ids(self, /, source_node_id, destination_node_id)
     |      Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the node IDs are higher than the number of nodes in the graph.
     |  
     |  get_resource_allocation_index_from_node_names(self, /, first_node_name, second_node_name)
     |      Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node names.
     |      
     |      Parameters
     |      ----------
     |      first_node_name: str
     |          Node name of the first node.
     |      second_node_name: str
     |          Node name of the second node.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the given node names do not exist in the current graph.
     |  
     |  get_resource_allocation_index_scores(self, /, subgraph)
     |      Returns Resource Allocation index for all edges.
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided subgraph graph does not share a compatible vocabulary with the current graph instance.
     |  
     |  get_reversed_bfs_topological_sorting_from_node_id(self, /, root_node_id)
     |      Returns topological sorting reversed map using breadth-first search from the given node.
     |      
     |      Parameters
     |      ----------
     |      root_node_id: int
     |          Node ID of node to be used as root of BFS
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given root node ID does not exist in the graph
     |  
     |  get_right_normalized_laplacian_coo_matrix(self, /)
     |      Returns right normalized Laplacian coo matrix
     |  
     |  get_right_normalized_laplacian_graph(self, /)
     |      Returns right normalized Laplacian weighted graph
     |  
     |  get_root_node_ids(self, /)
     |      Returns vector of root node ids, nodes with zero inbound degree and non-zero outbound degree
     |  
     |  get_root_node_names(self, /)
     |      Returns vector of root node names, nodes with zero inbound degree and non-zero outbound degree
     |  
     |  get_selfloop_adjusted_node_degree_from_node_id(self, /, node_id)
     |      Returns number of outbound nodes for a given node ID, adjusted by removing the number of selfloops.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          ValueError - If the given node ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_selfloop_adjusted_node_degree_from_node_name(self, /, node_name)
     |      Returns number of outbound nodes for a given node name, adjusted by removing the number of selfloops.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          Integer name of the node.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          ValueError - If the given node name does not exist in the current graph the method will raise a panic.
     |  
     |  get_selfloop_nodes_rate(self, /)
     |      Returns rate of self-loops.
     |  
     |  get_shared_ancestors_jaccard_adjacency_matrix(self, /, bfs, verbose)
     |      Returns the dense shared ancestor jaccard.
     |      
     |      Parameters
     |      --------------
     |      bfs: ShortestPathsResultBFS
     |          The BFS object to use for the ancestors.
     |      verbose: bool = True
     |          Whether to show a loading bar. By default, true.
     |  
     |  get_shared_ancestors_size_adjacency_matrix(self, /, bfs, verbose)
     |      Returns the dense shared ancestor sizes.
     |      
     |      Parameters
     |      --------------
     |      bfs: ShortestPathsResultBFS
     |          The BFS object to use for the ancestors.
     |      verbose: bool = True
     |          Whether to show a loading bar. By default, true.
     |  
     |  get_shared_ancestors_size_coo_matrix(self, /, bfs)
     |      Returns shared ancestors size coo matrix.
     |      
     |      Parameters
     |      ----------
     |      bfs: ShortestPathsResultBFS
     |          The BFS object to use for the ancestors.
     |  
     |  get_shared_ancestors_size_graph(self, /, bfs)
     |      Returns shared ancestors size weighted graph.
     |      
     |      Parameters
     |      ----------
     |      bfs: ShortestPathsResultBFS
     |          The BFS object to use for the ancestors.
     |  
     |  get_shortest_path_node_ids_from_node_ids(self, /, src_node_id, dst_node_id, maximal_depth)
     |      Returns minimum path node names from given node ids.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Source node ID.
     |      dst_node_id: int
     |          Destination node ID.
     |      maximal_depth: Optional[int]
     |          The maximal depth to execute the BFS for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If any of the given node IDs do not exist in the current graph.
     |  
     |  get_shortest_path_node_ids_from_node_names(self, /, src_node_name, dst_node_name, maximal_depth)
     |      Returns minimum path node names from given node names.
     |      
     |      Parameters
     |      ----------
     |      src_node_name: str
     |          Source node name.
     |      dst_node_name: str
     |          Destination node name.
     |      maximal_depth: Optional[int]
     |          The maximal depth to execute the BFS for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If any of the given node names do not exist in the current graph.
     |  
     |  get_shortest_path_node_names_from_node_names(self, /, src_node_name, dst_node_name, maximal_depth)
     |      Returns minimum path node names from given node names.
     |      
     |      Parameters
     |      ----------
     |      src_node_name: str
     |          Source node name.
     |      dst_node_name: str
     |          Destination node name.
     |      maximal_depth: Optional[int]
     |          The maximal depth to execute the BFS for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If any of the given node names do not exist in the current graph.
     |  
     |  get_shortest_paths_matrix(self, /, verbose)
     |      Return the dense shortest paths matrix.
     |      
     |      Parameters
     |      --------------
     |      verbose: bool = True
     |          Whether to show a loading bar. By default, true.
     |  
     |  get_siamese_mini_batch(self, /, random_state, batch_size)
     |      Returns n-ple with terms used for training a siamese network.
     |      
     |      Parameters
     |      -------------
     |      random_state: int
     |          Random state to reproduce sampling
     |      batch_size: int
     |          The maximal size of the batch to generate,
     |  
     |  get_siamese_mini_batch_with_edge_types(self, /, random_state, batch_size)
     |      Returns n-ple with terms used for training a siamese network.
     |      
     |      Parameters
     |      -------------
     |      random_state: int
     |          Random state to reproduce sampling
     |      batch_size: int
     |          The maximal size of the batch to generate,
     |  
     |  get_single_label_node_type_ids(self, /, unknown_node_types_value)
     |      Returns 1D single labeled node types ids vector.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph has multilabel node types.
     |  
     |  get_singleton_edge_type_ids(self, /)
     |      Returns vector of singleton edge types IDs.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  get_singleton_edge_type_names(self, /)
     |      Returns vector of singleton edge types names.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  get_singleton_node_ids(self, /)
     |      Returns vector of singleton node IDs of the graph.
     |  
     |  get_singleton_node_names(self, /)
     |      Returns vector of singleton node names of the graph.
     |  
     |  get_singleton_node_type_ids(self, /)
     |      Returns vector of singleton node types IDs.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_singleton_node_type_names(self, /)
     |      Returns vector of singleton node types names.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_singleton_with_selfloops_node_ids(self, /)
     |      Returns vector of singleton_with_selfloops node IDs of the graph.
     |  
     |  get_singleton_with_selfloops_node_names(self, /)
     |      Returns vector of singleton_with_selfloops node names of the graph.
     |  
     |  get_sorted_unique_random_nodes(self, /, number_of_nodes_to_sample, random_state)
     |      Return random unique sorted numbers.
     |      
     |      Parameters
     |      ----------
     |      number_of_nodes_to_sample: int
     |          The number of nodes to sample.
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |  
     |  get_source_names(self, /, directed)
     |      Return vector of the non-unique source nodes names.
     |      
     |      Parameters
     |      ----------
     |      directed: bool
     |          Whether to filter out the undirected edges.
     |  
     |  get_source_node_id_from_edge_id(self, /, edge_id)
     |      Returns source node ID corresponding to given edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source node ID is to be retrieved.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given edge ID does not exist in the current graph.
     |  
     |  get_source_node_ids(self, /, directed)
     |      Return vector of the non-unique source nodes.
     |      
     |      Parameters
     |      ----------
     |      directed: bool
     |          Whether to filter out the undirected edges.
     |  
     |  get_source_node_name_from_edge_id(self, /, edge_id)
     |      Returns source node name corresponding to given edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source node name is to be retrieved.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  get_sparse_edge_weighting_methods(self, /)
     |      Return list of the supported sparse edge weighting methods
     |  
     |  get_sparse_subgraphs(self, /, number_of_nodes_to_sample, random_state, root_node, node_sampling_method, edge_weighting_methods, add_selfloops_where_missing, unique)
     |      Return subsampled nodes according to the given method and parameters.
     |      
     |      Parameters
     |      --------------------
     |      number_of_nodes_to_sample: int
     |          The number of nodes to sample.
     |      random_state: int
     |          The random state to reproduce the sampling.
     |      root_node: Optional[int]
     |          The (optional) root node to use to sample. In not provided, a random one is sampled.
     |      node_sampling_method: str
     |          The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.
     |      edge_weighting_methods: List[str]
     |          The edge weighting methods to use to compute the adjacency matrix.
     |      add_selfloops_where_missing: Optional[bool]
     |          Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.
     |      unique: Optional[bool] = True
     |          Whether to reduce the sampled nodes to a unique set.
     |      
     |      Raises
     |      --------------------
     |      ValueError
     |          If the given node sampling method is not supported.
     |      ValueError
     |          If any of the given subgraph edge weighting method is not supported.
     |      ValueError
     |          If the list of requested edge weighting methods is empty.
     |      ValueError
     |          If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.
     |      
     |      Returns
     |      --------------------
     |      Tuple with the sampled nodes and the computed kernels.
     |  
     |  get_sparse_undirected_laplacian_subgraphs(self, /, number_of_nodes_to_sample, random_state, root_node, node_sampling_method)
     |      Return subsampled nodes and edges using laplacian assuming undirected graph with selfloops.
     |      
     |      Parameters
     |      --------------------
     |      number_of_nodes_to_sample: int
     |          The number of nodes to sample.
     |      random_state: int
     |          The random state to reproduce the sampling.
     |      root_node: Optional[int]
     |          The (optional) root node to use to sample. In not provided, a random one is sampled.
     |      node_sampling_method: str
     |          The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.
     |      
     |      Raises
     |      --------------------
     |      TODO: Update
     |      
     |      Returns
     |      --------------------
     |      Tuple with the sampled nodes and the computed kernels.
     |  
     |  get_star_edge_names(self, /, central_node, removed_existing_edges, star_points_nodes_set, star_points_node_types_set)
     |      Return vector of tuple of Node names that form the edges of the required star.
     |      
     |      Parameters
     |      ----------
     |      central_node: str
     |          Name of the node to use as center of the star.
     |      removed_existing_edges: Optional[bool]
     |          Whether to filter out the existing edges. By default, true.
     |      star_points_nodes_set: Optional[Set[str]]
     |          Optional set of nodes to use to create the set of star points.
     |      star_points_node_types_set: Optional[Set[str]]
     |          Optional set of node types to create the set of star points.
     |  
     |  get_star_edges(self, /, central_node, removed_existing_edges, star_points_nodes_set, star_points_node_types_set)
     |      Return vector of tuple of Node IDs that form the edges of the required star.
     |      
     |      Parameters
     |      ----------
     |      central_node: str
     |          Name of the node to use as center of the star.
     |      removed_existing_edges: Optional[bool]
     |          Whether to filter out the existing edges. By default, true.
     |      star_points_nodes_set: Optional[Set[str]]
     |          Optional set of nodes to use to create the set of star points.
     |      star_points_node_types_set: Optional[Set[str]]
     |          Optional set of node types to create the set of star points.
     |  
     |  get_stars(self, /, minimum_number_of_nodes_per_star)
     |      Return vector of Stars in the current graph instance.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_stress_centrality(self, /, verbose)
     |      Returns vector of stress centrality for all nodes.
     |      
     |      Parameters
     |      ----------
     |      verbose: Optional[bool]
     |          Whether to show a loading bar while computing the stress centrality. By default, true.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is a multigraph.
     |  
     |  get_subgraphs(self, /, number_of_nodes_to_sample, random_state, root_node, node_sampling_method, edge_weighting_methods, add_selfloops_where_missing, unique)
     |      Return subsampled nodes according to the given method and parameters.
     |      
     |      Parameters
     |      ----------
     |      number_of_nodes_to_sample: int
     |          the number of nodes to sample.
     |      random_state: int
     |          The random state to reproduce the sampling.
     |      root_node: Optional[int]
     |          The (optional) root node to use to sample. In not provided, a random one is sampled.
     |      node_sampling_method: str
     |          The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.
     |      edge_weighting_methods: List[str]
     |          The edge weighting methods to use to compute the adjacency matrix.
     |      add_selfloops_where_missing: Optional[bool]
     |          Whether to add selfloops where they are missing. This parameter only applies to laplacian edge weighting method. By default, true.
     |      unique: Optional[bool] = True
     |          Whether to reduce the sampled nodes to a unique set.
     |      
     |      Raises
     |      ------
     |      ValueError
     |          If the given node sampling method is not supported.
     |      ValueError
     |          If any of the given subgraph edge weighting method is not supported.
     |      ValueError
     |          If the list of requested edge weighting methods is empty.
     |      ValueError
     |          If the `add_selfloops_where_missing` parameter is provided, but the edge weighting method is not laplacian.
     |      
     |      Returns
     |      -------
     |      Tuple with the sampled nodes and the computed kernels.
     |  
     |  get_subsampled_nodes(self, /, number_of_nodes_to_sample, random_state, node_sampling_method, root_node, unique)
     |      Return subsampled nodes according to the given method and parameters.
     |      
     |      Parameters
     |      ----------
     |      number_of_nodes_to_sample: int
     |          The number of nodes to sample.
     |      random_state: int
     |          The random state to reproduce the sampling.
     |      root_node: Optional[int]
     |          The (optional) root node to use to sample. In not provided, a random one is sampled.
     |      node_sampling_method: str
     |          The method to use to sample the nodes. Can either be random nodes, breath first search-based or uniform random walk-based.
     |      unique: Optional[bool]
     |          Whether to make the sampled nodes unique.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node sampling method is not supported.
     |  
     |  get_symmetric_normalized_laplacian_coo_matrix(self, /)
     |      Returns symmetric normalized Laplacian coo matrix
     |  
     |  get_symmetric_normalized_laplacian_graph(self, /)
     |      Returns symmetric normalized Laplacian weighted graph
     |  
     |  get_tendrils(self, /, minimum_number_of_nodes_per_tendril, compute_tendril_nodes)
     |      Return vector of Tendrils in the current graph instance.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_top_k_central_node_ids(self, /, k)
     |      Return vector with unweighted top k central node Ids.
     |      
     |      If the k passed is bigger than the number of nodes this method will return
     |      all the nodes in the graph.
     |      
     |      Parameters
     |      ----------
     |      k: int
     |          Number of central nodes to extract.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given value k is zero.
     |      ValueError
     |          If the graph has no nodes.
     |  
     |  get_top_k_central_node_names(self, /, k)
     |      Return vector with top k central node names.
     |      
     |      Parameters
     |      ----------
     |      k: int
     |          Number of central nodes to extract.
     |  
     |  get_total_edge_weights(self, /)
     |      Return total edge weights, if graph has weights.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain edge weights.
     |  
     |  get_total_memory_used(self, /)
     |      Returns how many bytes are currently used to store the given graph
     |  
     |  get_transitive_closure(self, /, iterations, verbose)
     |      Returns graph to the i-th transitivity closure iteration.
     |      
     |      Parameters
     |      ----------
     |      iterations: Optional[int]
     |          The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar while building the graph.
     |  
     |  get_transitivity(self, /, verbose)
     |      Returns transitivity of the graph without taking into account weights.
     |      
     |      Parameters
     |      ----------
     |      verbose: Optional[bool]
     |          Whether to show a loading bar.
     |  
     |  get_trap_node_ids(self, /)
     |      Returns vector of trap nodes present in the current graph
     |  
     |  get_trap_nodes_rate(self, /)
     |      Returns the traps rate of the graph.
     |      
     |      THIS IS EXPERIMENTAL AND MUST BE PROVEN!
     |  
     |  get_unchecked_adamic_adar_index_from_node_ids(self, /, source_node_id, destination_node_id)
     |      Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      
     |      
     |      Safety
     |      ------
     |      If either of the provided one and two node IDs are higher than the
     |       number of nodes in the graph.
     |  
     |  get_unchecked_all_edge_metrics_from_node_ids_tuple(self, /, source_node_id, destination_node_id, normalize)
     |      Returns all the implemented edge metrics for the two given node IDs.
     |      
     |      Specifically, the returned values are:
     |      * Adamic Adar
     |      * Jaccard coefficient
     |      * Resource allocation index
     |      * Preferential attachment
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      normalize: bool
     |          Whether to normalize within 0 to 1.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node IDs do not exist in the graph this method will panic.
     |  
     |  get_unchecked_breadth_first_search_distances_parallel_from_node_id(self, /, src_node_id, maximal_depth)
     |      Returns shortest path result for the BFS from given source node ID.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Root of the tree of minimum paths.
     |      maximal_depth: Optional[int]
     |          The maximal depth to run the BFS for.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node ID does not exist in the graph the method will panic.
     |  
     |  get_unchecked_breadth_first_search_distances_parallel_from_node_ids(self, /, src_node_ids, maximal_depth)
     |      Returns shortest path result for the BFS from given source node IDs, treating the set of source nodes as an hyper-node.
     |      
     |      Parameters
     |      ----------
     |      src_node_ids: List[int]
     |          Roots of the tree of minimum paths.
     |      maximal_depth: Optional[int]
     |          The maximal depth to run the BFS for.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |       The provided list of node ids must be non-empty, or the method will panic.
     |  
     |  get_unchecked_breadth_first_search_distances_sequential_from_node_id(self, /, src_node_id)
     |      Returns shortest path result for the BFS from given source node ID.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Root of the tree of minimum paths.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node ID does not exist in the graph the method will panic.
     |      
     |       TODO! Explore chains accelerations!
     |  
     |  get_unchecked_breadth_first_search_from_node_id(self, /, src_node_id, dst_node_id, compute_predecessors, maximal_depth)
     |      Returns vector of minimum paths distances and vector of nodes predecessors, if requested.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Root of the tree of minimum paths.
     |      maybe_dst_node_id: Optional[int]
     |          Optional target destination. If provided, breadth first search will stop upon reaching this node.
     |      compute_predecessors: Optional[bool]
     |          Whether to compute the vector of predecessors.
     |      maximal_depth: Optional[int]
     |          The maximal depth to execute the DFS for.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |  
     |  get_unchecked_breadth_first_search_from_node_ids(self, /, src_node_ids, dst_node_id, compute_predecessors, maximal_depth)
     |      Returns vector of minimum paths distances and vector of nodes predecessors, if requested, treating the set of source nodes as an hyper-node.
     |      
     |      Parameters
     |      ----------
     |      src_node_ids: List[int]
     |          Root of the tree of minimum paths.
     |      maybe_dst_node_id: Optional[int]
     |          Optional target destination. If provided, the breadth first search will stop upon reaching this node.
     |      compute_predecessors: Optional[bool]
     |          Whether to compute the vector of predecessors.
     |      maximal_depth: Optional[int]
     |          The maximal depth to execute the DFS for.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |  
     |  get_unchecked_breadth_first_search_predecessors_parallel_from_node_id(self, /, src_node_id)
     |      Returns shortest path result for the BFS from given source node ID.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Root of the tree of minimum paths.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node ID does not exist in the graph the method will panic.
     |  
     |  get_unchecked_closeness_centrality_from_node_id(self, /, node_id)
     |      Return closeness centrality of the requested node.
     |      
     |      If the given node ID does not exist in the current graph the method
     |      will panic.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID whose closeness centrality is to be computed.
     |      verbose: Optional[bool]
     |          Whether to show an indicative progress bar.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exist in the graph the method will panic.
     |  
     |  get_unchecked_comulative_node_degree_from_node_id(self, /, node_id)
     |      Returns the comulative node degree up to the given node.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_destination_node_id_from_edge_id(self, /, edge_id)
     |      Returns the destination of given edge id without making any boundary check.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose destination is to be retrieved.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge ID does not exist in the current graph the method will cause an out of bounds.
     |  
     |  get_unchecked_destination_node_name_from_edge_id(self, /, edge_id)
     |      Returns destination node name corresponding to given edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose destination node name is to be retrieved.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_dijkstra_from_node_id(self, /, src_node_id, maybe_dst_node_id, maybe_dst_node_ids, compute_predecessors, maximal_depth, use_edge_weights_as_probabilities)
     |      Returns vector of minimum paths distances and vector of nodes predecessors, if requested.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Root of the tree of minimum paths.
     |      maybe_dst_node_id: Optional[int]
     |          Optional target destination. If provided, Dijkstra will stop upon reaching this node.
     |      maybe_dst_node_ids: Optional[List[int]]
     |          Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.
     |      compute_predecessors: bool
     |          Whether to compute the vector of predecessors.
     |      maximal_depth: Optional[int]
     |          The maximal number of iterations to execute Dijkstra for.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |  
     |  get_unchecked_dijkstra_from_node_ids(self, /, src_node_ids, maybe_dst_node_id, maybe_dst_node_ids, compute_predecessors, maximal_depth, use_edge_weights_as_probabilities)
     |      Returns vector of minimum paths distances and vector of nodes predecessors, if requested, from the given root nodes (treated as an hyper-node).
     |      
     |      Parameters
     |      ----------
     |      src_node_id: List[int]
     |          Root of the tree of minimum paths.
     |      maybe_dst_node_id: Optional[int]
     |          Optional target destination. If provided, Dijkstra will stop upon reaching this node.
     |      maybe_dst_node_ids: Optional[List[int]]
     |          Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.
     |      compute_predecessors: bool
     |          Whether to compute the vector of predecessors.
     |      maximal_depth: Optional[int]
     |          The maximal number of iterations to execute Dijkstra for.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |  
     |  get_unchecked_eccentricity_and_most_distant_node_id_from_node_id(self, /, node_id)
     |      Returns unweighted eccentricity of the given node.
     |      
     |      This method will panic if the given node ID does not exists in the graph.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Node for which to compute the eccentricity.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |  
     |  get_unchecked_edge_count_from_edge_type_id(self, /, edge_type)
     |      Return number of edges of the given edge type without checks.
     |      
     |      Parameters
     |      ----------
     |      edge_type: Optional[int]
     |          The edge type to retrieve count of.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge type ID does not exist in the graph the method will panic.
     |  
     |  get_unchecked_edge_id_from_node_ids(self, /, src, dst)
     |      Returns edge ID corresponding to given source and destination node IDs.
     |      
     |      The method will panic if the given source and destination node IDs do
     |      not correspond to an edge in this graph instance.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          The source node ID.
     |      dst: int
     |          The destination node ID.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs do not exist in the graph the method will panic.
     |  
     |  get_unchecked_edge_id_from_node_ids_and_edge_type_id(self, /, src, dst, edge_type)
     |      Return edge ID without any checks for given tuple of nodes and edge type.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          Source node of the edge.
     |      dst: int
     |          Destination node of the edge.
     |      edge_type: Optional[int]
     |          Edge Type of the edge.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node IDs or edge type does not exists in the graph this method will panic.
     |  
     |  get_unchecked_edge_type_id_counts_hashmap_from_node_ids(self, /, node_ids)
     |      Returns edge type IDs counts hashmap for the provided node IDs.
     |      
     |      Parameters
     |      ----------
     |      node_ids: List[int]
     |          The node IDs to consider for this count.
     |      
     |      
     |      Safety
     |      ------
     |      Must have edge types and the provided node IDs must exit in the graph
     |       or the result will be undefined and most likely will lead to panic.
     |  
     |  get_unchecked_edge_type_id_from_edge_id(self, /, edge_id)
     |      Returns edge type of given edge.
     |      
     |      This method will panic if the given edge ID is greater than
     |      the number of edges in the graph.
     |      Furthermore, if the graph does NOT have edge types, it will NOT
     |      return neither an error or a panic.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          edge whose edge type is to be returned.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_edge_type_id_from_edge_type_name(self, /, edge_type_name)
     |      Return edge type ID corresponding to the given edge type name.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: str
     |          The edge type name whose edge type ID is to be returned.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge type name does not exists in the considered graph the method will panic.
     |  
     |  get_unchecked_edge_type_name_from_edge_id(self, /, edge_id)
     |      Returns edge type name of given edge.
     |      
     |      This method will panic if the given edge ID is greater than
     |      the number of edges in the graph.
     |      Furthermore, if the graph does NOT have edge types, it will NOT
     |      return neither an error or a panic.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          edge whose edge type is to be returned.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_edge_type_name_from_edge_type_id(self, /, edge_type_id)
     |      Return edge type ID corresponding to the given edge type name
     |      raising panic if edge type ID does not exists in current graph.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: Optional[int]
     |          The edge type naIDme whose edge type name is to be returned.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge type ID does not exist in the graph the method will panic.
     |  
     |  get_unchecked_edge_weight_from_edge_id(self, /, edge_id)
     |      Returns option with the weight of the given edge id.
     |      
     |      This method will raise a panic if the given edge ID is higher than
     |      the number of edges in the graph. Additionally, it will simply
     |      return None if there are no graph weights.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge whose edge weight is to be returned.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge ID does not exists in the graph this method will panic.
     |  
     |  get_unchecked_edge_weight_from_node_ids(self, /, src, dst)
     |      Returns option with the weight of the given node ids.
     |      
     |      This method will raise a panic if the given node IDs are higher than
     |      the number of nodes in the graph.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          The source node ID.
     |      dst: int
     |          The destination node ID.
     |      
     |      
     |      Safety
     |      ------
     |      If either of the two given node IDs does not exists in the graph.
     |  
     |  get_unchecked_harmonic_centrality_from_node_id(self, /, node_id)
     |      Return harmonic centrality of the requested node.
     |      
     |      If the given node ID does not exist in the current graph the method
     |      will panic.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID whose harmonic centrality is to be computed.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exist in the graph the method will panic.
     |  
     |  get_unchecked_jaccard_coefficient_from_node_ids(self, /, source_node_id, destination_node_id)
     |      Returns the Jaccard index for the two given nodes from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      
     |      
     |      Safety
     |      ------
     |      If either of the provided one and two node IDs are higher than the
     |       number of nodes in the graph.
     |  
     |  get_unchecked_k_shortest_path_node_ids_from_node_ids(self, /, src_node_id, dst_node_id, k)
     |      Return vector of the k minimum paths node IDs between given source node and destination node ID.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Source node ID.
     |      dst_node_id: int
     |          Destination node ID.
     |      k: int
     |          Number of paths to find.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |  
     |  get_unchecked_maximum_node_degree(self, /)
     |      Return the maximum node degree.
     |      
     |      Safety
     |      ------
     |      The method will return an undefined value (0) when the graph
     |      does not contain nodes. In those cases the value is not properly
     |      defined.
     |  
     |  get_unchecked_maximum_preferential_attachment(self, /)
     |      Returns the maximum unweighted preferential attachment score.
     |      
     |      Safety
     |      ------
     |      If the graph does not contain nodes, the return value will be undefined.
     |  
     |  get_unchecked_minimum_node_degree(self, /)
     |      Return the minimum node degree.
     |      
     |      Safety
     |      ------
     |      The method will return an undefined value (0) when the graph
     |      does not contain nodes. In those cases the value is not properly
     |      defined.
     |  
     |  get_unchecked_minimum_preferential_attachment(self, /)
     |      Returns the minumum unweighted preferential attachment score.
     |      
     |      Safety
     |      ------
     |      If the graph does not contain nodes, the return value will be undefined.
     |  
     |  get_unchecked_minmax_edge_ids_from_node_ids(self, /, src, dst)
     |      Return range of outbound edges IDs for all the edges bewteen the given
     |      source and destination nodes.
     |      This operation is meaningfull only in a multigraph.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          Source node.
     |      dst: int
     |          Destination node.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node type IDs do not exist in the graph this method will panic.
     |  
     |  get_unchecked_minmax_edge_ids_from_source_node_id(self, /, src)
     |      Return range of outbound edges IDs which have as source the given Node.
     |      
     |      The method will panic if the given source node ID is higher than
     |      the number of nodes in the graph.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          Node for which we need to compute the cumulative_node_degrees range.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_most_central_node_id(self, /)
     |      Returns maximum node degree of the graph.
     |      
     |      Safety
     |      ------
     |      This method fails with a panic if the graph does not have any node.
     |  
     |  get_unchecked_neighbours_intersection_size_from_node_ids(self, /, source_node_id, destination_node_id)
     |      Returns the Neighbours intersection size for the two given nodes from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      
     |      
     |      Safety
     |      ------
     |      If either of the provided one and two node IDs are higher than the
     |       number of nodes in the graph.
     |  
     |  get_unchecked_node_count_from_node_type_id(self, /, node_type)
     |      Return number of nodes of the given node type without checks.
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Safety
     |      ------
     |      If the provided value is not within the graph's vocabulary
     |       the method will panic.
     |  
     |  get_unchecked_node_degree_from_node_id(self, /, node_id)
     |      Returns the number of outbound neighbours of given node.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_node_id_from_node_name(self, /, node_name)
     |      Returns node id from given node name raising a panic if used unproperly.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          The node name whose node ID is to be returned.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node name does not exists in the considered graph the method will panic.
     |  
     |  get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(self, /, edge_id)
     |      Return the src, dst, edge type and weight of a given edge ID.
     |      
     |      This method will raise a panic when an improper configuration is used.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source, destination, edge type and weight are to be retrieved.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_node_ids_and_edge_type_id_from_edge_id(self, /, edge_id)
     |      Return the src, dst, edge type of a given edge ID.
     |      
     |      This method will raise a panic when an improper configuration is used.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source, destination and edge type are to be retrieved.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_node_ids_from_edge_id(self, /, edge_id)
     |      Returns node IDs corresponding to given edge ID.
     |      
     |      The method will panic if the given edge ID does not exists in the
     |      current graph instance.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source and destination node IDs are to e retrieved.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_node_name_from_node_id(self, /, node_id)
     |      Returns result with the node name.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID whose name is to be returned.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_node_names_from_edge_id(self, /, edge_id)
     |      Returns node names corresponding to given edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source and destination node IDs are to e retrieved.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_node_type_id_counts_hashmap_from_node_ids(self, /, node_ids)
     |      Returns node type IDs counts hashmap for the provided node IDs.
     |      
     |      Parameters
     |      ----------
     |      node_ids: List[int]
     |          The node IDs to consider for this count.
     |      
     |      
     |      Safety
     |      ------
     |      Must have node types and the provided node IDs must exit in the graph
     |       or the result will be undefined and most likely will lead to panic.
     |  
     |  get_unchecked_node_type_ids_from_node_id(self, /, node_id)
     |      Returns option with vector of node types of given node.
     |      
     |      This method will panic if the given node ID is greater than
     |      the number of nodes in the graph.
     |      Furthermore, if the graph does NOT have node types, it will NOT
     |      return neither an error or a panic.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          node whose node type is to be returned.
     |      
     |      
     |      Safety
     |      ------
     |      Even though the method will return an option when the node types are
     |       not available for the current graph, the behaviour is undefined.
     |  
     |  get_unchecked_node_type_names_from_node_id(self, /, node_id)
     |      Returns result of option with the node type of the given node id.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID whose node types are to be returned.
     |      
     |      
     |      Safety
     |      ------
     |      This method will return an iterator of None values when the graph
     |       does not contain node types.
     |  
     |  get_unchecked_node_type_names_from_node_type_ids(self, /, node_type_ids)
     |      Return node type name of given node type.
     |      
     |      Parameters
     |      ----------
     |      node_type_ids: List[int]
     |          Id of the node type.
     |      
     |      
     |      Safety
     |      ------
     |      The method will panic if the graph does not contain node types.
     |  
     |  get_unchecked_number_of_edges_from_edge_type_id(self, /, edge_type_id)
     |      Return number of edges with the provided edge type ID.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: int
     |          The edge type to return the number of edges of.
     |      
     |      
     |      Safety
     |      ------
     |      The method may panic if an invalid edge type (one not present in the graph)
     |       is provided. If the graph does not have edge types, zero will be returned.
     |  
     |  get_unchecked_number_of_nodes_from_node_type_id(self, /, node_type_id)
     |      Return number of nodes with the provided node type ID.
     |      
     |      Parameters
     |      ----------
     |      node_type_id: int
     |          The node type to return the number of nodes of.
     |      
     |      
     |      Safety
     |      ------
     |      The method may panic if an invalid node type (one not present in the graph)
     |       is provided. If the graph does not have node types, zero will be returned.
     |  
     |  get_unchecked_number_of_selfloops_from_node_id(self, /, node_id)
     |      Returns number of self-loops associated to the provided node ID.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID for which to retrieve the number of self-loops.
     |      
     |      
     |      Safety
     |      ------
     |      This method may panic if the provided node ID is outside
     |       the number of nodes in the graph.
     |  
     |  get_unchecked_ontology_from_node_id(self, /, node_id)
     |      Return node ontology for the provided node id, if available.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node id to query for.
     |  
     |  get_unchecked_ontology_from_node_name(self, /, node_name)
     |      Return node ontology for the provided node name, if available.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          The node name to query for.
     |  
     |  get_unchecked_preferential_attachment_from_node_ids(self, /, source_node_id, destination_node_id, normalize)
     |      Returns the unweighted preferential attachment from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      normalize: bool
     |          Whether to normalize within 0 to 1.
     |      
     |      
     |      Safety
     |      ------
     |      If either of the provided one and two node IDs are higher than the
     |       number of nodes in the graph.
     |  
     |  get_unchecked_random_scale_free_edge_type(self, /, random_state)
     |      Return random scale_free edge type ID.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |      
     |      
     |      Safety
     |      ------
     |      * If the graph does not have edge types, the method will always return None.
     |  
     |  get_unchecked_random_scale_free_edge_weight(self, /, random_state)
     |      Return random scale free edge weight.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |      
     |      
     |      Safety
     |      ------
     |      * If the graph does not have edge types, the method will always return None.
     |  
     |  get_unchecked_reciprocal_sqrt_degree_from_node_id(self, /, node_id)
     |      Returns the reciprocal squared root node degree up to the given node.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_reciprocal_sqrt_degrees_from_node_ids(self, /, node_ids)
     |      Return vector with reciprocal squared root degree of the provided nodes.
     |      
     |      Parameters
     |      ----------
     |      node_ids: List[int]
     |          The vector of node IDs whose reciprocal squared root degree is to be retrieved.
     |      
     |      
     |      Safety
     |      ------
     |      This method makes the assumption that the provided node IDs exist in the graph, that is
     |       they are not higher than the number of nodes in the graph.
     |  
     |  get_unchecked_resource_allocation_index_from_node_ids(self, /, source_node_id, destination_node_id)
     |      Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      
     |      
     |      Safety
     |      ------
     |      If either of the provided one and two node IDs are higher than the
     |       number of nodes in the graph.
     |  
     |  get_unchecked_selfloop_excluded_node_degree_from_node_id(self, /, node_id)
     |      Returns number of outbound nodes for a given node ID, adjusted by removing the number of selfloops.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_shortest_path_node_ids_from_node_ids(self, /, src_node_id, dst_node_id, maximal_depth)
     |      Returns minimum path node IDs and distance from given node ids.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Source node ID.
     |      dst_node_id: int
     |          Destination node ID.
     |      maximal_depth: Optional[int]
     |          The maximal depth to execute the BFS for.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node is a selfloop.
     |      ValueError
     |          If there is no path between the two given nodes.
     |  
     |  get_unchecked_shortest_path_node_names_from_node_ids(self, /, src_node_id, dst_node_id, maximal_depth)
     |      Returns minimum path node names from given node ids.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Source node ID.
     |      dst_node_id: int
     |          Destination node ID.
     |      maximal_depth: Optional[int]
     |          The maximal depth to execute the BFS for.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |  
     |  get_unchecked_source_node_id_from_edge_id(self, /, edge_id)
     |      Returns the source of given edge id without making any boundary check.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source is to be retrieved.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge ID does not exist in the current graph the method will cause an out of bounds.
     |  
     |  get_unchecked_source_node_name_from_edge_id(self, /, edge_id)
     |      Returns source node name corresponding to given edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          The edge ID whose source node name is to be retrieved.
     |      
     |      
     |      Safety
     |      ------
     |      If the given edge ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_structural_distance_from_node_ids(self, /, source_node_id, destination_node_id, maximal_hop_distance)
     |      Returns the structural distance from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      maximal_hop_distance: int
     |          Maximal hop distance to consider.
     |      
     |      
     |      Safety
     |      ------
     |      If either of the provided one and two node IDs are higher than the
     |       number of nodes in the graph.
     |  
     |  get_unchecked_unique_source_node_id(self, /, source_id)
     |      Returns edge ID corresponding to given source and destination node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_id: int
     |          The source node ID.
     |      
     |      
     |      Safety
     |      ------
     |      If the given source node ID does not exist in the current graph the method will panic.
     |  
     |  get_unchecked_weighted_closeness_centrality_from_node_id(self, /, node_id, use_edge_weights_as_probabilities)
     |      Return closeness centrality of the requested node.
     |      
     |      If the given node ID does not exist in the current graph the method
     |      will panic.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID whose closeness centrality is to be computed.
     |      use_edge_weights_as_probabilities: bool
     |          Whether to treat the edge weights as probabilities.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exist in the graph the method will panic.
     |  
     |  get_unchecked_weighted_eccentricity_from_node_id(self, /, node_id, use_edge_weights_as_probabilities)
     |      Returns weighted eccentricity of the given node.
     |      
     |      This method will panic if the given node ID does not exists in the graph.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Node for which to compute the eccentricity.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |  
     |  get_unchecked_weighted_harmonic_centrality_from_node_id(self, /, node_id, use_edge_weights_as_probabilities)
     |      Return harmonic centrality of the requested node.
     |      
     |      If the given node ID does not exist in the current graph the method
     |      will panic.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID whose harmonic centrality is to be computed.
     |      use_edge_weights_as_probabilities: bool
     |          Whether to treat the edge weights as probabilities.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exist in the graph the method will panic.
     |  
     |  get_unchecked_weighted_maximum_preferential_attachment(self, /)
     |      Returns the maximum weighted preferential attachment score.
     |      
     |      Safety
     |      ------
     |      If the graph does not contain nodes, the return value will be undefined.
     |  
     |  get_unchecked_weighted_minimum_preferential_attachment(self, /)
     |      Returns the minumum weighted preferential attachment score.
     |      
     |      Safety
     |      ------
     |      If the graph does not contain nodes, the return value will be undefined.
     |  
     |  get_unchecked_weighted_node_degree_from_node_id(self, /, node_id)
     |      Returns the weighted sum of outbound neighbours of given node.
     |      
     |      The method will panic if the given node id is higher than the number of
     |      nodes in the graph.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exist in the current graph the method will raise a panic.
     |  
     |  get_unchecked_weighted_preferential_attachment_from_node_ids(self, /, source_node_id, destination_node_id, normalize)
     |      Returns the weighted preferential attachment from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      normalize: bool
     |          Whether to normalize within 0 to 1.
     |      
     |      
     |      Safety
     |      ------
     |      If either of the provided one and two node IDs are higher than the
     |       number of nodes in the graph.
     |  
     |  get_unchecked_weighted_resource_allocation_index_from_node_ids(self, /, source_node_id, destination_node_id)
     |      Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      
     |      
     |      Safety
     |      ------
     |      If either of the provided one and two node IDs are higher than the
     |       number of nodes in the graph.
     |  
     |  get_unchecked_weighted_shortest_path_node_ids_from_node_ids(self, /, src_node_id, dst_node_id, use_edge_weights_as_probabilities, maximal_depth)
     |      Returns minimum path node IDs and distance from given node ids.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Source node ID.
     |      dst_node_id: int
     |          Destination node ID.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      maximal_depth: Optional[int]
     |          The maximal number of iterations to execute Dijkstra for.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |  
     |  get_unchecked_weighted_shortest_path_node_names_from_node_ids(self, /, src_node_id, dst_node_id, use_edge_weights_as_probabilities, maximal_depth)
     |      Returns minimum path node names from given node ids.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Source node ID.
     |      dst_node_id: int
     |          Destination node ID.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      maximal_depth: Optional[int]
     |          The maximal number of iterations to execute Dijkstra for.
     |      
     |      
     |      Safety
     |      ------
     |      If any of the given node IDs does not exist in the graph the method will panic.
     |  
     |  get_undirected_edge_weights(self, /)
     |      Return the undirected weights of the graph edges, filtering out edges where src > dst.
     |  
     |  get_undirected_louvain_community_detection(self, /, recursion_minimum_improvement, first_phase_minimum_improvement, patience, random_state)
     |      Returns vector of vectors of communities for each layer of hierarchy minimizing undirected modularity.
     |      
     |      Parameters
     |      ----------
     |      recursion_minimum_improvement: Optional[float]
     |          The minimum improvement to warrant another resursion round. By default, zero.
     |      first_phase_minimum_improvement: Optional[float]
     |          The minimum improvement to warrant another first phase iteration. By default, `0.00001` (not zero because of numerical instability).
     |      patience: Optional[int]
     |          How many iterations of the first phase to wait for before stopping. By default, `5`.
     |      random_state: Optional[int]
     |          The random state to use to reproduce this modularity computation. By default, 42.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is not directed.
     |      ValueError
     |          If the `recursion_minimum_improvement` has an invalid value, i.e. NaN or infinity.
     |      ValueError
     |          If the `first_phase_minimum_improvement` has an invalid value, i.e. NaN or infinity.
     |  
     |  get_undirected_modularity_from_node_community_memberships(self, /, node_community_memberships)
     |      Returns the undirected modularity of the graph from the given memberships.
     |      
     |      Parameters
     |      ----------
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the number of provided memberships does not match the number of nodes of the graph.
     |  
     |  get_uniform_random_walk_random_nodes(self, /, node, random_state, walk_length, unique)
     |      Returns unique nodes sampled from uniform random walk.
     |      
     |      Parameters
     |      ----------
     |      node: int
     |          Node from where to start the random walks.
     |      random_state: int
     |          the random_state to use for extracting the nodes and edges.
     |      walk_length: int
     |          Length of the random walk.
     |      unique: Optional[bool]
     |          Whether to make the sampled nodes unique.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node does not exist in the current slack.
     |  
     |  get_unique_edge_type_ids(self, /)
     |      Return the unique edge type IDs of the graph edges.
     |  
     |  get_unique_edge_type_names(self, /)
     |      Return the edge types names
     |  
     |  get_unique_node_type_ids(self, /)
     |      Return the unique node type IDs of the graph nodes.
     |  
     |  get_unique_node_type_names(self, /)
     |      Return the unique node types names.
     |  
     |  get_unknown_edge_types_mask(self, /)
     |      Returns boolean mask of unknown edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  get_unknown_edge_types_rate(self, /)
     |      Returns rate of unknown edge types over total edges number.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_unknown_node_types_mask(self, /)
     |      Returns boolean mask of unknown node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  get_unknown_node_types_rate(self, /)
     |      Returns rate of unknown node types over total nodes number.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  get_upper_triangular_edge_ids_with_known_edge_types(self, /)
     |      Returns upper triangular edge IDs of the edges with known edge types
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_upper_triangular_edge_ids_with_unknown_edge_types(self, /)
     |      Returns upper triangular edge IDs of the edges with unknown edge types
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  get_upper_triangular_edge_type_ids(self, /)
     |      Return the upper triangular edge types of the edges
     |  
     |  get_upper_triangular_edge_type_names(self, /)
     |      Return the upper triangular edge type names of the edges
     |  
     |  get_upper_triangular_known_edge_type_ids(self, /)
     |      Return the upper triangular known edge types of the edges, dropping unknown ones
     |  
     |  get_upper_triangular_known_edge_types_mask(self, /)
     |      Returns a boolean vector with known edge types from the upper triangular matrix.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |      ValueError
     |          If the graph is not undirected.
     |  
     |  get_vertex_cover(self, /, approach, sequential, insert_only_source, random_seed)
     |      Returns 2-approximated verted cover bitvec using greedy algorithm.
     |      
     |      Parameters
     |      ----------
     |      approach: Optional[&str]
     |          The approach name to be used. By default, the edge list order is used.
     |      sequential: Optional[bool]
     |          Whether to proceed sequantially or concurrently. By default, sequential.
     |      insert_only_source: Optional[bool]
     |          Whether to insert only the source node or both source and destination.
     |      random_seed: Optional[int]
     |          The random seed to be used for the stocastic approaches.
     |  
     |  get_weighted_all_shortest_paths(self, /, iterations, use_edge_weights_as_probabilities, verbose)
     |      Returns graph with weighted shortest paths computed up to the given depth.
     |      
     |      The returned graph will have no selfloops.
     |      
     |      Parameters
     |      ----------
     |      iterations: Optional[int]
     |          The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar while building the graph.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have weights.
     |      ValueError
     |          If the graph contains negative weights.
     |      ValueError
     |          If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.
     |  
     |  get_weighted_approximated_betweenness_centrality_from_node_id(self, /, node_id, ant, use_edge_weights_as_probabilities, maximum_samples_number, random_state)
     |      Returns the weighted approximated betweenness centrality of the given node id.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node ID for which to compute the approximated betweenness centrality.
     |      constant: Optional[float]
     |          The constant factor to use to regulate the sampling. By default 2.0. It must be greater or equal than 2.0.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to consider the edge weights as probabilities.
     |      maximum_samples_number: Optional[float]
     |          The maximum number of samples to sample. By default `number_of_nodes / 20`, as suggested in the paper.
     |      random_state: Optional[int]
     |          The random state to use for the sampling. By default 42.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided node ID does not exist in the current graph instance.
     |  
     |  get_weighted_approximated_betweenness_centrality_from_node_name(self, /, node_name, ant, use_edge_weights_as_probabilities, maximum_samples_number, random_state)
     |      Returns the weighted approximated betweenness centrality of the given node id.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          The node name for which to compute the approximated betweenness centrality.
     |      constant: Optional[float]
     |          The constant factor to use to regulate the sampling. By default 2.0. It must be greater or equal than 2.0.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to consider the edge weights as probabilities.
     |      maximum_samples_number: Optional[float]
     |          The maximum number of samples to sample. By default `number_of_nodes / 20`, as suggested in the paper.
     |      random_state: Optional[int]
     |          The random state to use for the sampling. By default 42.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided node name does not exist in the current graph instance.
     |  
     |  get_weighted_closeness_centrality(self, /, use_edge_weights_as_probabilities, verbose)
     |      Return closeness centrality for all nodes.
     |      
     |      Parameters
     |      ----------
     |      use_edge_weights_as_probabilities: bool
     |          Whether to treat the edge weights as probabilities.
     |      verbose: Optional[bool]
     |          Whether to show an indicative progress bar.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have weights.
     |      ValueError
     |          If the graph contains negative weights.
     |      ValueError
     |          If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.
     |  
     |  get_weighted_degree_centrality(self, /)
     |      Returns vector of weighted degree centrality for all nodes
     |  
     |  get_weighted_eccentricity_from_node_id(self, /, node_id, use_edge_weights_as_probabilities)
     |      Returns weighted eccentricity of the given node ID.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Node for which to compute the eccentricity.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node ID does not exist in the graph.
     |      ValueError
     |          If weights are requested to be treated as probabilities but are not between 0 and 1.
     |      ValueError
     |          If the graph contains negative weights.
     |  
     |  get_weighted_eccentricity_from_node_name(self, /, node_name, use_edge_weights_as_probabilities)
     |      Returns weighted eccentricity of the given node name.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          Node for which to compute the eccentricity.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node name does not exist in the graph.
     |      ValueError
     |          If weights are requested to be treated as probabilities but are not between 0 and 1.
     |      ValueError
     |          If the graph contains negative weights.
     |  
     |  get_weighted_eigenvector_centrality(self, /, maximum_iterations_number, tollerance)
     |      Returns vector with unweighted eigenvector centrality.
     |      
     |      Parameters
     |      ----------
     |      maximum_iterations_number: Optional[int]
     |          The maximum number of iterations to consider.
     |      tollerance: Optional[float]
     |          The maximum error tollerance for convergence.
     |  
     |  get_weighted_harmonic_centrality(self, /, use_edge_weights_as_probabilities, verbose)
     |      Return harmonic centrality for all nodes.
     |      
     |      Parameters
     |      ----------
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      verbose: Optional[bool]
     |          Whether to show an indicative progress bar.
     |  
     |  get_weighted_maximum_node_degree(self, /)
     |      Return the maximum weighted node degree
     |  
     |  get_weighted_minimum_node_degree(self, /)
     |      Return the minimum weighted node degree
     |  
     |  get_weighted_node_degree_from_node_id(self, /, node_id)
     |      Returns the weighted sum of outbound neighbours of given node ID.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node.
     |  
     |  get_weighted_node_degrees(self, /)
     |      Returns the weighted degree of every node in the graph
     |  
     |  get_weighted_node_degrees_mean(self, /)
     |      Returns weighted mean node degree of the graph.
     |  
     |  get_weighted_node_degrees_median(self, /)
     |      Returns weighted median node degree of the graph
     |  
     |  get_weighted_node_indegrees(self, /)
     |      Return the weighted indegree (total weighted inbound edge weights) for each node.
     |  
     |  get_weighted_preferential_attachment_from_node_ids(self, /, source_node_id, destination_node_id, normalize)
     |      Returns the weighted preferential attachment from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      normalize: bool
     |          Whether to normalize by the square of maximum degree.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the node IDs are higher than the number of nodes in the graph.
     |  
     |  get_weighted_preferential_attachment_from_node_names(self, /, first_node_name, second_node_name, normalize)
     |      Returns the weighted preferential attachment from the given node names.
     |      
     |      Parameters
     |      ----------
     |      first_node_name: str
     |          Node name of the first node.
     |      second_node_name: str
     |          Node name of the second node.
     |      normalize: bool
     |          Whether to normalize by the square of maximum degree.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the given node names do not exist in the current graph.
     |  
     |  get_weighted_resource_allocation_index_from_node_ids(self, /, source_node_id, destination_node_id)
     |      Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          Node ID of the first node.
     |      destination_node_id: int
     |          Node ID of the second node.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the node IDs are higher than the number of nodes in the graph.
     |  
     |  get_weighted_resource_allocation_index_from_node_names(self, /, first_node_name, second_node_name)
     |      Returns the weighted Resource Allocation Index for the given pair of nodes from the given node names.
     |      
     |      Parameters
     |      ----------
     |      first_node_name: str
     |          Node name of the first node.
     |      second_node_name: str
     |          Node name of the second node.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If either of the given node names do not exist in the current graph.
     |  
     |  get_weighted_shortest_path_node_ids_from_node_ids(self, /, src_node_id, dst_node_id, use_edge_weights_as_probabilities, maximal_depth)
     |      Returns minimum path node names from given node ids.
     |      
     |      Parameters
     |      ----------
     |      src_node_id: int
     |          Source node ID.
     |      dst_node_id: int
     |          Destination node ID.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      maximal_depth: Optional[int]
     |          The maximal number of iterations to execute Dijkstra for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If any of the given node IDs do not exist in the current graph.
     |  
     |  get_weighted_shortest_path_node_ids_from_node_names(self, /, src_node_name, dst_node_name, use_edge_weights_as_probabilities, maximal_depth)
     |      Returns minimum path node names from given node names.
     |      
     |      Parameters
     |      ----------
     |      src_node_name: str
     |          Source node name.
     |      dst_node_name: str
     |          Destination node name.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      maximal_depth: Optional[int]
     |          The maximal number of iterations to execute Dijkstra for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If any of the given node names do not exist in the current graph.
     |  
     |  get_weighted_shortest_path_node_names_from_node_names(self, /, src_node_name, dst_node_name, use_edge_weights_as_probabilities, maximal_depth)
     |      Returns minimum path node names from given node names.
     |      
     |      Parameters
     |      ----------
     |      src_node_name: str
     |          Source node name.
     |      dst_node_name: str
     |          Destination node name.
     |      use_edge_weights_as_probabilities: Optional[bool]
     |          Whether to treat the edge weights as probabilities.
     |      maximal_depth: Optional[int]
     |          The maximal number of iterations to execute Dijkstra for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If any of the given node names do not exist in the current graph.
     |  
     |  get_weighted_top_k_central_node_ids(self, /, k)
     |      Return vector with weighted top k central node Ids.
     |      
     |      If the k passed is bigger than the number of nodes this method will return
     |      all the nodes in the graph.
     |      
     |      Parameters
     |      ----------
     |      k: int
     |          Number of central nodes to extract.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the current graph instance does not contain edge weights.
     |      ValueError
     |          If the given value k is zero.
     |  
     |  has_compatible_edge_types_vocabularies(self, /, other)
     |      Returns whether the graphs share the same edge types or absence thereof.
     |      
     |      Parameters
     |      ----------
     |      other: Graph
     |          The other graph.
     |  
     |  has_compatible_node_types_vocabularies(self, /, other)
     |      Returns whether the graphs share the same node types or absence thereof.
     |      
     |      Parameters
     |      ----------
     |      other: Graph
     |          The other graph.
     |  
     |  has_compatible_node_vocabularies(self, /, other)
     |      Returns whether the graphs share the same nodes.
     |      
     |      Parameters
     |      ----------
     |      other: Graph
     |          The other graph.
     |  
     |  has_constant_edge_weights(self, /)
     |      Returns whether the graph has constant weights.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain edge weights.
     |  
     |  has_default_graph_name(self, /)
     |      Return if graph has name that is not the default one.
     |      
     |      TODO: use a default for the default graph name
     |  
     |  has_disconnected_nodes(self, /)
     |      Returns boolean representing if nodes which are nor singletons nor
     |      singletons with selfloops.
     |  
     |  has_edge_from_node_id_and_edge_type_id(self, /, src, edge_type_id)
     |      Returns whether a given node ID has at least an edge of the given edge type.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          The source node of which to check connected edges' type.
     |      edge_type_id: Optional[int]
     |          The edge type to look for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given source node does not exist in the current graph.
     |      ValueError
     |          If the given edge type does not exist in the current graph.
     |  
     |  has_edge_from_node_ids(self, /, src, dst)
     |      Returns whether edge passing between given node ids exists.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          Source node id.
     |      dst: int
     |          Destination node id.
     |  
     |  has_edge_from_node_ids_and_edge_type_id(self, /, src, dst, edge_type)
     |      Returns whether edge with the given type passing between given nodes exists.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          The source node of the edge.
     |      dst: int
     |          The destination node of the edge.
     |      edge_type: Optional[int]
     |          The (optional) edge type.
     |  
     |  has_edge_from_node_names(self, /, src_name, dst_name)
     |      Returns whether if edge passing between given nodes exists.
     |      
     |      Parameters
     |      ----------
     |      src_name: str
     |          The source node name of the edge.
     |      dst_name: str
     |          The destination node name of the edge.
     |  
     |  has_edge_from_node_names_and_edge_type_name(self, /, src_name, dst_name, edge_type_name)
     |      Returns whether if edge with type passing between given nodes exists.
     |      
     |      Parameters
     |      ----------
     |      src_name: str
     |          The source node name of the edge.
     |      dst_name: str
     |          The destination node name of the edge.
     |      edge_type_name: Optional[&str]
     |          The (optional) edge type name.
     |  
     |  has_edge_type_id(self, /, edge_type_id)
     |      Returns whether the graph has the given edge type id.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: int
     |          id of the edge.
     |  
     |  has_edge_type_name(self, /, edge_type_name)
     |      Returns whether the graph has the given edge type name.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: str
     |          Name of the edge.
     |  
     |  has_edge_types(self, /)
     |      Returns boolean representing whether graph has edge types.
     |  
     |  has_edge_types_oddities(self, /)
     |      Return whether the graph has any known edge type-related graph oddities.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  has_edge_weights(self, /)
     |      Returns boolean representing whether graph has weights.
     |  
     |  has_edge_weights_representing_probabilities(self, /)
     |      Returns whether graph has weights that can represent probabilities
     |  
     |  has_edges(self, /)
     |      Return if the graph has any edges.
     |  
     |  has_exclusively_homogeneous_edge_types(self, /)
     |      Returns whether the edges have exclusively homogeneous edge type.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  has_exclusively_homogeneous_node_types(self, /)
     |      Returns whether the nodes have exclusively homogenous node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  has_exclusively_singleton_edge_types(self, /)
     |      Returns whether the graph has exclusively singleton edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  has_exclusively_singleton_node_types(self, /)
     |      Returns whether the graph has exclusively singleton node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  has_homogeneous_edge_types(self, /)
     |      Returns whether the edges have an homogenous edge type.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  has_homogeneous_node_ontologies(self, /)
     |      Returns whether the nodes have an homogenous node ontology
     |  
     |  has_homogeneous_node_types(self, /)
     |      Returns whether the nodes have an homogenous node type.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  has_isomorphic_node_types_from_node_ids(self, /, node_ids)
     |      Returns whether the set of provided node IDs have isomorphic node types.
     |      
     |      Parameters
     |      ----------
     |      node_ids: List[int]
     |          Node IDs to check for.
     |  
     |  has_isomorphic_nodes(self, /, minimum_node_degree)
     |      Returns whether the current graph has topological synonims.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_degree: Optional[int]
     |          Minimum node degree for the topological synonims.
     |  
     |  has_known_edge_types(self, /)
     |      Returns whether there are known edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  has_known_node_types(self, /)
     |      Returns whether there are known node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  has_multilabel_node_types(self, /)
     |      Returns boolean representing if graph has multilabel node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  has_negative_edge_weights(self, /)
     |      Returns boolean representing whether graph has negative weights.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain weights.
     |  
     |  has_node_name(self, /, node_name)
     |      Returns whether the graph has the given node name.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          Name of the node.
     |  
     |  has_node_name_and_node_type_name(self, /, node_name, node_type_name)
     |      Returns whether the given node name and node type name exist in current graph.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          The node name.
     |      node_type_name: Optional[List[str]]
     |          The node types name.
     |  
     |  has_node_oddities(self, /)
     |      Return whether the graph has any known node-related graph oddities
     |  
     |  has_node_ontologies(self, /)
     |      Return whether at least a node has a known ontology
     |  
     |  has_node_type_id(self, /, node_type_id)
     |      Returns whether the graph has the given node type id.
     |      
     |      Parameters
     |      ----------
     |      node_type_id: int
     |          id of the node.
     |  
     |  has_node_type_name(self, /, node_type_name)
     |      Returns whether the graph has the given node type name.
     |      
     |      Parameters
     |      ----------
     |      node_type_name: str
     |          Name of the node.
     |  
     |  has_node_types(self, /)
     |      Returns boolean representing if graph has node types
     |  
     |  has_node_types_oddities(self, /)
     |      Return whether the graph has any known node type-related graph oddities.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  has_nodes(self, /)
     |      Return if the graph has any nodes.
     |  
     |  has_nodes_sorted_by_decreasing_outbound_node_degree(self, /)
     |      Returns whether the node IDs are sorted by decreasing outbound node degree.
     |  
     |  has_nodes_sorted_by_increasing_outbound_node_degree(self, /)
     |      Returns whether the node IDs are sorted by increasing outbound node degree.
     |  
     |  has_nodes_sorted_by_lexicographic_order(self, /)
     |      Returns whether the node IDs are sorted by decreasing outbound node degree.
     |  
     |  has_reciprocal_sqrt_degrees_tradeoff_enabled(self, /)
     |      Returns whether the reciprocal_sqrt_degrees time-memory tradeoff is enabled
     |  
     |  has_same_adjacency_matrix(self, /, other)
     |      Return true if the graphs share the same adjacency matrix.
     |      
     |      Parameters
     |      ----------
     |      other: Graph
     |          The other graph.
     |  
     |  has_selfloop_from_node_id(self, /, node_id)
     |      Returns whether the given node ID has a selfloop.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Source node id.
     |  
     |  has_selfloops(self, /)
     |      Returns boolean representing if graph has self-loops.
     |  
     |  has_singleton_edge_types(self, /)
     |      Returns whether there is at least singleton edge type, that is a edge type that only appears once.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  has_singleton_node_types(self, /)
     |      Returns whether there is at least singleton node type, that is a node type that only appears once.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  has_singleton_nodes(self, /)
     |      Returns boolean representing if graph has singletons.
     |  
     |  has_singleton_nodes_with_selfloops(self, /)
     |      Returns boolean representing if graph has singletons
     |  
     |  has_sources_tradeoff_enabled(self, /)
     |      Returns whether the sources time-memory tradeoff is enabled
     |  
     |  has_trap_nodes(self, /)
     |      Return whether the graph has trap nodes.
     |  
     |  has_trap_nodes_with_selfloops(self, /)
     |      Return whether the graph has trap nodes with self-loops.
     |  
     |  has_unchecked_edge_from_node_id_and_edge_type_id(self, /, src, edge_type_id)
     |      Returns whether a given node ID has at least an edge of the given edge type.
     |      
     |      Parameters
     |      ----------
     |      src: int
     |          The source node of which to check connected edges' type.
     |      edge_type_id: Optional[int]
     |          The edge type to look for.
     |      
     |      
     |      Safety
     |      ------
     |      When
     |  
     |  has_unchecked_isomorphic_node_types_from_node_ids(self, /, node_ids)
     |      Returns whether the set of provided node IDs have isomorphic node types.
     |      
     |      Parameters
     |      ----------
     |      node_ids: List[int]
     |          Node IDs to check for.
     |  
     |  has_unknown_edge_types(self, /)
     |      Returns whether there are unknown edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  has_unknown_node_ontologies(self, /)
     |      Return whether at least a node has an unknown ontology
     |  
     |  has_unknown_node_types(self, /)
     |      Returns whether there are unknown node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  has_weighted_singleton_nodes(self, /)
     |      Returns whether a graph has one or more weighted singleton nodes.
     |      
     |      A weighted singleton node is a node whose weighted node degree is 0.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain edge weights.
     |  
     |  hash(self, /)
     |      Returns a 64-bit hash of the graph.
     |  
     |  is_compatible(self, /, other)
     |      Return true if the graphs are compatible.
     |      
     |      Parameters
     |      ----------
     |      other: Graph
     |          The other graph.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If a graph is directed and the other is undirected.
     |      ValueError
     |          If one of the two graphs has edge weights and the other does not.
     |      ValueError
     |          If one of the two graphs has node types and the other does not.
     |      ValueError
     |          If one of the two graphs has edge types and the other does not.
     |  
     |  is_connected(self, /, verbose)
     |      Returns whether the graph is connected.
     |      
     |      Parameters
     |      ----------
     |      verbose: Optional[bool]
     |          Whether to show the loading bar while computing the connected components, if necessary.
     |  
     |  is_connected_from_node_id(self, /, node_id)
     |      Returns boolean representing if given node is not a singleton nor a singleton with selfloop.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node to be checked for.
     |      
     |      
     |      Raises
     |      -------
     |  
     |  is_directed(self, /)
     |      Returns boolean representing if graph is directed.
     |  
     |  is_directed_acyclic(self, /)
     |      Returns whether graph is a directed acyclic graph.
     |  
     |  is_multigraph(self, /)
     |      Return if there are multiple edges between two node
     |  
     |  is_singleton_from_node_id(self, /, node_id)
     |      Returns boolean representing if given node is a singleton.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node to be checked for.
     |  
     |  is_singleton_from_node_name(self, /, node_name)
     |      Returns boolean representing if given node is a singleton.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          The node name to be checked for.
     |  
     |  is_singleton_with_selfloops_from_node_id(self, /, node_id)
     |      Returns boolean representing if given node is a singleton with self-loops.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node to be checked for.
     |  
     |  is_trap_node_from_node_id(self, /, node_id)
     |      Returns boolean representing if given node is a trap.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node, if this is bigger that the number of nodes it will panic.
     |  
     |  is_trap_node_with_selfloops_from_node_id(self, /, node_id)
     |      Returns boolean representing if given node is a trap with selfloops.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node, if this is bigger that the number of nodes it will panic.
     |  
     |  is_unchecked_connected_from_node_id(self, /, node_id)
     |      Returns boolean representing if given node is not a singleton nor a singleton with selfloop.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node to be checked for.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exists in the graph this method will panic.
     |  
     |  is_unchecked_disconnected_node_from_node_id(self, /, node_id)
     |      Returns boolean representing if given node is a singleton or a singleton with selfloop.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node to be checked for.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exists in the graph this method will panic.
     |  
     |  is_unchecked_singleton_from_node_id(self, /, node_id)
     |      Returns boolean representing if given node is a singleton.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node to be checked for.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exists in the graph this method will panic.
     |  
     |  is_unchecked_singleton_from_node_name(self, /, node_name)
     |      Returns boolean representing if given node is a singleton.
     |      
     |      Nota that this method will raise a panic if caled with unproper
     |      parametrization.
     |      
     |      Parameters
     |      ----------
     |      node_name: str
     |          The node name to be checked for.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node name does not exist in the graph this method will panic.
     |  
     |  is_unchecked_singleton_with_selfloops_from_node_id(self, /, node_id)
     |      Returns boolean representing if given node is a singleton with self-loops.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node to be checked for.
     |  
     |  is_unchecked_trap_node_from_node_id(self, /, node_id)
     |      Returns boolean representing if given node is a trap.
     |      
     |      If the provided node_id is higher than the number of nodes in the graph,
     |      the method will panic.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node, if this is bigger that the number of nodes it will panic.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exists in the graph this method will panic.
     |  
     |  is_unchecked_trap_node_with_selfloops_from_node_id(self, /, node_id)
     |      Returns boolean representing if given node is a trap.
     |      
     |      If the provided node_id is higher than the number of nodes in the graph,
     |      the method will panic.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          Integer ID of the node, if this is bigger that the number of nodes it will panic.
     |      
     |      
     |      Safety
     |      ------
     |      If the given node ID does not exists in the graph this method will panic.
     |  
     |  multiply_edge_weights(self, /, denominator)
     |      Multiply edge weights.
     |      
     |      Note that the modification does not happen inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge weights.
     |  
     |  multiply_edge_weights_inplace(self, /, denominator)
     |      Multiply edge weights in place.
     |      
     |      Note that the modification happens inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge weights.
     |  
     |  must_be_connected(self, /)
     |      Raises an error if the graph is not connected.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is not connected.
     |  
     |  must_be_directed_acyclic(self, /)
     |      Raises an error if the graph is not a directed acyclic.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is directed.
     |  
     |  must_be_multigraph(self, /)
     |      Raises an error if the graph does not have edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is not a multigraph.
     |  
     |  must_be_undirected(self, /)
     |      Raises an error if the graph is not undirected.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is directed.
     |  
     |  must_contain_identity_matrix(self, /)
     |      Raises an error if the graph does not include the identity matrix.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is a multigraph.
     |  
     |  must_have_edges(self, /)
     |      Raises an error if the graph has a maximal weighted
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edges.
     |  
     |  must_have_node_ontologies(self, /)
     |      Raises an error if the graph's nodes do not have detectable ontologies.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain nodes with detectable ontologies.
     |  
     |  must_have_nodes(self, /)
     |      Raises an error if the graph does not have any node.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have nodes.
     |  
     |  must_not_be_multigraph(self, /)
     |      Raises an error if the graph does not have edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is a multigraph.
     |  
     |  must_not_contain_unknown_edge_types(self, /)
     |      Raises an error if the graph contains unknown edge types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain edge types.
     |      ValueError
     |          If the graph contains unknown edge types.
     |  
     |  must_not_contain_unknown_node_types(self, /)
     |      Raises an error if the graph contains unknown node types.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not contain node types.
     |      ValueError
     |          If the graph contains unknown node types.
     |  
     |  must_not_contain_weighted_singleton_nodes(self, /)
     |      Raises an error if the graph contains zero weighted degree.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edges.
     |  
     |  must_not_have_trap_nodes(self, /)
     |      Raises an error if the graph contains trap nodes.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph contains trap nodes.
     |  
     |  must_share_node_vocabulary(self, /, other)
     |      Raises an error if the provided graph does not a node vocabulary compatible with the current graph instance.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided graph does not share a compatible node vocabulary with the current instance.
     |  
     |  node2vec(self, /, batch_size, walk_length, window_size, *, iterations, return_weight, explore_weight, change_edge_type_weight, change_node_type_weight, dense_node_mapping, max_neighbours, random_state)
     |      Return training batches for Node2Vec models.
     |      
     |      The batch is composed of a tuple as the following:
     |      
     |      - (Contexts indices, central nodes indices): the tuple of nodes
     |      
     |      This does not provide any output value as the model uses NCE loss
     |      and basically the central nodes that are fed as inputs work as the
     |      outputs value.
     |      
     |      Parameters
     |      ---------------------
     |      batch_size: int
     |          Number of walks to include within this batch.
     |          In some pathological cases, this might leed to an empty batch.
     |          These cases include graphs with particularly high number of traps.
     |          Consider using the method graph.report() to verify if this might
     |          apply to your use case.
     |      walk_length: int
     |          Maximal length of the random walk.
     |          On graphs without traps, all walks have this length.
     |      window_size: int
     |          Size of the window for local contexts.
     |      iterations: int = 1
     |          Number of iterations for each node.
     |      return_weight: float = 1.0
     |          Weight on the probability of returning to node coming from
     |          Having this higher tends the walks to be
     |          more like a Breadth-First Search.
     |          Having this very high  (> 2) makes search very local.
     |          Equal to the inverse of p in the Node2Vec paper.
     |      explore_weight: float = 1.0
     |          Weight on the probability of visiting a neighbor node
     |          to the one we're coming from in the random walk
     |          Having this higher tends the walks to be
     |          more like a Depth-First Search.
     |          Having this very high makes search more outward.
     |          Having this very low makes search very local.
     |          Equal to the inverse of q in the Node2Vec paper.
     |      change_node_type_weight: float = 1.0
     |          Weight on the probability of visiting a neighbor node of a
     |          different type than the previous node. This only applies to
     |          colored graphs, otherwise it has no impact.
     |      change_edge_type_weight: float = 1.0
     |          Weight on the probability of visiting a neighbor edge of a
     |          different type than the previous edge. This only applies to
     |          multigraphs, otherwise it has no impact.
     |      dense_node_mapping: Dict[int, int]
     |          Mapping to use for converting sparse walk space into a dense space.
     |          This object can be created using the method available from graph
     |          called `get_dense_node_mapping` that returns a mapping from
     |          the non trap nodes (those from where a walk could start) and
     |          maps these nodes into a dense range of values.
     |      max_neighbours: Optional[int] = 100
     |          Maximum number of randomly sampled neighbours to consider.
     |          If this parameter is used, the walks becomes probabilistic in nature
     |          and becomes an approximation of an exact walk.
     |      random_state: int
     |          random_state to use to reproduce the walks.
     |      
     |      Returns
     |      ----------------------------
     |      Tuple with vector of integer with contexts and words.
     |  
     |  normalize_edge_weights(self, /)
     |      Normalize edge weights.
     |      
     |      Note that the modification does not happen inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge weights.
     |  
     |  normalize_edge_weights_inplace(self, /)
     |      Normalize edge weights in place.
     |      
     |      Note that the modification happens inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge weights.
     |  
     |  overlap_textual_report(self, /, other, verbose)
     |      Return rendered textual report about the graph overlaps.
     |      
     |      Parameters
     |      ----------
     |      other: Graph
     |          graph to create overlap report with.
     |      verbose: Optional[bool]
     |          Whether to shor the loading bars.
     |  
     |  overlaps(self, /, other)
     |      Return whether given graph has any edge overlapping with current graph.
     |      
     |      Parameters
     |      ----------
     |      other: Graph
     |          The graph to check against.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If a graph is directed and the other is undirected.
     |      ValueError
     |          If one of the two graphs has edge weights and the other does not.
     |      ValueError
     |          If one of the two graphs has node types and the other does not.
     |      ValueError
     |          If one of the two graphs has edge types and the other does not.
     |  
     |  random_holdout(self, /, train_size, random_state, include_all_edge_types, edge_types, min_number_overlaps, verbose)
     |      Returns random holdout for training ML algorithms on the graph edges.
     |      
     |      The holdouts returned are a tuple of graphs. In neither holdouts the
     |      graph connectivity is necessarily preserved. To maintain that, use
     |      the method `connected_holdout`.
     |      
     |      Parameters
     |      ----------
     |      train_size: float
     |          rate target to reserve for training
     |      random_state: Optional[int]
     |          The random_state to use for the holdout,
     |      include_all_edge_types: Optional[bool]
     |          Whether to include all the edges between two nodes.
     |      edge_types: Optional[&List[Optional[&str]]]
     |          The edges to include in validation set.
     |      min_number_overlaps: Optional[int]
     |          The minimum number of overlaps to include the edge into the validation set.
     |      verbose: Optional[bool]
     |          Whether to show the loading bar.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the edge types have been specified but the graph does not have edge types.
     |      ValueError
     |          If the minimum number of overlaps have been specified but the graph is not a multigraph.
     |      ValueError
     |          If one or more of the given edge type names is not present in the graph.
     |  
     |  random_spanning_arborescence_kruskal(self, /, random_state, undesired_edge_types, verbose)
     |      Returns set of edges composing a spanning tree and connected components.
     |      
     |      The spanning tree is NOT minimal.
     |      The given random_state is NOT the root of the tree.
     |      
     |      This method, additionally, allows for undesired edge types to be
     |      used to build the spanning tree only in extremis when it is utterly
     |      necessary in order to complete the spanning arborescence.
     |      
     |      The quintuple returned contains:
     |      - Set of the edges used in order to build the spanning arborescence.
     |      - Vector of the connected component of each node.
     |      - Number of connected components.
     |      - Minimum component size.
     |      - Maximum component size.
     |      
     |      Parameters
     |      ----------
     |      random_state: Optional[int]
     |          The random_state to use for the holdout,
     |      undesired_edge_types: Optional[Set[Optional[int]]]
     |          Which edge types id to try to avoid.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar or not.
     |  
     |  random_walks(self, /, walk_length, quantity, *, return_weight, explore_weight, change_edge_type_weight, change_node_type_weight, random_state, iterations, dense_node_mapping, max_neighbours, normalize_by_degree)
     |      Return random walks done on the graph using Rust.
     |      
     |      Parameters
     |      ----------
     |      walk_length: int
     |          Maximal length of the random walk.
     |          On graphs without traps, all walks have this length.
     |      quantity: int
     |          Number of nodes to sample.
     |      return_weight: float = 1.0
     |          Weight on the probability of returning to node coming from
     |          Having this higher tends the walks to be
     |          more like a Breadth-First Search.
     |          Having this very high  (> 2) makes search very local.
     |          Equal to the inverse of p in the Node2Vec paper.
     |      explore_weight: float = 1.0
     |          Weight on the probability of visiting a neighbor node
     |          to the one we're coming from in the random walk
     |          Having this higher tends the walks to be
     |          more like a Depth-First Search.
     |          Having this very high makes search more outward.
     |          Having this very low makes search very local.
     |          Equal to the inverse of q in the Node2Vec paper.
     |      change_edge_type_weight: float = 1.0
     |          Weight on the probability of visiting a neighbor node of a
     |          different type than the previous node. This only applies to
     |          colored graphs, otherwise it has no impact.
     |      change_node_type_weight: float = 1.0
     |          Weight on the probability of visiting a neighbor edge of a
     |          different type than the previous edge. This only applies to
     |          multigraphs, otherwise it has no impact.
     |      random_state: int = 42
     |          random_state to use to reproduce the walks.
     |      iterations: int = 1
     |          Number of cycles on the graphs to execute.
     |      dense_node_mapping: Dict[int, int] = None
     |          Mapping to use for converting sparse walk space into a dense space.
     |          This object can be created using the method available from graph
     |          called `get_dense_node_mapping` that returns a mapping from
     |          the non trap nodes (those from where a walk could start) and
     |          maps these nodes into a dense range of values.
     |      max_neighbours: Optional[int] = 100
     |          Maximum number of randomly sampled neighbours to consider.
     |          If this parameter is used, the walks becomes probabilistic in nature
     |          and becomes an approximation of an exact walk.
     |      normalize_by_degree: Optional[bool] = False
     |          Whether to normalize the random walks by the node degree.
     |      
     |      Raises
     |      ------
     |      TODO: Update raises
     |      
     |      Returns
     |      -------
     |      List of list of walks containing the numeric IDs of nodes.
     |  
     |  remap_from_graph(self, /, other)
     |      Return graph remapped towards nodes of the given graph.
     |      
     |      Parameters
     |      ----------
     |      other: Graph
     |          The graph to remap towards.
     |  
     |  remap_from_node_ids(self, /, node_ids)
     |      Returns graph remapped using given node IDs ordering.
     |      
     |      Parameters
     |      ----------
     |      node_ids: List[int]
     |          The node Ids to remap the graph to.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node IDs are not unique.
     |      ValueError
     |          If the given node IDs are not available for all the values in the graph.
     |  
     |  remap_from_node_names(self, /, node_names)
     |      Returns graph remapped using given node names ordering.
     |      
     |      Parameters
     |      ----------
     |      node_names: List[&str]
     |          The node names to remap the graph to.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node names are not unique.
     |      ValueError
     |          If the given node names are not available for all the values in the graph.
     |  
     |  remap_from_node_names_map(self, /, node_names_map)
     |      Returns graph remapped using given node names mapping hashmap.
     |      
     |      Parameters
     |      ----------
     |      node_names_map: Dict[str, str]
     |          The node names to remap the graph to.
     |  
     |  remap_unchecked_from_node_ids(self, /, node_ids)
     |      Returns graph remapped using given node IDs ordering.
     |      
     |      Parameters
     |      ----------
     |      node_ids: List[int]
     |          The node Ids to remap the graph to.
     |      
     |      
     |      Safety
     |      ------
     |      This method will cause a panic if the node IDs are either:
     |       * Not unique
     |       * Not available for each of the node IDs of the graph.
     |  
     |  remove_components(self, /, node_names, node_types, edge_types, minimum_component_size, top_k_components)
     |      Return a new graph with solely the requested connected components.
     |      
     |      Parameters
     |      ----------
     |      node_names: Optional[List[str]]
     |          The name of the nodes of which components to keep.
     |      node_types: Optional[&List[Optional[&str]]]
     |          The types of the nodes of which components to keep.
     |      edge_types: Optional[&List[Optional[&str]]]
     |          The types of the edges of which components to keep.
     |      minimum_component_size: Optional[int]
     |          Optional, Minimum size of the components to keep.
     |      top_k_components: Optional[int]
     |          Optional, number of components to keep sorted by number of nodes.
     |  
     |  remove_dendritic_trees(self, /)
     |      Returns new graph without tendrils
     |  
     |  remove_disconnected_nodes(self, /)
     |      Returns new graph without disconnected nodes.
     |      
     |      A disconnected node is a node with no connection to any other node.
     |  
     |  remove_edge_type_id(self, /, edge_type_id)
     |      Remove given edge type ID from all edges.
     |      
     |      If any given edge remains with no edge type, that edge is labeled
     |      with edge type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: int
     |          The edge type ID to remove.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |      ValueError
     |          If the given edge type ID does not exists in the graph.
     |  
     |  remove_edge_type_name(self, /, edge_type_name)
     |      Remove given edge type name from all edges.
     |      
     |      If any given edge remains with no edge type, that edge is labeled
     |      with edge type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: str
     |          The edge type ID to remove.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |      ValueError
     |          If the given edge type name does not exists in the graph.
     |  
     |  remove_edge_types(self, /)
     |      Remove edge types from the graph.
     |      
     |      Note that the modification does not happen inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  remove_edge_weights(self, /)
     |      Remove edge weights from the graph.
     |      
     |      Note that the modification does not happen inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge weights.
     |  
     |  remove_homogeneous_node_types(self, /)
     |      Remove homogeneous node types from all nodes.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  remove_inplace_edge_type_ids(self, /, edge_type_ids_to_remove)
     |      Remove given edge type ID from all edges.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: int
     |          The edge type ID to remove.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph is a multigraph.
     |      ValueError
     |          If the graph does not have edge types.
     |      ValueError
     |          If the given edge type ID does not exists in the graph.
     |  
     |  remove_inplace_edge_type_name(self, /, edge_type_name)
     |      Remove given edge type name from all edges.
     |      
     |      If any given edge remains with no edge type, that edge is labeled
     |      with edge type None. Note that the modification happens inplace.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: str
     |          The edge type ID to remove.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |      ValueError
     |          If the given edge type name does not exists in the graph.
     |  
     |  remove_inplace_edge_types(self, /)
     |      Remove edge types from the graph.
     |      
     |      Note that the modification happens inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |      ValueError
     |          If the graph is a multigraph.
     |  
     |  remove_inplace_edge_weights(self, /)
     |      Remove edge weights from the graph.
     |      
     |      Note that the modification happens inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge weights.
     |  
     |  remove_inplace_homogeneous_node_types(self, /)
     |      Remove homogeneous node types from all nodes.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification happens inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  remove_inplace_isomorphic_edge_types(self, /, minimum_number_of_edges)
     |      Remove inplace isomorphic edge types.
     |      
     |      This will leave for each isomorphic edge tyoe group only an element.
     |      
     |      If any given edge remains with no edge type, that edge is labeled
     |      with edge type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Parameters
     |      ----------
     |      minimum_number_of_edges: Optional[int]
     |          Minimum number of edges to detect edge types topological synonims. By default, 5.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  remove_inplace_isomorphic_node_types(self, /)
     |      Remove inplace isomorphic node types.
     |      
     |      This will leave for each isomorphic node tyoe group only an element.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  remove_inplace_node_type_ids(self, /, node_type_ids_to_remove)
     |      Remove given node type ID from all nodes.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification happens inplace.
     |      
     |      Parameters
     |      ----------
     |      node_type_ids_to_remove: List[int]
     |          The node type ID to remove.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If the given node type ID does not exists in the graph.
     |  
     |  remove_inplace_node_type_name(self, /, node_type_name)
     |      Remove given node type name from all nodes.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification happens inplace.
     |      
     |      Parameters
     |      ----------
     |      node_type_name: str
     |          The node type names to remove.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If the given node type name does not exists in the graph.
     |  
     |  remove_inplace_node_type_names(self, /, node_type_names)
     |      Remove given node type names from all nodes.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification happens inplace.
     |      
     |      Parameters
     |      ----------
     |      node_type_names: List[&str]
     |          The node type names to remove.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If the given node type name does not exists in the graph.
     |  
     |  remove_inplace_node_types(self, /)
     |      Remove node types from the graph.
     |      
     |      Note that the modification happens inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  remove_inplace_singleton_edge_types(self, /)
     |      Remove singleton edge types from all edges.
     |      
     |      If any given edge remains with no edge type, that edge is labeled
     |      with edge type None. Note that the modification happens inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  remove_inplace_singleton_node_types(self, /)
     |      Remove singleton node types from all nodes.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification happens inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  remove_isomorphic_edge_types(self, /, minimum_number_of_edges)
     |      Remove isomorphic edge types.
     |      
     |      This will leave for each isomorphic edge tyoe group only an element.
     |      
     |      If any given edge remains with no edge type, that edge is labeled
     |      with edge type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Parameters
     |      ----------
     |      minimum_number_of_edges: Optional[int]
     |          Minimum number of edges to detect edge types topological synonims. By default, 5.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  remove_isomorphic_node_types(self, /)
     |      Remove isomorphic node types.
     |      
     |      This will leave for each isomorphic node tyoe group only an element.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  remove_isomorphic_nodes(self, /, minimum_node_degree, number_of_neighbours_for_hash)
     |      Returns new graph without isomorphic nodes, only keeping the smallest node ID of each group.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_degree: Optional[int]
     |          Minimum node degree for the topological synonims. By default equal to 5.
     |      number_of_neighbours_for_hash: Optional[int]
     |          The number of neighbours to consider for the hash. By default 10.
     |  
     |  remove_node_type_id(self, /, node_type_id)
     |      Remove given node type ID from all nodes.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Parameters
     |      ----------
     |      node_type_id: int
     |          The node type ID to remove.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If the given node type ID does not exists in the graph.
     |  
     |  remove_node_type_name(self, /, node_type_name)
     |      Remove given node type name from all nodes.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Parameters
     |      ----------
     |      node_type_name: str
     |          The node type ID to remove.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If the given node type name does not exists in the graph.
     |  
     |  remove_node_type_names(self, /, node_type_names)
     |      Remove given node type names from all nodes.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Parameters
     |      ----------
     |      node_type_names: List[&str]
     |          The node type ID to remove.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |      ValueError
     |          If the given node type name does not exists in the graph.
     |  
     |  remove_node_types(self, /)
     |      Remove node types from the graph.
     |      
     |      Note that the modification does not happen inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  remove_parallel_edges(self, /)
     |      Returns new graph without parallel edges
     |  
     |  remove_selfloops(self, /)
     |      Returns new graph without selfloops.
     |  
     |  remove_singleton_edge_types(self, /)
     |      Remove singleton edge types from all edges.
     |      
     |      If any given edge remains with no edge type, that edge is labeled
     |      with edge type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edge types.
     |  
     |  remove_singleton_node_types(self, /)
     |      Remove singleton node types from all nodes.
     |      
     |      If any given node remains with no node type, that node is labeled
     |      with node type None. Note that the modification DOES NOT happen inplace.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have node types.
     |  
     |  remove_singleton_nodes(self, /)
     |      Returns new graph without singleton nodes.
     |      
     |      A node is singleton when does not have neither incoming or outgoing edges.
     |  
     |  remove_singleton_nodes_with_selfloops(self, /)
     |      Returns new graph without singleton nodes with selfloops.
     |      
     |      A node is singleton with selfloop when does not have neither incoming or outgoing edges.
     |  
     |  remove_tendrils(self, /)
     |      Returns new graph without tendrils
     |  
     |  remove_unknown_edge_types(self, /)
     |      Returns new graph without unknown edge types and relative edges.
     |      
     |      Note that this method will remove ALL edges labeled with unknown edge
     |      type!
     |  
     |  remove_unknown_node_types(self, /)
     |      Returns new graph without unknown node types and relative nodes.
     |      
     |      Note that this method will remove ALL nodes labeled with unknown node
     |      type!
     |  
     |  replace_edge_type_id_from_edge_node_type_ids(self, /, edge_type_id, source_node_type_ids, destination_node_type_ids)
     |      Replaces given edge type id to the nodes with given source and destination node type IDs.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: int
     |          The edge type ID to replace with.
     |      source_node_type_ids: List[Optional[int]]
     |          Node types of the source nodes. When an edge has a source node with any of this node types, we may change its edge type if also the destination nodes have the correct node types.
     |      destination_node_type_ids: List[Optional[int]]
     |          Node types of the destination nodes. When an edge has a destination node with any of this node types, we may change its edge type if also the source nodes have the correct node types.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given list of node name prefixes is empty.
     |  
     |  replace_edge_type_id_from_edge_node_type_ids_inplace(self, /, edge_type_id, source_node_type_ids, destination_node_type_ids)
     |      Replaces inplace given edge type id to the nodes with given source and destination node type IDs.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: int
     |          The edge type ID to replace with.
     |      source_node_type_ids: List[Optional[int]]
     |          Node types of the source nodes. When an edge has a source node with any of this node types, we may change its edge type if also the destination nodes have the correct node types.
     |      destination_node_type_ids: List[Optional[int]]
     |          Node types of the destination nodes. When an edge has a destination node with any of this node types, we may change its edge type if also the source nodes have the correct node types.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given list of node name prefixes is empty.
     |  
     |  replace_edge_type_name_from_edge_node_type_names(self, /, edge_type_name, source_node_type_names, destination_node_type_names)
     |      Replaces given edge type name to the nodes with given source and destination node type names.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: str
     |          The edge type name to replace with.
     |      source_node_type_names: List[Optional[&str]]
     |          Node types of the source nodes. When an edge has a source node with any of this node types, we may change its edge type if also the destination nodes have the correct node types.
     |      destination_node_type_names: List[Optional[&str]]
     |          Node types of the destination nodes. When an edge has a destination node with any of this node types, we may change its edge type if also the source nodes have the correct node types.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given list of node name prefixes is empty.
     |  
     |  replace_edge_type_name_from_edge_node_type_names_inplace(self, /, edge_type_name, source_node_type_names, destination_node_type_names)
     |      Replaces inplace given edge type name to the nodes with given source and destination node type names.
     |      
     |      Parameters
     |      ----------
     |      edge_type_name: str
     |          The edge type name to replace with.
     |      source_node_type_names: List[Optional[&str]]
     |          Node types of the source nodes. When an edge has a source node with any of this node types, we may change its edge type if also the destination nodes have the correct node types.
     |      destination_node_type_names: List[Optional[&str]]
     |          Node types of the destination nodes. When an edge has a destination node with any of this node types, we may change its edge type if also the source nodes have the correct node types.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given list of node name prefixes is empty.
     |  
     |  report(self, /)
     |      Returns report relative to the graph metrics
     |      
     |      The report includes the following metrics by default:
     |      * Name of the graph
     |      * Whether the graph is directed or undirected
     |      * Number of singleton nodes
     |      * Number of nodes
     |      - If the graph has nodes, we also compute:
     |      * Minimum unweighted node degree
     |      * Maximum unweighted node degree
     |      * Unweighted node degree mean
     |      * Number of edges
     |      * Number of self-loops
     |      * Number of singleton with self-loops
     |      * Whether the graph is a multigraph
     |      * Number of parallel edges
     |      * Number of directed edges
     |      - If the graph has edges, we also compute:
     |      * Rate of self-loops
     |      * Whether the graph has weighted edges
     |      - If the graph has weights, we also compute:
     |      * Minimum weighted node degree
     |      * Maximum weighted node degree
     |      * Weighted node degree mean
     |      * The total edge weights
     |      * Whether the graph has node types
     |      - If the graph has node types, we also compute:
     |      * Whether the graph has singleton node types
     |      * The number of node types
     |      * The number of nodes with unknown node types
     |      * The number of nodes with known node types
     |      * Whether the graph has edge types
     |      - If the graph has edge types, we also compute:
     |      * Whether the graph has singleton edge types
     |      * The number of edge types
     |      * The number of edges with unknown edge types
     |      * The number of edges with known edge types
     |      
     |      On request, since it takes more time to compute it, the method also provides:
     |  
     |  sample_negative_graph(self, /, number_of_negative_samples, random_state, only_from_same_component, minimum_node_degree, maximum_node_degree, source_node_types_names, destination_node_types_names, source_edge_types_names, destination_edge_types_names, source_nodes_prefixes, destination_nodes_prefixes, graph_to_avoid, support, use_scale_free_distribution, sample_edge_types, sample_edge_weights, enforce_node_type_connection_consistency, number_of_sampling_attempts)
     |      Returns Graph with given amount of negative edges as positive edges.
     |      
     |      The graph generated may be used as a testing negatives partition to be
     |      fed into the argument "graph_to_avoid" of the link_prediction or the
     |      skipgrams algorithm.
     |      
     |      Parameters
     |      ----------
     |      number_of_negative_samples: int
     |          Number of negatives edges to include.
     |      random_state: Optional[int]
     |          random_state to use to reproduce negative edge set.
     |      only_from_same_component: Optional[bool]
     |          Whether to sample negative edges only from nodes that are from the same component.
     |      minimum_node_degree: Optional[int]
     |          The minimum node degree of either the source or destination node to be sampled. By default 0.
     |      maximum_node_degree: Optional[int]
     |          The maximum node degree of either the source or destination node to be sampled. By default, the number of nodes.
     |      destination_node_types_names: Optional[List[str]]
     |          Node type names of the nodes to be samples as destinations. If a node has any of the provided node types, it can be sampled as a destination node.
     |      source_edge_types_names: Optional[List[str]]
     |          Edge type names of the nodes to be samples as sources. If a node has any of the provided edge types, it can be sampled as a source node.
     |      destination_edge_types_names: Optional[List[str]]
     |          Edge type names of the nodes to be samples as destinations. If a node has any of the provided edge types, it can be sampled as a destination node.
     |      source_nodes_prefixes: Optional[List[str]]
     |          Prefixes of the nodes names to be samples as sources. If a node starts with any of the provided prefixes, it can be sampled as a source node.
     |      destination_nodes_prefixes: Optional[List[str]]
     |          Prefixes of the nodes names to be samples as destinations. If a node starts with any of the provided prefixes, it can be sampled as a destinations node.
     |      graph_to_avoid: Optional[&Graph]
     |          Compatible graph whose edges are not to be sampled.
     |      support: Optional[&Graph]
     |          Parent graph of this subgraph, defining the `true` topology of the graph. Node degrees and connected components are sampled from this support graph when provided. Useful when sampling negative edges for a test graph. In this latter case, the support graph should be the training graph.
     |      use_scale_free_distribution: Optional[bool]
     |          Whether to sample the nodes using scale_free distribution. By default True. Not using this may cause significant biases.
     |      sample_edge_types: Optional[bool]
     |          Whether to sample edge types, following the edge type counts distribution. By default it is true only when the current graph instance has edge types.
     |      sample_edge_weights: Optional[bool]
     |          Whether to sample edge weights, following the edge weight distribution. By default it is true only when the current graph instance has edge weights.
     |      enforce_node_type_connection_consistency: Optional[bool]
     |          Whether to enforce that the sampled negative edges have the same node types as the positive edges. By default it is true only when the current graph instance has node types.
     |      number_of_sampling_attempts: Optional[int]
     |          Number of times to attempt to sample edges before giving up.
     |  
     |  sample_positive_graph(self, /, number_of_samples, random_state, minimum_node_degree, maximum_node_degree, source_node_types_names, destination_node_types_names, source_edge_types_names, destination_edge_types_names, source_nodes_prefixes, destination_nodes_prefixes, edge_type_names, support, number_of_sampling_attempts)
     |      Returns Graph with given amount of subsampled edges.
     |      
     |      Parameters
     |      ----------
     |      number_of_samples: int
     |          Number of edges to include.
     |      random_state: Optional[int]
     |          random_state to use to reproduce negative edge set.
     |      minimum_node_degree: Optional[int]
     |          The minimum node degree of either the source or destination node to be sampled. By default 0.
     |      maximum_node_degree: Optional[int]
     |          The maximum node degree of either the source or destination node to be sampled. By default, the number of nodes.
     |      destination_node_types_names: Optional[List[str]]
     |          Node type names of the nodes to be samples as destinations. If a node has any of the provided node types, it can be sampled as a destination node.
     |      source_edge_types_names: Optional[List[str]]
     |          Edge type names of the nodes to be samples as sources. If a node has any of the provided edge types, it can be sampled as a source node.
     |      destination_edge_types_names: Optional[List[str]]
     |          Edge type names of the nodes to be samples as destinations. If a node has any of the provided edge types, it can be sampled as a destination node.
     |      source_nodes_prefixes: Optional[List[str]]
     |          Prefixes of the nodes names to be samples as sources. If a node starts with any of the provided prefixes, it can be sampled as a source node.
     |      destination_nodes_prefixes: Optional[List[str]]
     |          Prefixes of the nodes names to be samples as destinations. If a node starts with any of the provided prefixes, it can be sampled as a destinations node.
     |      edge_type_names: Optional[&List[Optional[&str]]]
     |          Edge type names of the edges to sample. Only edges with ANY of these edge types will be kept.
     |      support: Optional[&Graph]
     |          Parent graph of this subgraph, defining the `true` topology of the graph. Node degrees are sampled from this support graph when provided. Useful when sampling positive edges for a test graph. In this latter case, the support graph should be the training graph.
     |      number_of_sampling_attempts: Optional[int]
     |          Number of times to attempt to sample edges before giving up.
     |  
     |  set_all_edge_types(self, /, edge_type)
     |      Replace all edge types (if present) and set all the edge to edge_type.
     |      
     |      This DOES NOT happen inplace, but created a new instance of the graph.
     |      
     |      Parameters
     |      ----------
     |      edge_type: str
     |          The edge type to assing to all the edges.
     |  
     |  set_all_node_types(self, /, node_type)
     |      Replace all node types (if present) and set all the node to node_type.
     |      
     |      This DOES NOT happen inplace, but created a new instance of the graph.
     |      
     |      Parameters
     |      ----------
     |      node_type: str
     |          The node type to assing to all the nodes.
     |  
     |  set_inplace_all_edge_types(self, /, edge_type)
     |      Replace all edge types (if present) and set all the edge to edge_type.
     |      
     |      This happens INPLACE, that is edits the current graph instance.
     |      
     |      Parameters
     |      ----------
     |      edge_type: str
     |          The edge type to assing to all the edges.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the graph does not have edges.
     |      ValueError
     |          If the graph is a multigraph.
     |  
     |  set_inplace_all_node_types(self, /, node_type)
     |      Replace all node types (if present) and set all the node to node_type.
     |      
     |      Parameters
     |      ----------
     |      node_type: str
     |          The node type to assing to all the nodes.
     |  
     |  set_name(self, /, name)
     |      Set the name of the graph.
     |      
     |      Parameters
     |      ----------
     |      name: str
     |          Name of the graph.
     |  
     |  sort_by_bfs_topological_sorting_from_node_id(self, /, root_node_id)
     |      Returns graph with node IDs sorted using a BFS
     |      
     |      Parameters
     |      ----------
     |      root_node_id: int
     |          Node ID of node to be used as root of BFS
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given root node ID does not exist in the graph
     |  
     |  sort_by_decreasing_outbound_node_degree(self, /)
     |      Returns graph with node IDs sorted by decreasing outbound node degree
     |  
     |  sort_by_increasing_outbound_node_degree(self, /)
     |      Returns graph with node IDs sorted by increasing outbound node degree
     |  
     |  sort_by_node_lexicographic_order(self, /)
     |      Returns graph with node IDs sorted by lexicographic order
     |  
     |  spanning_arborescence_kruskal(self, /, verbose)
     |      Returns consistent spanning arborescence using Kruskal.
     |      
     |      The spanning tree is NOT minimal.
     |      
     |      The quintuple returned contains:
     |      - Set of the edges used in order to build the spanning arborescence.
     |      - Vector of the connected component of each node.
     |      - Number of connected components.
     |      - Minimum component size.
     |      - Maximum component size.
     |      
     |      Parameters
     |      ----------
     |      verbose: Optional[bool]
     |          Whether to show a loading bar or not.
     |  
     |  strongly_connected_components(self, /)
     |      Returns list of nodes of the various strongly connected components.
     |      
     |      This is an implementation of Tarjan algorithm.
     |  
     |  textual_report(self, /)
     |      Return html short textual report of the graph.
     |      
     |      TODO! Add reports on various node metrics
     |      TODO! Add reports on various edge metrics
     |      NOTE! Most of the above TODOs will require first to implement the
     |      support for the fast computation of the inbound edges in a directed
     |      graphs
     |  
     |  to_anti_diagonal(self, /)
     |      Return the graph from the anti-diagonal adjacency matrix.
     |  
     |  to_arrowhead(self, /)
     |      Return the graph from the arrowhead adjacency matrix.
     |  
     |  to_bidiagonal(self, /)
     |      Return the graph from the bidiagonal adjacency matrix.
     |  
     |  to_complementary(self, /)
     |      Return the complementary graph.
     |  
     |  to_directed(self, /)
     |      Return a new instance of the current graph as directed
     |  
     |  to_directed_inplace(self, /)
     |      Convert inplace the graph to directed.
     |  
     |  to_dot(self, /)
     |      Print the current graph in a format compatible with Graphviz dot's format
     |  
     |  to_lower_triangular(self, /)
     |      Return the directed graph from the lower triangular adjacency matrix.
     |  
     |  to_main_diagonal(self, /)
     |      Return the graph from the main diagonal adjacency matrix.
     |  
     |  to_structural_similarity_multi_graph(self, /, maximal_hop_distance, change_layer_probability, random_walk_length, iterations)
     |      Returns structural similarity multi-graph.
     |      
     |      Parameters
     |      ----------
     |      maximal_hop_distance: Optional[int]
     |          The maximal hop distance. By default, equal to the graph diameter. By default, equal to the diameter.
     |      change_layer_probability: Optional[float]
     |          Probability to change the layer during the random walk. By default 0.5.
     |      random_walk_length: Optional[int]
     |          Length of the random walk to be used to compute the approximated stationary distribution. By default, 1024.
     |      iterations: Optional[int]
     |          Number of iterations per node to compute the approximated stationary distribution. By default 1.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the provided graph does not have any edges.
     |      ValueError
     |          If the provided change layer probability is not a probability.
     |      ValueError
     |          If the provided random walk parameters are not valid.
     |  
     |  to_transposed(self, /)
     |      Return the graph from the transposed adjacency matrix.
     |  
     |  to_undirected(self, /)
     |      Return the graph with all symmetric edges
     |  
     |  to_upper_triangular(self, /)
     |      Return the directed graph from the upper triangular adjacency matrix.
     |  
     |  validate_edge_id(self, /, edge_id)
     |      Validates provided edge ID.
     |      
     |      Parameters
     |      ----------
     |      edge_id: int
     |          Edge ID to validate.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given edge ID does not exists in the graph.
     |  
     |  validate_edge_ids(self, /, edge_ids)
     |      Validates provided edge IDs.
     |      
     |      Parameters
     |      ----------
     |      edge_ids: List[int]
     |          Edge IDs to validate.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If any of the given edge ID does not exists in the graph.
     |  
     |  validate_edge_type_id(self, /, edge_type_id)
     |      Validates provided edge type ID.
     |      
     |      Parameters
     |      ----------
     |      edge_type_id: Optional[int]
     |          edge type ID to validate.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given edge type ID does not exists in the graph.
     |  
     |  validate_edge_type_ids(self, /, edge_type_ids)
     |      Validates provided edge type IDs.
     |      
     |      Parameters
     |      ----------
     |      edge_type_ids: List[Optional[int]]
     |          Vector of edge type IDs to validate.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no edge types in the graph.
     |  
     |  validate_node_id(self, /, node_id)
     |      Validates provided node ID.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          node ID to validate.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node ID does not exists in the graph.
     |  
     |  validate_node_ids(self, /, node_ids)
     |      Validates all provided node IDs.
     |      
     |      Parameters
     |      ----------
     |      node_ids: List[int]
     |          node IDs to validate.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If any of the given node ID does not exists in the graph.
     |  
     |  validate_node_type_id(self, /, node_type_id)
     |      Validates provided node type ID.
     |      
     |      Parameters
     |      ----------
     |      node_type_id: Optional[int]
     |          Node type ID to validate.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node type ID does not exists in the graph.
     |  
     |  validate_node_type_ids(self, /, node_type_ids)
     |      Validates provided node type IDs.
     |      
     |      Parameters
     |      ----------
     |      node_type_ids: List[Optional[int]]
     |          Vector of node type IDs to validate.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If there are no node types in the graph.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  (directed, node_type_path, node_type_list_separator, node_types_column_number, node_types_column, node_types_ids_column_number, node_types_ids_column, number_of_node_types, numeric_node_type_ids, minimum_node_type_id, node_type_list_header, node_type_list_support_balanced_quotes, node_type_list_rows_to_skip, node_type_list_is_correct, node_type_list_max_rows_number, node_type_list_comment_symbol, load_node_type_list_in_parallel, node_path, node_list_separator, node_list_header, node_list_support_balanced_quotes, node_list_rows_to_skip, node_list_is_correct, node_list_max_rows_number, node_list_comment_symbol, default_node_type, nodes_column_number, nodes_column, node_types_separator, node_list_node_types_column_number, node_list_node_types_column, node_ids_column, node_ids_column_number, number_of_nodes, minimum_node_id, numeric_node_ids, node_list_numeric_node_type_ids, skip_node_types_if_unavailable, load_node_list_in_parallel, edge_type_path, edge_types_column_number, edge_types_column, edge_types_ids_column_number, edge_types_ids_column, number_of_edge_types, numeric_edge_type_ids, minimum_edge_type_id, edge_type_list_separator, edge_type_list_header, edge_type_list_support_balanced_quotes, edge_type_list_rows_to_skip, edge_type_list_is_correct, edge_type_list_max_rows_number, edge_type_list_comment_symbol, load_edge_type_list_in_parallel, edge_path, edge_list_separator, edge_list_header, edge_list_support_balanced_quotes, edge_list_rows_to_skip, sources_column_number, sources_column, destinations_column_number, destinations_column, edge_list_edge_types_column_number, edge_list_edge_types_column, default_edge_type, weights_column_number, weights_column, default_weight, edge_ids_column, edge_ids_column_number, edge_list_numeric_edge_type_ids, edge_list_numeric_node_ids, skip_weights_if_unavailable, skip_edge_types_if_unavailable, edge_list_is_complete, edge_list_may_contain_duplicates, edge_list_is_sorted, edge_list_is_correct, edge_list_max_rows_number, edge_list_comment_symbol, number_of_edges, load_edge_list_in_parallel, remove_chevrons, remove_spaces, verbose, may_have_singletons, may_have_singleton_with_selfloops, name)
     |      Return graph renderized from given CSVs or TSVs-like files.
     |      from_csv
     |      Parameters
     |      ----------
     |      node_type_path: Optional[str]
     |          The path to the file with the unique node type names.
     |      node_type_list_separator: Optional[str]
     |          The separator to use for the node types file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.
     |      node_types_column_number: Optional[int]
     |          The number of the column of the node types file from where to load the node types.
     |      node_types_column: Optional[str]
     |          The name of the column of the node types file from where to load the node types.
     |      number_of_node_types: Optional[int]
     |          The number of the unique node types. This will be used in order to allocate the correct size for the data structure.
     |      numeric_node_type_ids: Optional[bool]
     |          Whether the node type names should be loaded as numeric values, i.e. casted from string to a numeric representation.
     |      minimum_node_type_id: Optional[int]
     |          The minimum node type ID to be used when using numeric node type IDs.
     |      node_type_list_header: Optional[bool]
     |          Whether the node type file has an header.
     |      node_type_list_support_balanced_quotes: Optional[bool]
     |          Whether to support balanced quotes.
     |      node_type_list_rows_to_skip: Optional[int]
     |          The number of lines to skip in the node types file`: the header is already skipped if it has been specified that the file has an header.
     |      node_type_list_is_correct: Optional[bool]
     |          Whether the node types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.
     |      node_type_list_max_rows_number: Optional[int]
     |          The maximum number of lines to be loaded from the node types file.
     |      node_type_list_comment_symbol: Optional[str]
     |          The comment symbol to skip lines in the node types file. Lines starting with this symbol will be skipped.
     |      load_node_type_list_in_parallel: Optional[bool]
     |          Whether to load the node type list in parallel. Note that when loading in parallel, the internal order of the node type IDs may result changed across different iterations. We are working to get this to be stable.
     |      node_path: Optional[str]
     |          The path to the file with the unique node names.
     |      node_list_separator: Optional[str]
     |          The separator to use for the nodes file. Note that if this is not provided, one will be automatically detected among the following`: comma, semi-column, tab and space.
     |      node_list_header: Optional[bool]
     |          Whether the nodes file has an header.
     |      node_list_support_balanced_quotes: Optional[bool]
     |          Whether to support balanced quotes.
     |      node_list_rows_to_skip: Optional[int]
     |          Number of rows to skip in the node list file.
     |      node_list_is_correct: Optional[bool]
     |          Whether the nodes file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.
     |      node_list_max_rows_number: Optional[int]
     |          The maximum number of lines to be loaded from the nodes file.
     |      node_list_comment_symbol: Optional[str]
     |          The comment symbol to skip lines in the nodes file. Lines starting with this symbol will be skipped.
     |      default_node_type: Optional[str]
     |          The node type to be used when the node type for a given node in the node file is None.
     |      nodes_column_number: Optional[int]
     |          The number of the column of the node file from where to load the node names.
     |      nodes_column: Optional[str]
     |          The name of the column of the node file from where to load the node names.
     |      node_types_separator: Optional[str]
     |          The node types separator.
     |      node_list_node_types_column_number: Optional[int]
     |          The number of the column of the node file from where to load the node types.
     |      node_list_node_types_column: Optional[str]
     |          The name of the column of the node file from where to load the node types.
     |      node_ids_column: Optional[str]
     |          The name of the column of the node file from where to load the node IDs.
     |      node_ids_column_number: Optional[int]
     |          The number of the column of the node file from where to load the node IDs
     |      number_of_nodes: Optional[int]
     |          The expected number of nodes. Note that this must be the EXACT number of nodes in the graph.
     |      minimum_node_id: Optional[int]
     |          The minimum node ID to be used, when loading the node IDs as numerical.
     |      numeric_node_ids: Optional[bool]
     |          Whether to load the numeric node IDs as numeric.
     |      node_list_numeric_node_type_ids: Optional[bool]
     |          Whether to load the node types IDs in the node file to be numeric.
     |      skip_node_types_if_unavailable: Optional[bool]
     |          Whether to skip the node types without raising an error if these are unavailable.
     |      load_node_list_in_parallel: Optional[bool]
     |          Whether to load the node list in parallel. When loading in parallel, without node IDs, the nodes may not be loaded in a deterministic order.
     |      edge_type_path: Optional[str]
     |          The path to the file with the unique edge type names.
     |      edge_types_column_number: Optional[int]
     |          The number of the column of the edge types file from where to load the edge types.
     |      edge_types_column: Optional[str]
     |          The name of the column of the edge types file from where to load the edge types.
     |      number_of_edge_types: Optional[int]
     |          The number of the unique edge types. This will be used in order to allocate the correct size for the data structure.
     |      numeric_edge_type_ids: Optional[bool]
     |          Whether the edge type names should be loaded as numeric values, i.e. casted from string to a numeric representation.
     |      minimum_edge_type_id: Optional[int]
     |          The minimum edge type ID to be used when using numeric edge type IDs.
     |      edge_type_list_separator: Optional[str]
     |          The separator to use for the edge type list. Note that, if None is provided, one will be attempted to be detected automatically between ';', ',', tab or space.
     |      edge_type_list_header: Optional[bool]
     |          Whether the edge type file has an header.
     |      edge_type_list_support_balanced_quotes: Optional[bool]
     |          Whether to support balanced quotes while reading the edge type list.
     |      edge_type_list_rows_to_skip: Optional[int]
     |          Number of rows to skip in the edge type list file.
     |      edge_type_list_is_correct: Optional[bool]
     |          Whether the edge types file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.
     |      edge_type_list_max_rows_number: Optional[int]
     |          The maximum number of lines to be loaded from the edge types file.
     |      edge_type_list_comment_symbol: Optional[str]
     |          The comment symbol to skip lines in the edge types file. Lines starting with this symbol will be skipped.
     |      load_edge_type_list_in_parallel: Optional[bool]
     |          Whether to load the edge type list in parallel. When loading in parallel, without edge type IDs, the edge types may not be loaded in a deterministic order.
     |      edge_path: Optional[str]
     |          The path to the file with the edge list.
     |      edge_list_separator: Optional[str]
     |          The separator to use for the edge list. Note that, if None is provided, one will be attempted to be detected automatically between ';', ',', tab or space.
     |      edge_list_header: Optional[bool]
     |          Whether the edges file has an header.
     |      edge_list_support_balanced_quotes: Optional[bool]
     |          Whether to support balanced quotes while reading the edge list.
     |      edge_list_rows_to_skip: Optional[int]
     |          Number of rows to skip in the edge list file.
     |      sources_column_number: Optional[int]
     |          The number of the column of the edges file from where to load the source nodes.
     |      sources_column: Optional[str]
     |          The name of the column of the edges file from where to load the source nodes.
     |      destinations_column_number: Optional[int]
     |          The number of the column of the edges file from where to load the destinaton nodes.
     |      destinations_column: Optional[str]
     |          The name of the column of the edges file from where to load the destinaton nodes.
     |      edge_list_edge_types_column_number: Optional[int]
     |          The number of the column of the edges file from where to load the edge types.
     |      edge_list_edge_types_column: Optional[str]
     |          The name of the column of the edges file from where to load the edge types.
     |      default_edge_type: Optional[str]
     |          The edge type to be used when the edge type for a given edge in the edge file is None.
     |      weights_column_number: Optional[int]
     |          The number of the column of the edges file from where to load the edge weights.
     |      weights_column: Optional[str]
     |          The name of the column of the edges file from where to load the edge weights.
     |      default_weight: Optional[float]
     |          The edge weight to be used when the edge weight for a given edge in the edge file is None.
     |      edge_ids_column: Optional[str]
     |          The name of the column of the edges file from where to load the edge IDs.
     |      edge_ids_column_number: Optional[int]
     |          The number of the column of the edges file from where to load the edge IDs.
     |      edge_list_numeric_edge_type_ids: Optional[bool]
     |          Whether to load the edge type IDs as numeric from the edge list.
     |      edge_list_numeric_node_ids: Optional[bool]
     |          Whether to load the edge node IDs as numeric from the edge list.
     |      skip_weights_if_unavailable: Optional[bool]
     |          Whether to skip the weights without raising an error if these are unavailable.
     |      skip_edge_types_if_unavailable: Optional[bool]
     |          Whether to skip the edge types without raising an error if these are unavailable.
     |      edge_list_is_complete: Optional[bool]
     |          Whether to consider the edge list as complete, i.e. the edges are presented in both directions when loading an undirected graph.
     |      edge_list_may_contain_duplicates: Optional[bool]
     |          Whether the edge list may contain duplicates. If the edge list surely DOES NOT contain duplicates, a validation step may be skipped. By default, it is assumed that the edge list may contain duplicates.
     |      edge_list_is_sorted: Optional[bool]
     |          Whether the edge list is sorted. Note that a sorted edge list has the minimal memory peak, but requires the nodes number and the edges number.
     |      edge_list_is_correct: Optional[bool]
     |          Whether the edges file can be assumed to be correct, i.e. does not have something wrong in it. If this parameter is passed as true on a malformed file, the constructor will crash.
     |      edge_list_max_rows_number: Optional[int]
     |          The maximum number of lines to be loaded from the edges file.
     |      edge_list_comment_symbol: Optional[str]
     |          The comment symbol to skip lines in the edges file. Lines starting with this symbol will be skipped.
     |      number_of_edges: Optional[int]
     |          The expected number of edges. Note that this must be the EXACT number of edges in the graph.
     |      load_edge_list_in_parallel: Optional[bool]
     |          Whether to load the edge list in parallel. Note that, if the edge IDs indices are not given, it is NOT possible to load a sorted edge list. Similarly, when loading in parallel, without edge IDs, the edges may not be loaded in a deterministic order.
     |      remove_chevrons: Optional[bool]
     |          Whether remove chevrons while reading elements.
     |      remove_spaces: Optional[bool]
     |          Whether remove spaces while reading elements.
     |      verbose: Optional[bool]
     |          Whether to show a loading bar while reading the files. Note that, if parallel loading is enabled, loading bars will not be showed because they are a synchronization bottleneck.
     |      may_have_singletons: Optional[bool]
     |          Whether the graph may be expected to have singleton nodes. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.
     |      may_have_singleton_with_selfloops: Optional[bool]
     |          Whether the graph may be expected to have singleton nodes with selfloops. If it is said that it surely DOES NOT have any, it will allow for some speedups and lower mempry peaks.
     |      directed: bool
     |          Whether to load the graph as directed or undirected.
     |      name: Optional[str]
     |          The name of the graph to be loaded.
     |  
     |  from_pd(directed, edges_df, *, nodes_df, node_name_column, node_type_column, edge_src_column, edge_dst_column, edge_weight_column, edge_type_column, name)
     |      Create a new graph from pandas dataframes.
     |      
     |      # Arguments
     |      * `directed` - Whether the graph is directed or not.
     |      * `edges_df` - The dataframe containing the edges.
     |      * `nodes_df` - The dataframe containing the nodes.
     |      * `node_name_column` - The name of the column containing the node names. Default: "name".
     |      * `node_type_column` - The name of the column containing the node types.
     |      * `edge_src_column` - The name of the column containing the source nodes. Default: "subject".
     |      * `edge_dst_column` - The name of the column containing the destination nodes. Default: "object".
     |      * `edge_weight_column` - The name of the column containing the edge weights.
     |      * `edge_type_column` - The name of the column containing the edge types.
     |      * `name` - The name of the graph. Default: "Graph".
     |      
     |      # Example
     |      
     |      ```python
     |      nodes_df = pd.DataFrame(
     |          [("a", "user"), ("b", "user"), ("c", "product")],
     |          columns=["name", "type"],
     |      )
     |      
     |      edges_df = pd.DataFrame(
     |          [("a", "b", 1.0, "knows"), ("b", "c", 2.0, "bought")],
     |          columns=["subject", "object", "weight", "predicate"],
     |      )
     |      
     |      graph = Graph::from_pd(
     |          edges_df,
     |          nodes_df,
     |          node_name_column="name",
     |          node_type_column="type",
     |          edge_src_column="subject",
     |          edge_dst_column="object",
     |          edge_weight_column="weight",
     |          edge_type_column="predicate",
     |          directed=True,
     |          name="graph",
     |      )
     |      ```
     |  
     |  generate_barbell_graph(minimum_node_id, left_clique_number_of_nodes, right_clique_number_of_nodes, chain_number_of_nodes, include_selfloops, left_clique_node_type, right_clique_node_type, chain_node_type, left_clique_edge_type, right_clique_edge_type, chain_edge_type, left_clique_weight, right_clique_weight, chain_weight, directed, name)
     |      Creates new barbell graph with given sizes and types.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_id: Optional[int]
     |          Minimum node ID to start with. May be needed when chaining graphs. By default 0.
     |      left_clique_number_of_nodes: Optional[int]
     |          Number of nodes in the left clique. By default 10.
     |      right_clique_number_of_nodes: Optional[int]
     |           Number of nodes in the right clique. By default equal to the left clique.
     |      chain_number_of_nodes: Optional[int]
     |          Number of nodes in the chain. By default 10.
     |      include_selfloops: Optional[bool]
     |          Whether to include selfloops.
     |      left_clique_node_type: Optional[&str]
     |          The node type to use for the left clique. By default 'left_clique'.
     |      right_clique_node_type: Optional[&str]
     |          The node type to use for the right clique. By default 'right_clique'.
     |      chain_node_type: Optional[&str]
     |          The node type to use for the chain. By default 'chain'.
     |      left_clique_edge_type: Optional[&str]
     |          The node type to use for the left clique. By default 'left_clique'.
     |      right_clique_edge_type: Optional[&str]
     |          The node type to use for the right clique. By default 'right_clique'.
     |      chain_edge_type: Optional[&str]
     |          The node type to use for the chain. By default 'chain'.
     |      left_clique_weight: Optional[float]
     |          The weight to use for the edges in the left clique. By default None.
     |      right_clique_weight: Optional[float]
     |          The weight to use for the edges in the right clique. By default None.
     |      chain_weight: Optional[float]
     |          The weight to use for the edges in the chain. By default None.
     |      directed: Optional[bool]
     |          Whether the graph is to built as directed. By default false.
     |      name: Optional[&str]
     |          Name of the graph. By default 'Barbell'.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the edge weights are provided only for a subset.
     |  
     |  generate_chain_graph(minimum_node_id, number_of_nodes, include_selfloops, node_type, edge_type, weight, directed, name)
     |      Creates new chain graph with given sizes and types.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_id: Optional[int]
     |          Minimum node ID to start with. May be needed when chaining graphs. By default 0.
     |      number_of_nodes: Optional[int]
     |          Number of nodes in the chain. By default 10.
     |      include_selfloops: Optional[bool]
     |          Whether to include selfloops.
     |      node_type: Optional[&str]
     |          The node type to use for the chain. By default 'chain'.
     |      edge_type: Optional[&str]
     |          The node type to use for the chain. By default 'chain'.
     |      weight: Optional[float]
     |          The weight to use for the edges in the chain. By default None.
     |      directed: Optional[bool]
     |          Whether the graph is to built as directed. By default false.
     |      name: Optional[&str]
     |          Name of the graph. By default 'Chain'.
     |  
     |  generate_circle_graph(minimum_node_id, number_of_nodes, include_selfloops, node_type, edge_type, weight, directed, name)
     |      Creates new circle graph with given sizes and types.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_id: Optional[int]
     |          Minimum node ID to start with. May be needed when circleing graphs. By default 0.
     |      number_of_nodes: Optional[int]
     |          Number of nodes in the circle. By default 10.
     |      include_selfloops: Optional[bool]
     |          Whether to include selfloops.
     |      node_type: Optional[&str]
     |          The node type to use for the circle. By default 'circle'.
     |      edge_type: Optional[&str]
     |          The node type to use for the circle. By default 'circle'.
     |      weight: Optional[float]
     |          The weight to use for the edges in the circle. By default None.
     |      directed: Optional[bool]
     |          Whether the graph is to built as directed. By default false.
     |      name: Optional[&str]
     |          Name of the graph. By default 'Circle'.
     |  
     |  generate_complete_graph(minimum_node_id, number_of_nodes, include_selfloops, node_type, edge_type, weight, directed, name)
     |      Creates new complete graph with given sizes and types.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_id: Optional[int]
     |          Minimum node ID to start with. May be needed when combining graphs. By default 0.
     |      number_of_nodes: Optional[int]
     |          Number of nodes in the chain. By default 10.
     |      include_selfloops: Optional[bool]
     |          Whether to include selfloops.
     |      node_type: Optional[&str]
     |          The node type to use. By default 'complete'.
     |      edge_type: Optional[&str]
     |          The node type to use. By default 'complete'.
     |      weight: Optional[float]
     |          The weight to use for the edges. By default None.
     |      directed: Optional[bool]
     |          Whether the graph is to built as directed. By default false.
     |      name: Optional[&str]
     |          Name of the graph. By default 'Complete'.
     |  
     |  generate_lollipop_graph(minimum_node_id, clique_number_of_nodes, chain_number_of_nodes, include_selfloops, clique_node_type, chain_node_type, clique_edge_type, chain_edge_type, clique_weight, chain_weight, directed, name)
     |      Creates new lollipop graph with given sizes and types.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_id: Optional[int]
     |          Minimum node ID to start with. May be needed when chaining graphs. By default 0.
     |      clique_number_of_nodes: Optional[int]
     |          Number of nodes in the left clique. By default 10.
     |      chain_number_of_nodes: Optional[int]
     |          Number of nodes in the chain. By default 10.
     |      include_selfloops: Optional[bool]
     |          Whether to include selfloops.
     |      clique_node_type: Optional[&str]
     |          The node type to use for the left clique. By default 'clique'.
     |      chain_node_type: Optional[&str]
     |          The node type to use for the chain. By default 'chain'.
     |      clique_edge_type: Optional[&str]
     |          The node type to use for the left clique. By default 'clique'.
     |      chain_edge_type: Optional[&str]
     |          The node type to use for the chain. By default 'chain'.
     |      clique_weight: Optional[float]
     |          The weight to use for the edges in the left clique. By default None.
     |      chain_weight: Optional[float]
     |          The weight to use for the edges in the chain. By default None.
     |      directed: Optional[bool]
     |          Whether the graph is to built as directed. By default false.
     |      name: Optional[&str]
     |          Name of the graph. By default 'Lollipop'.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the edge weights are provided only for a subset.
     |  
     |  generate_random_connected_graph(random_state, minimum_node_id, minimum_node_sampling, maximum_node_sampling, number_of_nodes, include_selfloops, node_type, edge_type, weight, directed, name)
     |      Creates new random connected graph with given sizes and types.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |      minimum_node_id: int
     |          The minimum node ID for the connected graph.
     |      minimum_node_sampling: int
     |          The minimum amount of nodes to sample per node.
     |      maximum_node_sampling: int
     |          The maximum amount of nodes to sample per node.
     |      number_of_nodes: Optional[int]
     |          Number of nodes in the chain. By default 10.
     |      include_selfloops: Optional[bool]
     |          Whether to include selfloops.
     |      node_type: Optional[&str]
     |          The node type to use for the chain. By default 'chain'.
     |      edge_type: Optional[&str]
     |          The node type to use for the chain. By default 'chain'.
     |      weight: Optional[float]
     |          The weight to use for the edges in the chain. By default None.
     |      directed: Optional[bool]
     |          Whether the graph is to built as directed. By default false.
     |      name: Optional[&str]
     |          Name of the graph. By default 'Chain'.
     |  
     |  generate_random_spanning_tree(random_state, minimum_node_id, number_of_nodes, include_selfloops, node_type, edge_type, weight, directed, name)
     |      Creates new random connected graph with given sizes and types.
     |      
     |      Parameters
     |      ----------
     |      random_state: int
     |          The random state to use to reproduce the sampling.
     |      minimum_node_id: int
     |          The minimum node ID for the connected graph.
     |      minimum_node_sampling: int
     |          The minimum amount of nodes to sample per node.
     |      maximum_node_sampling: int
     |          The maximum amount of nodes to sample per node.
     |      number_of_nodes: Optional[int]
     |          Number of nodes in the chain. By default 10.
     |      include_selfloops: Optional[bool]
     |          Whether to include selfloops.
     |      node_type: Optional[&str]
     |          The node type to use for the chain. By default 'chain'.
     |      edge_type: Optional[&str]
     |          The node type to use for the chain. By default 'chain'.
     |      weight: Optional[float]
     |          The weight to use for the edges in the chain. By default None.
     |      directed: Optional[bool]
     |          Whether the graph is to built as directed. By default false.
     |      name: Optional[&str]
     |          Name of the graph. By default 'Chain'.
     |  
     |  generate_squared_lattice_graph(sides, minimum_node_id, node_type, weight, directed, name)
     |      Creates new squared lattice graph with given sizes and types.
     |      
     |      Parameters
     |      ----------
     |      sides: List[int]
     |          Sides of the hyper-dimensional lattice with square cell.
     |      minimum_node_id: Optional[int]
     |          Minimum node ID to start with. May be needed when chaining graphs. By default 0.
     |      node_type: Optional[&str]
     |          The node type to use for the squared lattice. By default 'squared_lattice'.
     |      weight: Optional[float]
     |          The weight to use for the edges in the left clique. By default None.
     |      directed: Optional[bool]
     |          Whether the graph is to built as directed. By default false.
     |      name: Optional[&str]
     |          Name of the graph. By default 'Lollipop'.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the edge weights are provided only for a subset.
     |  
     |  generate_star_graph(minimum_node_id, number_of_nodes, include_selfloops, node_type, edge_type, weight, directed, name)
     |      Creates new star graph with given sizes and types.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_id: Optional[int]
     |          Minimum node ID to start with. May be needed when circleing graphs. By default 0.
     |      number_of_nodes: Optional[int]
     |          Number of nodes in the star. By default 10.
     |      include_selfloops: Optional[bool]
     |          Whether to include selfloops.
     |      node_type: Optional[&str]
     |          The node type to use for the star. By default 'star'.
     |      edge_type: Optional[&str]
     |          The node type to use for the star. By default 'star'.
     |      weight: Optional[float]
     |          The weight to use for the edges in the star. By default None.
     |      directed: Optional[bool]
     |          Whether the graph is to built as directed. By default false.
     |      name: Optional[&str]
     |          Name of the graph. By default 'Star'.
     |  
     |  generate_wheel_graph(minimum_node_id, number_of_nodes, include_selfloops, node_type, edge_type, weight, directed, name)
     |      Creates new wheel graph with given sizes and types.
     |      
     |      Parameters
     |      ----------
     |      minimum_node_id: Optional[int]
     |          Minimum node ID to start with. May be needed when circleing graphs. By default 0.
     |      number_of_nodes: Optional[int]
     |          Number of nodes in the wheel. By default 10.
     |      include_selfloops: Optional[bool]
     |          Whether to include selfloops.
     |      node_type: Optional[&str]
     |          The node type to use for the wheel. By default 'wheel'.
     |      edge_type: Optional[&str]
     |          The node type to use for the wheel. By default 'wheel'.
     |      weight: Optional[float]
     |          The weight to use for the edges in the wheel. By default None.
     |      directed: Optional[bool]
     |          Whether the graph is to built as directed. By default false.
     |      name: Optional[&str]
     |          Name of the graph. By default 'Wheel'.
    
    class GraphBuilder(builtins.object)
     |  Methods defined here:
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  add_edge(self, /, src, dst, edge_type, weight)
     |      Add an edge to the graph
     |      
     |      Parameters
     |      ----------
     |      src: str
     |          The name of the source node
     |      dst: str
     |          The name of the destination node
     |      edge_type: Optional[str]
     |          The name of the edge_type, if present
     |      weight: Optional[float]
     |          The weight of the edge, if present
     |  
     |  add_node(self, /, name, node_type)
     |      Add a node to the graph, if the node is already present in the graph it will be overwritten
     |      
     |      Parameters
     |      ----------
     |      name: str
     |          The name of the node
     |      node_type: Optional[List[str]]
     |          List of node type names, if present
     |  
     |  build(self, /)
     |      Consume the edges and nodes to create a new graph
     |  
     |  remove_edge(self, /, src, dst, edge_type, weight)
     |      Remove an edge to the graph, if the edge is not present this will do nothing.
     |      
     |      Parameters
     |      ----------
     |      src: str
     |          The name of the source node
     |      dst: str
     |          The name of the destination node
     |      edge_type: Optional[str]
     |          The name of the edge_type, if present
     |      weight: Optional[float]
     |          The weight of the edge, if present
     |  
     |  remove_node(self, /, name)
     |      Remove a node from the graph, if the node does not exist, this method does nothing
     |      
     |      Parameters
     |      ----------
     |      name: str
     |          The name of the node
     |  
     |  set_default_weight(self, /, default_weight)
     |      Set a default missing weight to be used if only some edges have weights
     |      
     |      Parameters
     |      ----------
     |      default_weight: float
     |          set the weight to assign by default at edges
     |  
     |  set_directed(self, /, is_directed)
     |      Set if the graph will be directed or undirected
     |      
     |      Parameters
     |      ----------
     |      is_directed: bool
     |          the generated graph will be directed if this is true
     |  
     |  set_name(self, /, name)
     |      Set the name of the graph that will be created
     |      
     |      Parameters
     |      ----------
     |      name: str
     |          The name of the graph
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class GraphCSVBuilder(builtins.object)
     |  Methods defined here:
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  add_edge(self, /, src, dst, edge_type, weight)
     |      Add an edge to the graph
     |      
     |      Parameters
     |      ----------
     |      src: str
     |          The name of the source node
     |      dst: str
     |          The name of the destination node
     |      edge_type: Optional[str]
     |          The name of the edge_type, if present
     |      weight: Optional[float]
     |          The weight of the edge, if present
     |  
     |  add_node(self, /, name, node_type)
     |      Add a node to the graph, if the node is already present in the graph it will be overwritten
     |      
     |      Parameters
     |      ----------
     |      name: str
     |          The name of the node
     |      node_type: Optional[List[str]]
     |          List of node type names, if present
     |  
     |  finish(self, /)
     |      Flush the changes to the files and print the example code on how the
     |      graph can be loaded using `Graph.from_csv
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class GraphVisualizer(builtins.object)
     |  GraphVisualizer(graph: Union[ensmallen.Graph, str], support: Optional[ensmallen.Graph] = None, subgraph_of_interest: Optional[ensmallen.Graph] = None, repository: Optional[str] = None, version: Optional[str] = None, decomposition_method: str = 'TSNE', n_components: int = 2, rotate: bool = False, video_format: str = 'webm', duration: int = 10, fps: int = 24, node_embedding_method_name: str = 'auto', edge_embedding_methods: Union[List[str], str] = 'Concatenate', minimum_node_degree: int = 0, maximum_node_degree: Optional[int] = None, only_from_same_component: Union[bool, str] = 'auto', source_node_types_names: Union[str, List[str], NoneType] = None, destination_node_types_names: Union[str, List[str], NoneType] = None, source_edge_types_names: Union[str, List[str], NoneType] = None, destination_edge_types_names: Union[str, List[str], NoneType] = None, source_nodes_prefixes: Union[str, List[str], NoneType] = None, destination_nodes_prefixes: Union[str, List[str], NoneType] = None, edge_type_names: Optional[List[Optional[str]]] = None, show_graph_name: Union[str, bool] = 'auto', number_of_columns_in_legend: int = 2, show_embedding_method: bool = True, show_edge_embedding_methods: bool = True, show_separability_considerations_explanation: bool = True, show_heatmaps_description: bool = True, show_non_existing_edges_sampling_description: bool = True, automatically_display_on_notebooks: bool = True, number_of_subsampled_nodes: int = 20000, number_of_subsampled_edges: int = 10000, number_of_subsampled_negative_edges: int = 10000, number_of_holdouts_for_cluster_comments: int = 5, random_state: int = 42, decomposition_kwargs: Optional[Dict] = None, verbose: bool = False)
     |  
     |  Tools to visualize the graph embeddings.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, graph: Union[ensmallen.Graph, str], support: Optional[ensmallen.Graph] = None, subgraph_of_interest: Optional[ensmallen.Graph] = None, repository: Optional[str] = None, version: Optional[str] = None, decomposition_method: str = 'TSNE', n_components: int = 2, rotate: bool = False, video_format: str = 'webm', duration: int = 10, fps: int = 24, node_embedding_method_name: str = 'auto', edge_embedding_methods: Union[List[str], str] = 'Concatenate', minimum_node_degree: int = 0, maximum_node_degree: Optional[int] = None, only_from_same_component: Union[bool, str] = 'auto', source_node_types_names: Union[str, List[str], NoneType] = None, destination_node_types_names: Union[str, List[str], NoneType] = None, source_edge_types_names: Union[str, List[str], NoneType] = None, destination_edge_types_names: Union[str, List[str], NoneType] = None, source_nodes_prefixes: Union[str, List[str], NoneType] = None, destination_nodes_prefixes: Union[str, List[str], NoneType] = None, edge_type_names: Optional[List[Optional[str]]] = None, show_graph_name: Union[str, bool] = 'auto', number_of_columns_in_legend: int = 2, show_embedding_method: bool = True, show_edge_embedding_methods: bool = True, show_separability_considerations_explanation: bool = True, show_heatmaps_description: bool = True, show_non_existing_edges_sampling_description: bool = True, automatically_display_on_notebooks: bool = True, number_of_subsampled_nodes: int = 20000, number_of_subsampled_edges: int = 10000, number_of_subsampled_negative_edges: int = 10000, number_of_holdouts_for_cluster_comments: int = 5, random_state: int = 42, decomposition_kwargs: Optional[Dict] = None, verbose: bool = False)
     |      Create new GraphVisualizer object.
     |      
     |      Parameters
     |      --------------------------
     |      graph: Union[Graph, str]
     |          The graph to visualize.
     |          If a string was provided, we try to retrieve the given
     |          graph name using the Ensmallen automatic graph retrieval.
     |      support: Optional[Graph] = None
     |          The support graph to use to compute metrics such as degrees,
     |          Adamic-Adar and so on. This is useful when the graph to be
     |          visualized is a small component of a larger graph, for instance
     |          when visualizing the test graph of an holdout where most edges
     |          are left in the training graph.
     |          Without providing a support graph, it would not be possible
     |          to visualize the correct metrics of the provided graph as we
     |          would have to assume that this graph is a `true` graph by itself,
     |          and not a subgraph of a larger one.
     |          The support graph is also employed in the sampling of the negative
     |          edges, so to avoid sampling edges that exist in the original graph,
     |          and is also used in the computation of the embedding when requested.
     |          This provided graph must share the same vocabulary of the support graph.
     |          When visualizing an holdout, the train graph should be used as support
     |          for the validation or test graphs.
     |      subgraph_of_interest: Optional[Graph] = None
     |          The graph to use to sample the negative edges.
     |          This graph's node degree distribution is expected to be the one best capturing
     |          the are of interest of a task (for instance a subgraph edge prediction)
     |          and is therefore best suited to sample the negative edges.
     |          If we were to use the support graph for cases of this type we would
     |          sample negative edges that are far away from the positive edges we are
     |          taking into consideration, making the visualization biased and make the
     |          task look artificially easy.
     |          We expected for the provided graph to be contained in this subgraph of interest.
     |      repository: Optional[str] = None
     |          Repository of the provided graph.
     |          This only applies when the provided graph is a
     |          graph name that can be retrieved using ensmallen.
     |          Providing this parameter with an actual graph
     |          object will cause an exception to be raised.
     |      version: Optional[str] = None
     |          version of the provided graph.
     |          This only applies when the provided graph is a
     |          graph name that can be retrieved using ensmallen.
     |          Providing this parameter with an actual graph
     |          object will cause an exception to be raised.
     |      decomposition_method: str = "TSNE",
     |          The decomposition method to use.
     |          The supported methods are UMAP, TSNE and PCA.
     |      n_components: int = 2,
     |          Number of components to reduce the image to.
     |          Currently we support 2D, 3D and 4D visualizations.
     |      rotate: bool = False,
     |          Whether to create a rotating animation.
     |      video_format: str = "webm"
     |          What video format to use for the animations.
     |      duration: int = 15,
     |          Duration of the animation in seconds.
     |      fps: int = 24,
     |          Number of frames per second in animations.
     |      node_embedding_method_name: str = "auto",
     |          Name of the node embedding method used.
     |          If "auto" is used, then we try to infer the type of
     |          node embedding algorithm used, which in some cases is
     |          recognizable automatically.
     |      edge_embedding_methods: Union[List[str], str] = "Concatenate",
     |          Edge embedding method.
     |          Can either be 'Hadamard', 'Sum', 'Average', 'L1', 'AbsoluteL1', 'L2' or 'Concatenate'.
     |      only_from_same_component: Union[bool, str] = "auto"
     |          Whether to sample negative edges only from the same connected component.
     |          This should generally be set to `True`, but in some corner cases when
     |          the graph to visualize has extremely dense (or very small, like tuples)
     |          components it will raise an exception as it is not possible to sample
     |          negative edges from such densely connected components.
     |          By default, it is set to `auto`, which will set it to `True` if the
     |          graph is smaller than 50M nodes, as computing and masking the connected
     |          components can get expensive on very large graphs, such as WikiData.
     |      minimum_node_degree: Optional[int] = 0
     |          The minimum node degree of either the source or
     |          destination node to be sampled.
     |      maximum_node_degree: Optional[int] = None
     |          The maximum node degree of either the source or
     |          destination node to be sampled.
     |          By default, the number of nodes.
     |      source_node_types_names: Optional[str, List[str]] = None
     |          Node type names of the nodes to be samples as sources.
     |          If a node has any of the provided node types,
     |          it can be sampled as a source node.
     |      destination_node_types_names: Optional[str, List[str]] = None
     |          Node type names of the nodes to be samples as destinations.
     |          If a node has any of the provided node types,
     |          it can be sampled as a destination node.
     |      source_edge_types_names: Optional[str, List[str]] = None
     |          Edge type names of the nodes to be samples as sources.
     |          If a node has any of the provided edge types,
     |          it can be sampled as a source node.
     |      destination_edge_types_names: Optional[str, List[str]] = None
     |          Edge type names of the nodes to be samples as destinations.
     |          If a node has any of the provided edge types,
     |          it can be sampled as a destination node.
     |      source_nodes_prefixes: Optional[str, List[str]] = None
     |          Prefixes of the nodes names to be samples as sources.
     |          If a node starts with any of the provided prefixes,
     |          it can be sampled as a source node.
     |      destination_nodes_prefixes: Optional[str, List[str]] = None
     |          Prefixes of the nodes names to be samples as destinations.
     |          If a node starts with any of the provided prefixes,
     |          it can be sampled as a destinations node.
     |      edge_type_names: Optional[List[Optional[str]]] = None
     |          Edge type names of the edges to show in the positive graph.
     |      show_graph_name: Union[str, bool] = "auto"
     |          Whether to show the graph name in the plots.
     |          By default, it is shown if the graph does not have a trivial
     |          name such as `Graph`.
     |      number_of_columns_in_legend: int = 2
     |          The number of columns to be used with the legend.
     |      show_embedding_method: bool = True
     |          Whether to show the node embedding method.
     |          By default, we show it if we can detect it.
     |      show_edge_embedding_methods: bool = True
     |          Whether to show the edge embedding method.
     |          By default, we show it if we can detect it.
     |      show_separability_considerations_explanation: bool = True
     |          Whether to explain how the separability considerations are obtained
     |          in the captions of the images.
     |      show_heatmaps_description: bool = True
     |          Whether to describe the heatmaps
     |          in the captions of the images.
     |      show_non_existing_edges_sampling_description: bool = True
     |          Whether to describe the modalities used to
     |          sample the negative edges.
     |      automatically_display_on_notebooks: bool = True
     |          Whether to automatically show the plots and the captions
     |          using the display command when in jupyter notebooks.
     |      number_of_subsampled_nodes: int = 20_000
     |          Number of points to subsample.
     |          Some graphs have a number of nodes and edges in the millions.
     |          Using non-CUDA versions of TSNE, the dimensionality reduction
     |          procedure can take a considerable amount of time.
     |          For this porpose, we include the possibility to subsample the
     |          points to the given number.
     |      number_of_subsampled_edges: int = 20_000
     |          Number of edges to subsample.
     |          The same considerations described for the subsampled nodes number
     |          also apply for the edges number.
     |          Not subsampling the edges in most graphs is a poor life choice.
     |      number_of_subsampled_negative_edges: int = 20_000
     |          Number of edges to subsample.
     |          The same considerations described for the subsampled nodes number
     |          also apply for the edges number.
     |          Not subsampling the edges in most graphs is a poor life choice.
     |      number_of_holdouts_for_cluster_comments: int = 5
     |          Number of holdouts to execute for getting the comments
     |          about clusters separability.
     |      random_state: int = 42
     |          The random state to reproduce the visualizations.
     |      decomposition_kwargs: Optional[Dict] = None
     |          Kwargs to forward to the selected decomposition method.
     |      verbose: bool = False
     |          Whether to show loading bars and logs.
     |      
     |      Raises
     |      ---------------------------
     |      ValueError,
     |          If the target decomposition size is not supported.
     |      ModuleNotFoundError,
     |          If TSNE decomposition has been required and no module supporting
     |          it is installed.
     |  
     |  annotate_nodes(self, figure: matplotlib.figure.Figure, axes: matplotlib.axes._axes.Axes, points: numpy.ndarray) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Annotate nodes of provided graph.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Figure,
     |          Figure to use to plot.
     |      axes: Axes,
     |          Axes to use to plot.
     |      points: np.ndarray,
     |          Points to plot.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  automatically_detect_embedding_method(self, node_embedding: numpy.ndarray) -> Optional[str]
     |      Detect node embedding method using heuristics, where possible.
     |  
     |  decompose(self, X: numpy.ndarray) -> numpy.ndarray
     |      Return requested decomposition of given array.
     |      
     |      Parameters
     |      -----------------------
     |      X: np.ndarray,
     |          The data to embed.
     |      
     |      Raises
     |      -----------------------
     |      ValueError,
     |          If the given vector has less components than the required
     |          decomposition target.
     |      
     |      Returns
     |      -----------------------
     |      The obtained decomposition.
     |  
     |  fit_and_plot_all(self, node_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, node_type_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, edge_type_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, edge_features: Union[Type[embiggen.utils.abstract_edge_feature.AbstractEdgeFeature], pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, number_of_columns: int = 4, show_letters: bool = True, include_distribution_plots: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Fits and plots all available features of the graph.
     |      
     |      Parameters
     |      -------------------------
     |      node_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The node features to use.
     |      node_type_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The node type features to use.
     |      edge_type_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The edge type features to use.
     |      edge_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The edge features to use.
     |      number_of_columns: int = 4
     |          Number of columns to use for the layout.
     |      show_letters: bool = True
     |          Whether to show letters on the top left of the subplots.
     |      include_distribution_plots: bool = True
     |          Whether to include the distribution plots for the degrees
     |          and the edge weights, if they are present.
     |  
     |  fit_edges(self, node_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, node_type_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, edge_type_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, edge_features: Union[Type[embiggen.utils.abstract_edge_feature.AbstractEdgeFeature], pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None)
     |      Executes fitting for plotting edge embeddings.
     |      
     |      Parameters
     |      -------------------------
     |      node_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The node features to use.
     |      node_type_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The node type features to use.
     |      edge_type_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The edge type features to use.
     |      edge_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The edge features to use.
     |  
     |  fit_negative_and_positive_edges(self, node_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, node_type_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, edge_type_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, edge_features: Union[Type[embiggen.utils.abstract_edge_feature.AbstractEdgeFeature], pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None)
     |      Executes fitting for plotting negative edge embeddings.
     |      
     |      Parameters
     |      -------------------------
     |      embedding: Optional[Union[pd.DataFrame, np.ndarray, str]] = None
     |          Embedding of the graph nodes.
     |          If a string is provided, we will run the node embedding
     |          from one of the available methods.
     |      **embedding_kwargs: Dict
     |          Kwargs to be forwarded to the node embedding algorithm.
     |  
     |  fit_nodes(self, node_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None, node_type_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType] = None)
     |      Executes fitting for plotting node embeddings.
     |      
     |      Parameters
     |      -------------------------
     |      node_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The node features to use.
     |      node_type_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]] = None
     |          The node type features to use.
     |  
     |  get_decomposition_method(self) -> Callable
     |  
     |  get_heatmaps_comments(self, letters: Optional[List[str]] = None) -> str
     |      Returns description of the heatmaps for the provided letters.
     |  
     |  get_non_existing_edges_sampling_description(self) -> str
     |      Returns description on how the non-existing edges are sampled.
     |  
     |  get_number_of_subsampled_nodes(self) -> int
     |      Return the number of subsampled nodes.
     |  
     |  get_separability_comments_description(self, letters: Optional[List[str]] = None) -> str
     |      Returns separability comments description for the provided letters.
     |  
     |  iterate_subsampled_node_ids(self) -> Iterator[int]
     |      Return iterator over the node IDs of the subsampled graph.
     |  
     |  plot_approximated_closeness_centrality(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', use_log_scale: bool = True, show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', annotate_nodes: Union[str, bool] = 'auto', show_edges: Union[str, bool] = 'auto', edge_scatter_kwargs: Optional[Dict] = None, **kwargs: Dict)
     |      Plot approximated closeness centrality heatmap.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      use_log_scale: bool = True,
     |          Whether to use log scale.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      show_edges: Union[str, bool] = "auto",
     |          Whether to show edges between the different nodes
     |          shown in the scatter plot.
     |          It is enabled by default with `auto` when the graph
     |          has less than 50 nodes.
     |      edge_scatter_kwargs: Optional[Dict] = None,
     |          Arguments to provide to the scatter plot of the edges
     |          if they were required.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_approximated_closeness_centrality_distribution(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, show_title: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the given graph Approximated Closeness Centrality distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      show_title: bool = True
     |          Wether to show the figure title.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  plot_approximated_harmonic_centrality(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', use_log_scale: bool = True, show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', annotate_nodes: Union[str, bool] = 'auto', show_edges: Union[str, bool] = 'auto', edge_scatter_kwargs: Optional[Dict] = None, **kwargs: Dict)
     |      Plot approximated harmonic centrality heatmap.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      use_log_scale: bool = True,
     |          Whether to use log scale.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      show_edges: Union[str, bool] = "auto",
     |          Whether to show edges between the different nodes
     |          shown in the scatter plot.
     |          It is enabled by default with `auto` when the graph
     |          has less than 50 nodes.
     |      edge_scatter_kwargs: Optional[Dict] = None,
     |          Arguments to provide to the scatter plot of the edges
     |          if they were required.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_approximated_harmonic_centrality_distribution(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, show_title: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the given graph Approximated Harmonic Centrality distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      show_title: bool = True
     |          Wether to show the figure title.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  plot_connected_components(self, k: int = 7, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, other_label: str = 'Other {} components', train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', annotate_nodes: Union[str, bool] = 'auto', show_edges: Union[str, bool] = 'auto', edge_scatter_kwargs: Optional[Dict] = None, **kwargs) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot common node types of provided graph.
     |      
     |      Parameters
     |      ------------------------------
     |      k: int = 7,
     |          Number of components to visualize.
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      other_label: str = "Other {} components",
     |          Label to use for edges below the top k threshold.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      annotate_nodes: Union[str, bool] = "auto"
     |          Whether to show the node names when plotting them.
     |          It is enabled by default with `auto` when the graph
     |          has less than 50 nodes.
     |      show_edges: Union[str, bool] = "auto"
     |          Whether to show edges between the different nodes
     |          shown in the scatter plot.
     |          It is enabled by default with `auto` when the graph
     |          has less than 50 nodes.
     |      edge_scatter_kwargs: Optional[Dict] = None,
     |          Arguments to provide to the scatter plot of the edges
     |          if they were required.
     |      **kwargs: Dict,
     |          Arguments to pass to the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      ValueError,
     |          If given k is greater than maximum supported value (10).
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_dot(self, engine: str = 'neato')
     |      Return dot plot of the current graph.
     |      
     |      Parameters
     |      ------------------------------
     |      engine: str = "neato"
     |          The engine to use to visualize the graph.
     |      
     |      Raises
     |      ------------------------------
     |      ModuleNotFoundError
     |          If graphviz is not installed.
     |  
     |  plot_edge_segments(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, **kwargs: Dict) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot edge segments between the nodes of the graph.
     |      
     |      Parameters
     |      ------------------------
     |      figure: Optional[Figure] = None
     |          The figure object to plot over.
     |          If None, a new figure is created automatically and returned.
     |      axes: Optional[Axes] = None
     |          The axes object to plot over.
     |          If None, a new axes is created automatically and returned.
     |      scatter_kwargs: Optional[Dict] = None
     |          Dictionary of parameters to pass to the scattering of the edges.
     |      **kwargs: Dict
     |          Dictionary of parameters to pass to the instantiation of the new figure and axes if one was not initially provided.
     |      
     |      Returns
     |      ------------------------
     |      Tuple with either the provided or created figure and axes.
     |  
     |  plot_edge_types(self, edge_type_predictions: Optional[List[int]] = None, k: int = 7, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, other_label: str = 'Other {} edge types', train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', **kwargs: Dict)
     |      Plot common edge types of provided graph.
     |      
     |      Parameters
     |      ------------------------------
     |      edge_type_predictions: Optional[List[int]] = None,
     |          Predictions of the edge types.
     |      k: int = 7,
     |          Number of edge types to visualize.
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      other_label: str = "Other {} edge types",
     |          Label to use for edges below the top k threshold.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption for the image.
     |      loc: str = 'best'
     |          Position for the legend.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If the graph does not have edge types.
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      ValueError,
     |          If given k is greater than maximum supported value (10).
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_edge_weight_distribution(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the given graph node degree distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  plot_edge_weights(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', **kwargs: Dict)
     |      Plot common edge types of provided graph.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption for this plot.
     |      loc: str = 'best'
     |          Position for the legend.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_edges(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, loc: str = 'best', **kwargs: Dict) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot edge embedding of provided graph.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      loc: str = 'best'
     |          Position for the legend.
     |      **kwargs: Dict,
     |          Arguments to pass to the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_node_degree_distribution(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, show_title: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the given graph node degree distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      show_title: bool = True
     |          Wether to show the figure title.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  plot_node_degrees(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', use_log_scale: bool = True, show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', annotate_nodes: Union[str, bool] = 'auto', show_edges: Union[str, bool] = 'auto', edge_scatter_kwargs: Optional[Dict] = None, **kwargs: Dict)
     |      Plot node degrees heatmap.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      use_log_scale: bool = True,
     |          Whether to use log scale.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      show_edges: Union[str, bool] = "auto",
     |          Whether to show edges between the different nodes
     |          shown in the scatter plot.
     |          It is enabled by default with `auto` when the graph
     |          has less than 50 nodes.
     |      edge_scatter_kwargs: Optional[Dict] = None,
     |          Arguments to provide to the scatter plot of the edges
     |          if they were required.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_node_ontologies(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, other_label: str = 'Other {} ontologies', train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', show_edges: Union[str, bool] = 'auto', edge_scatter_kwargs: Optional[Dict] = None, annotate_nodes: Union[str, bool] = 'auto', **kwargs) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot common node types of provided graph.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      other_label: str = "Other {} node ontologies"
     |          Label to use for edges below the top k threshold.
     |      train_indices: Optional[np.ndarray] = None
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o"
     |          The marker to use to draw the training points.
     |      test_marker: str = "X"
     |          The marker to use to draw the test points.
     |      show_title: bool = True
     |          Whether to show the figure title.
     |      show_legend: bool = True
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      show_edges: Union[str, bool] = "auto",
     |          Whether to show edges between the different nodes
     |          shown in the scatter plot.
     |          It is enabled by default with `auto` when the graph
     |          has less than 50 nodes.
     |      edge_scatter_kwargs: Optional[Dict] = None,
     |          Arguments to provide to the scatter plot of the edges
     |          if they were required.
     |      **kwargs: Dict,
     |          Arguments to pass to the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError
     |          If node fitting was not yet executed.
     |      ValueError
     |          If the graph does not have node ontologies.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_node_squares(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', use_log_scale: bool = True, show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', annotate_nodes: Union[str, bool] = 'auto', show_edges: Union[str, bool] = 'auto', edge_scatter_kwargs: Optional[Dict] = None, **kwargs: Dict)
     |      Plot node squares heatmap.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      use_log_scale: bool = True,
     |          Whether to use log scale.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      show_edges: Union[str, bool] = "auto",
     |          Whether to show edges between the different nodes
     |          shown in the scatter plot.
     |          It is enabled by default with `auto` when the graph
     |          has less than 50 nodes.
     |      edge_scatter_kwargs: Optional[Dict] = None,
     |          Arguments to provide to the scatter plot of the edges
     |          if they were required.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_node_triangles(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', use_log_scale: bool = True, show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', annotate_nodes: Union[str, bool] = 'auto', show_edges: Union[str, bool] = 'auto', edge_scatter_kwargs: Optional[Dict] = None, **kwargs: Dict)
     |      Plot Triangless heatmap.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      use_log_scale: bool = True,
     |          Whether to use log scale.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      show_edges: Union[str, bool] = "auto",
     |          Whether to show edges between the different nodes
     |          shown in the scatter plot.
     |          It is enabled by default with `auto` when the graph
     |          has less than 50 nodes.
     |      edge_scatter_kwargs: Optional[Dict] = None,
     |          Arguments to provide to the scatter plot of the edges
     |          if they were required.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_node_types(self, node_type_predictions: Optional[List[int]] = None, k: int = 7, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, other_label: str = 'Other {} node types', train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', show_edges: Union[str, bool] = 'auto', edge_scatter_kwargs: Optional[Dict] = None, annotate_nodes: Union[str, bool] = 'auto', **kwargs) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot common node types of provided graph.
     |      
     |      Parameters
     |      ------------------------------
     |      node_type_predictions: Optional[List[int]] = None,
     |          Predictions of the node types.
     |      k: int = 7,
     |          Number of node types to visualize.
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      other_label: str = "Other {} node types"
     |          Label to use for edges below the top k threshold.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      show_edges: Union[str, bool] = "auto",
     |          Whether to show edges between the different nodes
     |          shown in the scatter plot.
     |          It is enabled by default with `auto` when the graph
     |          has less than 50 nodes.
     |      edge_scatter_kwargs: Optional[Dict] = None,
     |          Arguments to provide to the scatter plot of the edges
     |          if they were required.
     |      **kwargs: Dict,
     |          Arguments to pass to the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      ValueError,
     |          If given k is greater than maximum supported value (10).
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_nodes(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, loc: str = 'best', annotate_nodes: Union[str, bool] = 'auto', show_edges: Union[str, bool] = 'auto', edge_scatter_kwargs: Optional[Dict] = None, **kwargs: Dict) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot nodes of provided graph.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      loc: str = 'best'
     |          Position for the legend.
     |      annotate_nodes: Union[str, bool] = "auto",
     |          Whether to show the node name when scattering them.
     |          The default behaviour, "auto", means that it will
     |          enable this feature automatically when the graph has
     |          less than 100 nodes.
     |      show_edges: Union[str, bool] = "auto",
     |          Whether to show edges between the different nodes
     |          shown in the scatter plot.
     |          It is enabled by default with `auto` when the graph
     |          has less than 50 nodes.
     |      edge_scatter_kwargs: Optional[Dict] = None,
     |          Arguments to provide to the scatter plot of the edges
     |          if they were required.
     |      **kwargs: Dict,
     |          Arguments to pass to the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_positive_and_negative_adamic_adar_histogram(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the positive and negative edges Adamic Adar metric distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  plot_positive_and_negative_edges(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', **kwargs: Dict) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot edge embedding of provided graph.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      **kwargs: Dict,
     |          Arguments to pass to the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_positive_and_negative_edges_adamic_adar(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', **kwargs: Dict)
     |      Plot Adamic Adar metric heatmap for sampled existent and non-existent edges.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_positive_and_negative_edges_cosine_similarity(self, node_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType], node_type_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType], figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', **kwargs: Dict)
     |      Plot Cosine similarity heatmap for sampled existent and non-existent edges.
     |      
     |      Parameters
     |      ------------------------------
     |      node_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]]
     |          The node features to use.
     |      node_type_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]]
     |          The node type features to use.
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_positive_and_negative_edges_cosine_similarity_histogram(self, node_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType], node_type_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType], figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the positive and negative edges Cosine similarity distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      node_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]]
     |          The node features to use.
     |      node_type_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]]
     |          The node type features to use.
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  plot_positive_and_negative_edges_euclidean_distance(self, node_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType], node_type_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType], figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', **kwargs: Dict)
     |      Plot L2 Distance heatmap for sampled existent and non-existent edges.
     |      
     |      Parameters
     |      ------------------------------
     |      node_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]]
     |          The node features to use.
     |      node_type_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]]
     |          The node type features to use.
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_positive_and_negative_edges_euclidean_distance_histogram(self, node_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType], node_type_features: Union[pandas.core.frame.DataFrame, numpy.ndarray, List[Union[pandas.core.frame.DataFrame, numpy.ndarray]], NoneType], figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the positive and negative edges Euclidean distance distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      node_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]]
     |          The node features to use.
     |      node_type_features: Optional[Union[pd.DataFrame, np.ndarray, List[Union[pd.DataFrame, np.ndarray]]]]
     |          The node type features to use.
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  plot_positive_and_negative_edges_jaccard_coefficient(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', **kwargs: Dict)
     |      Plot Jaccard Coefficient metric heatmap for sampled existent and non-existent edges.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_positive_and_negative_edges_preferential_attachment(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', **kwargs: Dict)
     |      Plot Preferential Attachment metric heatmap for sampled existent and non-existent edges.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_positive_and_negative_edges_resource_allocation_index(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.axes._axes.Axes] = None, scatter_kwargs: Optional[Dict] = None, train_indices: Optional[numpy.ndarray] = None, test_indices: Optional[numpy.ndarray] = None, train_marker: str = 'o', test_marker: str = 'X', show_title: bool = True, show_legend: bool = True, return_caption: bool = True, loc: str = 'best', **kwargs: Dict)
     |      Plot Resource Allocation Index metric heatmap for sampled existent and non-existent edges.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      scatter_kwargs: Optional[Dict] = None,
     |          Kwargs to pass to the scatter plot call.
     |      train_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the training marker.
     |          If None, all points are drawn using the training marker.
     |      test_indices: Optional[np.ndarray] = None,
     |          Indices to draw using the test marker.
     |          If None, while providing the train indices,
     |      train_marker: str = "o",
     |          The marker to use to draw the training points.
     |      test_marker: str = "X",
     |          The marker to use to draw the test points.
     |      show_title: bool = True,
     |          Whether to show the figure title.
     |      show_legend: bool = True,
     |          Whether to show the legend.
     |      return_caption: bool = True,
     |          Whether to return a caption.
     |      loc: str = 'best'
     |          Position for the legend.
     |      **kwargs: Dict,
     |          Additional kwargs for the subplots.
     |      
     |      Raises
     |      ------------------------------
     |      ValueError,
     |          If edge fitting was not yet executed.
     |      
     |      Returns
     |      ------------------------------
     |      Figure and Axis of the plot.
     |  
     |  plot_positive_and_negative_jaccard_coefficient_histogram(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the positive and negative edges Jaccard Coefficient metric distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  plot_positive_and_negative_preferential_attachment_histogram(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the positive and negative edges Adamic Adar metric distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  plot_positive_and_negative_resource_allocation_index_histogram(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the positive and negative edges Resource Allocation Index metric distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  plot_square_distribution(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, show_title: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the given graph square distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      show_title: bool = True
     |          Wether to show the figure title.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  plot_triangle_distribution(self, figure: Optional[matplotlib.figure.Figure] = None, axes: Optional[matplotlib.figure.Figure] = None, apply_tight_layout: bool = True, show_title: bool = True, return_caption: bool = True) -> Tuple[matplotlib.figure.Figure, matplotlib.axes._axes.Axes]
     |      Plot the given graph triangle distribution.
     |      
     |      Parameters
     |      ------------------------------
     |      figure: Optional[Figure] = None,
     |          Figure to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      axes: Optional[Axes] = None,
     |          Axes to use to plot. If None, a new one is created using the
     |          provided kwargs.
     |      apply_tight_layout: bool = True,
     |          Whether to apply the tight layout on the matplotlib
     |          Figure object.
     |      show_title: bool = True
     |          Wether to show the figure title.
     |      return_caption: bool = True,
     |          Whether to return a caption for the plot.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  DEFAULT_EDGES_SCATTER_KWARGS = {'alpha': 0.5}
     |  
     |  DEFAULT_SCATTER_KWARGS = {'alpha': 0.7, 's': 5}
     |  
     |  DEFAULT_SUBPLOT_KWARGS = {'dpi': 200, 'figsize': (7, 7)}
    
    class NodeTuple(builtins.object)
     |  Methods defined here:
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  get_node_ids(self, /)
     |      Return the node IDs of the nodes composing the tuple
     |  
     |  get_root_node_id(self, /)
     |      Return the first node ID of the tuple
     |  
     |  get_root_node_name(self, /)
     |      Return the first node name of the tuple
     |  
     |  len(self, /)
     |      Return length of the tuple
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class ShortestPathsDjkstra(builtins.object)
     |  Methods defined here:
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  get_distance_from_node_id(self, /, node_id)
     |  
     |  get_eccentricity(self, /)
     |  
     |  get_log_total_distance(self, /)
     |  
     |  get_median_point(self, /, dst_node_id)
     |  
     |  get_most_distant_node(self, /)
     |  
     |  get_number_of_shortest_paths(self, /)
     |      Returns the number of shortest paths starting from the root node
     |  
     |  get_number_of_shortest_paths_from_node_id(self, /, node_id)
     |      Returns the number of shortest paths passing through the given node.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node id.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If neither predecessors nor distances were computed for this BFS.
     |      ValueError
     |          If the given node ID does not exist in the current graph instance.
     |  
     |  get_parent_from_node_id(self, /, node_id)
     |  
     |  get_point_at_given_distance_on_shortest_path(self, /, dst_node_id, distance)
     |      Returns node at just before given distance on minimum path to given destination node.
     |      
     |      Parameters
     |      ----------
     |      dst_node_id: int
     |          The node to start computing predecessors from.
     |      distance: float
     |          The distance to aim for.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the predecessors vector was not requested.
     |  
     |  get_successors_from_node_id(self, /, source_node_id)
     |      Return list of successors of a given node.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          The node for which to return the successors.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node ID does not exist in the graph.
     |  
     |  get_total_distance(self, /)
     |  
     |  has_path_to_node_id(self, /, node_id)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class ShortestPathsResultBFS(builtins.object)
     |  Methods defined here:
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  get_ancestors_jaccard_index(self, /, first_node_id, second_node_id)
     |      Return Ancestors Jaccard Index.
     |      
     |      Parameters
     |      ----------
     |      first_node_id: int
     |          The first node for which to compute the predecessors Jaccard index.
     |      second_node_id: int
     |          The second node for which to compute the predecessors Jaccard index.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node IDs do not exist in the graph.
     |  
     |  get_distance_from_node_id(self, /, node_id)
     |  
     |  get_distances(self, /)
     |  
     |  get_eccentricity(self, /)
     |  
     |  get_kth_point_on_shortest_path(self, /, dst_node_id, k)
     |      Returns node at the `len - k` position on minimum path to given destination node.
     |      
     |      Parameters
     |      ----------
     |      dst_node_id: int
     |          The node to start computing predecessors from.
     |      k: int
     |          Steps to go back.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the predecessors vector was not requested.
     |  
     |  get_median_point(self, /, dst_node_id)
     |  
     |  get_median_point_to_most_distant_node(self, /)
     |  
     |  get_most_distant_node(self, /)
     |  
     |  get_number_of_shortest_paths(self, /)
     |      Returns the number of shortest paths starting from the root node.
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If neither predecessors nor distances were computed for this BFS.
     |  
     |  get_number_of_shortest_paths_from_node_id(self, /, node_id)
     |      Returns the number of shortest paths passing through the given node.
     |      
     |      Parameters
     |      ----------
     |      node_id: int
     |          The node id.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If neither predecessors nor distances were computed for this BFS.
     |      ValueError
     |          If the given node ID does not exist in the current graph instance.
     |  
     |  get_parent_from_node_id(self, /, node_id)
     |  
     |  get_predecessors(self, /)
     |  
     |  get_predecessors_from_node_id(self, /, source_node_id)
     |      Return list of predecessors of a given node.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          The node for which to return the predecessors.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node ID does not exist in the graph.
     |  
     |  get_shared_ancestors_size(self, /, first_node_id, second_node_id)
     |      Return Shared Ancestors number.
     |      
     |      Parameters
     |      ----------
     |      first_node_id: int
     |          The first node for which to compute the predecessors Jaccard index.
     |      second_node_id: int
     |          The second node for which to compute the predecessors Jaccard index.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node IDs do not exist in the graph.
     |  
     |  get_successors_from_node_id(self, /, source_node_id)
     |      Return list of successors of a given node.
     |      
     |      Parameters
     |      ----------
     |      source_node_id: int
     |          The node for which to return the successors.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the given node ID does not exist in the graph.
     |  
     |  get_unchecked_kth_point_on_shortest_path(self, /, dst_node_id, k)
     |      Returns node at the `len - k` position on minimum path to given destination node.
     |      
     |      Parameters
     |      ----------
     |      dst_node_id: int
     |          The node to start computing predecessors from.
     |      k: int
     |          Steps to go back.
     |      
     |      
     |      Raises
     |      -------
     |      ValueError
     |          If the predecessors vector was not requested.
     |  
     |  has_path_to_node_id(self, /, node_id)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class Star(builtins.object)
     |  Methods defined here:
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  get_first_k_star_node_ids(self, /, k)
     |      Return the first `k` node IDs of the nodes composing the star.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_first_k_star_node_names(self, /, k)
     |      Return the first `k` node names of the nodes composing the star.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_root_node_id(self, /)
     |      Return the central node ID of the Star
     |  
     |  get_root_node_name(self, /)
     |      Return the central node name of the star
     |  
     |  get_star_node_ids(self, /)
     |      Return the node IDs of the nodes composing the Star
     |  
     |  get_star_node_names(self, /)
     |      Return the node names of the nodes composing the star
     |  
     |  len(self, /)
     |      Return length of the Star
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
    
    class Tendril(builtins.object)
     |  Methods defined here:
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  get_first_k_tendril_node_ids(self, /, k)
     |      Return the first `k` node IDs of the nodes composing the Tendril.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_first_k_tendril_node_names(self, /, k)
     |      Return the first `k` node names of the nodes composing the Tendril.
     |      
     |      Parameters
     |      ----------
     |  
     |  get_root_node_id(self, /)
     |      Return the first node ID of the Tendril
     |  
     |  get_root_node_name(self, /)
     |      Return the first node name of the Tendril
     |  
     |  get_tendril_node_ids(self, /)
     |      Return the node IDs of the nodes composing the Tendril
     |  
     |  get_tendril_node_names(self, /)
     |      Return the node names of the nodes composing the Tendril
     |  
     |  len(self, /)
     |      Return length of the Tendril
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.

FUNCTIONS
    get_available_models_for_edge_embedding() -> pandas.core.frame.DataFrame
        Returns dataframe with informations about available models for edge embedding.
    
    get_available_models_for_edge_label_prediction() -> pandas.core.frame.DataFrame
        Returns dataframe with informations about available models for edge-label prediction.
    
    get_available_models_for_edge_prediction() -> pandas.core.frame.DataFrame
        Returns dataframe with informations about available models for edge prediction.
    
    get_available_models_for_node_embedding() -> pandas.core.frame.DataFrame
        Returns dataframe with informations about available models for node embedding.
    
    get_available_models_for_node_label_prediction() -> pandas.core.frame.DataFrame
        Returns dataframe with informations about available models for node-label prediction.
    
    get_models_dataframe() -> pandas.core.frame.DataFrame
        Returns dataframe with informations about available models.
    
    print_version()

DATA
    __all__ = ['GraphVisualizer', 'EmbeddingResult', 'get_models_dataframe...

FILE
    /Users/airbender/code/grape-testing/.venv/lib/python3.9/site-packages/grape/__init__.py


